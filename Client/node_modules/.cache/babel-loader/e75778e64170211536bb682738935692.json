{"ast":null,"code":"\"use strict\";\n/*\r\n * Copyright 2008 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar BarcodeFormat_1 = require(\"../BarcodeFormat\");\n\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\n\nvar OneDReader_1 = require(\"./OneDReader\");\n\nvar EAN13Reader_1 = require(\"./EAN13Reader\");\n\nvar EAN8Reader_1 = require(\"./EAN8Reader\");\n\nvar NotFoundException_1 = require(\"../NotFoundException\");\n/**\r\n * <p>A reader that can read all available UPC/EAN formats. If a caller wants to try to\r\n * read all such formats, it is most efficient to use this implementation rather than invoke\r\n * individual readers.</p>\r\n *\r\n * @author Sean Owen\r\n */\n\n\nvar MultiFormatUPCEANReader =\n/** @class */\nfunction (_super) {\n  __extends(MultiFormatUPCEANReader, _super);\n\n  function MultiFormatUPCEANReader(hints) {\n    var _this = _super.call(this) || this;\n\n    var possibleFormats = hints == null ? null : hints.get(DecodeHintType_1.default.POSSIBLE_FORMATS);\n    var readers = [];\n\n    if (possibleFormats != null) {\n      if (possibleFormats.indexOf(BarcodeFormat_1.default.EAN_13) > -1) {\n        readers.push(new EAN13Reader_1.default());\n      }\n\n      if (possibleFormats.indexOf(BarcodeFormat_1.default.EAN_8) > -1) {\n        readers.push(new EAN8Reader_1.default());\n      } // todo add UPC_A, UPC_E\n\n    }\n\n    if (readers.length === 0) {\n      readers.push(new EAN13Reader_1.default());\n      readers.push(new EAN8Reader_1.default()); // todo add UPC_A, UPC_E\n    }\n\n    _this.readers = readers;\n    return _this;\n  }\n\n  MultiFormatUPCEANReader.prototype.decodeRow = function (rowNumber, row, hints) {\n    var e_1, _a;\n\n    try {\n      for (var _b = __values(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var reader = _c.value;\n\n        try {\n          return reader.decodeRow(rowNumber, row, hints); // TODO ean13MayBeUPCA\n        } catch (err) {// continue;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    throw new NotFoundException_1.default();\n  };\n\n  MultiFormatUPCEANReader.prototype.reset = function () {\n    var e_2, _a;\n\n    try {\n      for (var _b = __values(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var reader = _c.value;\n        reader.reset();\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n  };\n\n  return MultiFormatUPCEANReader;\n}(OneDReader_1.default);\n\nexports.default = MultiFormatUPCEANReader;","map":{"version":3,"sources":["../../../src/core/oned/MultiFormatUPCEANReader.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/*\r\n * Copyright 2008 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __values = (this && this.__values) || function (o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar BarcodeFormat_1 = require(\"../BarcodeFormat\");\r\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\r\nvar OneDReader_1 = require(\"./OneDReader\");\r\nvar EAN13Reader_1 = require(\"./EAN13Reader\");\r\nvar EAN8Reader_1 = require(\"./EAN8Reader\");\r\nvar NotFoundException_1 = require(\"../NotFoundException\");\r\n/**\r\n * <p>A reader that can read all available UPC/EAN formats. If a caller wants to try to\r\n * read all such formats, it is most efficient to use this implementation rather than invoke\r\n * individual readers.</p>\r\n *\r\n * @author Sean Owen\r\n */\r\nvar MultiFormatUPCEANReader = /** @class */ (function (_super) {\r\n    __extends(MultiFormatUPCEANReader, _super);\r\n    function MultiFormatUPCEANReader(hints) {\r\n        var _this = _super.call(this) || this;\r\n        var possibleFormats = hints == null ? null : hints.get(DecodeHintType_1.default.POSSIBLE_FORMATS);\r\n        var readers = [];\r\n        if (possibleFormats != null) {\r\n            if (possibleFormats.indexOf(BarcodeFormat_1.default.EAN_13) > -1) {\r\n                readers.push(new EAN13Reader_1.default());\r\n            }\r\n            if (possibleFormats.indexOf(BarcodeFormat_1.default.EAN_8) > -1) {\r\n                readers.push(new EAN8Reader_1.default());\r\n            }\r\n            // todo add UPC_A, UPC_E\r\n        }\r\n        if (readers.length === 0) {\r\n            readers.push(new EAN13Reader_1.default());\r\n            readers.push(new EAN8Reader_1.default());\r\n            // todo add UPC_A, UPC_E\r\n        }\r\n        _this.readers = readers;\r\n        return _this;\r\n    }\r\n    MultiFormatUPCEANReader.prototype.decodeRow = function (rowNumber, row, hints) {\r\n        var e_1, _a;\r\n        try {\r\n            for (var _b = __values(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var reader = _c.value;\r\n                try {\r\n                    return reader.decodeRow(rowNumber, row, hints);\r\n                    // TODO ean13MayBeUPCA\r\n                }\r\n                catch (err) {\r\n                    // continue;\r\n                }\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        throw new NotFoundException_1.default();\r\n    };\r\n    MultiFormatUPCEANReader.prototype.reset = function () {\r\n        var e_2, _a;\r\n        try {\r\n            for (var _b = __values(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var reader = _c.value;\r\n                reader.reset();\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n    };\r\n    return MultiFormatUPCEANReader;\r\n}(OneDReader_1.default));\r\nexports.default = MultiFormatUPCEANReader;\r\n//# sourceMappingURL=MultiFormatUPCEANReader.js.map"]},"metadata":{},"sourceType":"script"}
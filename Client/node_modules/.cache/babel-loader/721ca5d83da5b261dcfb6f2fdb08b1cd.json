{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * <p>Encapsulates a set of error-correction blocks in one symbol version. Most versions will\r\n * use blocks of differing sizes within one version, so, this encapsulates the parameters for\r\n * each set of blocks. It also holds the number of error-correction codewords per block since it\r\n * will be the same across all blocks within one version.</p>\r\n */\n\nvar ECBlocks =\n/** @class */\nfunction () {\n  function ECBlocks(ecCodewordsPerBlock\n  /*int*/\n  ) {\n    var ecBlocks = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      ecBlocks[_i - 1] = arguments[_i];\n    }\n\n    this.ecCodewordsPerBlock = ecCodewordsPerBlock;\n    this.ecBlocks = ecBlocks;\n  }\n\n  ECBlocks.prototype.getECCodewordsPerBlock = function () {\n    return this.ecCodewordsPerBlock;\n  };\n\n  ECBlocks.prototype.getNumBlocks = function () {\n    var e_1, _a;\n\n    var total = 0;\n    var ecBlocks = this.ecBlocks;\n\n    try {\n      for (var ecBlocks_1 = __values(ecBlocks), ecBlocks_1_1 = ecBlocks_1.next(); !ecBlocks_1_1.done; ecBlocks_1_1 = ecBlocks_1.next()) {\n        var ecBlock = ecBlocks_1_1.value;\n        total += ecBlock.getCount();\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (ecBlocks_1_1 && !ecBlocks_1_1.done && (_a = ecBlocks_1.return)) _a.call(ecBlocks_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return total;\n  };\n\n  ECBlocks.prototype.getTotalECCodewords = function () {\n    return this.ecCodewordsPerBlock * this.getNumBlocks();\n  };\n\n  ECBlocks.prototype.getECBlocks = function () {\n    return this.ecBlocks;\n  };\n\n  return ECBlocks;\n}();\n\nexports.default = ECBlocks;","map":{"version":3,"sources":["../../../../src/core/qrcode/decoder/ECBlocks.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAEA;;;;;AAKG;;AACH,IAAA,QAAA;AAAA;AAAA,YAAA;AAGI,WAAA,QAAA,CAA2B;AAA4B;AAAvD,IAA8D;AAAE,QAAA,QAAA,GAAA,EAAA;;SAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAAkB;AAAlB,MAAA,QAAA,CAAA,EAAA,GAAA,CAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AAArC,SAAA,mBAAA,GAAA,mBAAA;AACvB,SAAK,QAAL,GAAgB,QAAhB;AACH;;AAEM,EAAA,QAAA,CAAA,SAAA,CAAA,sBAAA,GAAP,YAAA;AACI,WAAO,KAAK,mBAAZ;AACH,GAFM;;AAIA,EAAA,QAAA,CAAA,SAAA,CAAA,YAAA,GAAP,YAAA;;;AACI,QAAI,KAAK,GAAG,CAAZ;AACA,QAAM,QAAQ,GAAG,KAAK,QAAtB;;;AACA,WAAsB,IAAA,UAAA,GAAA,QAAA,CAAA,QAAA,CAAA,EAAQ,YAAA,GAAA,UAAA,CAAA,IAAA,EAA9B,EAA8B,CAAA,YAAA,CAAA,IAA9B,EAA8B,YAAA,GAAA,UAAA,CAAA,IAAA,EAA9B,EAAgC;AAA3B,YAAM,OAAO,GAAA,YAAA,CAAA,KAAb;AACD,QAAA,KAAK,IAAI,OAAO,CAAC,QAAR,EAAT;AACH;;;;;;;;;;;;;AACD,WAAO,KAAP;AACH,GAPM;;AASA,EAAA,QAAA,CAAA,SAAA,CAAA,mBAAA,GAAP,YAAA;AACI,WAAO,KAAK,mBAAL,GAA2B,KAAK,YAAL,EAAlC;AACH,GAFM;;AAIA,EAAA,QAAA,CAAA,SAAA,CAAA,WAAA,GAAP,YAAA;AACI,WAAO,KAAK,QAAZ;AACH,GAFM;;AAGX,SAAA,QAAA;AAAC,CA3BD,EAAA","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __values = (this && this.__values) || function (o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * <p>Encapsulates a set of error-correction blocks in one symbol version. Most versions will\r\n * use blocks of differing sizes within one version, so, this encapsulates the parameters for\r\n * each set of blocks. It also holds the number of error-correction codewords per block since it\r\n * will be the same across all blocks within one version.</p>\r\n */\r\nvar ECBlocks = /** @class */ (function () {\r\n    function ECBlocks(ecCodewordsPerBlock /*int*/) {\r\n        var ecBlocks = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            ecBlocks[_i - 1] = arguments[_i];\r\n        }\r\n        this.ecCodewordsPerBlock = ecCodewordsPerBlock;\r\n        this.ecBlocks = ecBlocks;\r\n    }\r\n    ECBlocks.prototype.getECCodewordsPerBlock = function () {\r\n        return this.ecCodewordsPerBlock;\r\n    };\r\n    ECBlocks.prototype.getNumBlocks = function () {\r\n        var e_1, _a;\r\n        var total = 0;\r\n        var ecBlocks = this.ecBlocks;\r\n        try {\r\n            for (var ecBlocks_1 = __values(ecBlocks), ecBlocks_1_1 = ecBlocks_1.next(); !ecBlocks_1_1.done; ecBlocks_1_1 = ecBlocks_1.next()) {\r\n                var ecBlock = ecBlocks_1_1.value;\r\n                total += ecBlock.getCount();\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (ecBlocks_1_1 && !ecBlocks_1_1.done && (_a = ecBlocks_1.return)) _a.call(ecBlocks_1);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        return total;\r\n    };\r\n    ECBlocks.prototype.getTotalECCodewords = function () {\r\n        return this.ecCodewordsPerBlock * this.getNumBlocks();\r\n    };\r\n    ECBlocks.prototype.getECBlocks = function () {\r\n        return this.ecBlocks;\r\n    };\r\n    return ECBlocks;\r\n}());\r\nexports.default = ECBlocks;\r\n//# sourceMappingURL=ECBlocks.js.map"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar IllegalArgumentException_1 = require(\"../../IllegalArgumentException\");\n/*\r\n * Copyright 2008 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * <p>Encapsulates a block of data within a Data Matrix Code. Data Matrix Codes may split their data into\r\n * multiple blocks, each of which is a unit of data and error-correction codewords. Each\r\n * is represented by an instance of this class.</p>\r\n *\r\n * @author bbrown@google.com (Brian Brown)\r\n */\n\n\nvar DataBlock =\n/** @class */\nfunction () {\n  function DataBlock(numDataCodewords, codewords) {\n    this.numDataCodewords = numDataCodewords;\n    this.codewords = codewords;\n  }\n  /**\r\n   * <p>When Data Matrix Codes use multiple data blocks, they actually interleave the bytes of each of them.\r\n   * That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This\r\n   * method will separate the data into original blocks.</p>\r\n   *\r\n   * @param rawCodewords bytes as read directly from the Data Matrix Code\r\n   * @param version version of the Data Matrix Code\r\n   * @return DataBlocks containing original bytes, \"de-interleaved\" from representation in the\r\n   *         Data Matrix Code\r\n   */\n\n\n  DataBlock.getDataBlocks = function (rawCodewords, version) {\n    var e_1, _a, e_2, _b; // Figure out the number and size of data blocks used by this version\n\n\n    var ecBlocks = version.getECBlocks(); // First count the total number of data blocks\n\n    var totalBlocks = 0;\n    var ecBlockArray = ecBlocks.getECBlocks();\n\n    try {\n      for (var ecBlockArray_1 = __values(ecBlockArray), ecBlockArray_1_1 = ecBlockArray_1.next(); !ecBlockArray_1_1.done; ecBlockArray_1_1 = ecBlockArray_1.next()) {\n        var ecBlock = ecBlockArray_1_1.value;\n        totalBlocks += ecBlock.getCount();\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (ecBlockArray_1_1 && !ecBlockArray_1_1.done && (_a = ecBlockArray_1.return)) _a.call(ecBlockArray_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    } // Now establish DataBlocks of the appropriate size and number of data codewords\n\n\n    var result = new Array(totalBlocks);\n    var numResultBlocks = 0;\n\n    try {\n      for (var ecBlockArray_2 = __values(ecBlockArray), ecBlockArray_2_1 = ecBlockArray_2.next(); !ecBlockArray_2_1.done; ecBlockArray_2_1 = ecBlockArray_2.next()) {\n        var ecBlock = ecBlockArray_2_1.value;\n\n        for (var i = 0; i < ecBlock.getCount(); i++) {\n          var numDataCodewords = ecBlock.getDataCodewords();\n          var numBlockCodewords = ecBlocks.getECCodewords() + numDataCodewords;\n          result[numResultBlocks++] = new DataBlock(numDataCodewords, new Uint8Array(numBlockCodewords));\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (ecBlockArray_2_1 && !ecBlockArray_2_1.done && (_b = ecBlockArray_2.return)) _b.call(ecBlockArray_2);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    } // All blocks have the same amount of data, except that the last n\n    // (where n may be 0) have 1 less byte. Figure out where these start.\n    // TODO(bbrown): There is only one case where there is a difference for Data Matrix for size 144\n\n\n    var longerBlocksTotalCodewords = result[0].codewords.length; // int shorterBlocksTotalCodewords = longerBlocksTotalCodewords - 1;\n\n    var longerBlocksNumDataCodewords = longerBlocksTotalCodewords - ecBlocks.getECCodewords();\n    var shorterBlocksNumDataCodewords = longerBlocksNumDataCodewords - 1; // The last elements of result may be 1 element shorter for 144 matrix\n    // first fill out as many elements as all of them have minus 1\n\n    var rawCodewordsOffset = 0;\n\n    for (var i = 0; i < shorterBlocksNumDataCodewords; i++) {\n      for (var j = 0; j < numResultBlocks; j++) {\n        result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];\n      }\n    } // Fill out the last data block in the longer ones\n\n\n    var specialVersion = version.getVersionNumber() === 24;\n    var numLongerBlocks = specialVersion ? 8 : numResultBlocks;\n\n    for (var j = 0; j < numLongerBlocks; j++) {\n      result[j].codewords[longerBlocksNumDataCodewords - 1] = rawCodewords[rawCodewordsOffset++];\n    } // Now add in error correction blocks\n\n\n    var max = result[0].codewords.length;\n\n    for (var i = longerBlocksNumDataCodewords; i < max; i++) {\n      for (var j = 0; j < numResultBlocks; j++) {\n        var jOffset = specialVersion ? (j + 8) % numResultBlocks : j;\n        var iOffset = specialVersion && jOffset > 7 ? i - 1 : i;\n        result[jOffset].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];\n      }\n    }\n\n    if (rawCodewordsOffset !== rawCodewords.length) {\n      throw new IllegalArgumentException_1.default();\n    }\n\n    return result;\n  };\n\n  DataBlock.prototype.getNumDataCodewords = function () {\n    return this.numDataCodewords;\n  };\n\n  DataBlock.prototype.getCodewords = function () {\n    return this.codewords;\n  };\n\n  return DataBlock;\n}();\n\nexports.default = DataBlock;","map":{"version":3,"sources":["../../../../src/core/datamatrix/decoder/DataBlock.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __values = (this && this.__values) || function (o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar IllegalArgumentException_1 = require(\"../../IllegalArgumentException\");\r\n/*\r\n * Copyright 2008 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * <p>Encapsulates a block of data within a Data Matrix Code. Data Matrix Codes may split their data into\r\n * multiple blocks, each of which is a unit of data and error-correction codewords. Each\r\n * is represented by an instance of this class.</p>\r\n *\r\n * @author bbrown@google.com (Brian Brown)\r\n */\r\nvar DataBlock = /** @class */ (function () {\r\n    function DataBlock(numDataCodewords, codewords) {\r\n        this.numDataCodewords = numDataCodewords;\r\n        this.codewords = codewords;\r\n    }\r\n    /**\r\n     * <p>When Data Matrix Codes use multiple data blocks, they actually interleave the bytes of each of them.\r\n     * That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This\r\n     * method will separate the data into original blocks.</p>\r\n     *\r\n     * @param rawCodewords bytes as read directly from the Data Matrix Code\r\n     * @param version version of the Data Matrix Code\r\n     * @return DataBlocks containing original bytes, \"de-interleaved\" from representation in the\r\n     *         Data Matrix Code\r\n     */\r\n    DataBlock.getDataBlocks = function (rawCodewords, version) {\r\n        var e_1, _a, e_2, _b;\r\n        // Figure out the number and size of data blocks used by this version\r\n        var ecBlocks = version.getECBlocks();\r\n        // First count the total number of data blocks\r\n        var totalBlocks = 0;\r\n        var ecBlockArray = ecBlocks.getECBlocks();\r\n        try {\r\n            for (var ecBlockArray_1 = __values(ecBlockArray), ecBlockArray_1_1 = ecBlockArray_1.next(); !ecBlockArray_1_1.done; ecBlockArray_1_1 = ecBlockArray_1.next()) {\r\n                var ecBlock = ecBlockArray_1_1.value;\r\n                totalBlocks += ecBlock.getCount();\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (ecBlockArray_1_1 && !ecBlockArray_1_1.done && (_a = ecBlockArray_1.return)) _a.call(ecBlockArray_1);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        // Now establish DataBlocks of the appropriate size and number of data codewords\r\n        var result = new Array(totalBlocks);\r\n        var numResultBlocks = 0;\r\n        try {\r\n            for (var ecBlockArray_2 = __values(ecBlockArray), ecBlockArray_2_1 = ecBlockArray_2.next(); !ecBlockArray_2_1.done; ecBlockArray_2_1 = ecBlockArray_2.next()) {\r\n                var ecBlock = ecBlockArray_2_1.value;\r\n                for (var i = 0; i < ecBlock.getCount(); i++) {\r\n                    var numDataCodewords = ecBlock.getDataCodewords();\r\n                    var numBlockCodewords = ecBlocks.getECCodewords() + numDataCodewords;\r\n                    result[numResultBlocks++] = new DataBlock(numDataCodewords, new Uint8Array(numBlockCodewords));\r\n                }\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (ecBlockArray_2_1 && !ecBlockArray_2_1.done && (_b = ecBlockArray_2.return)) _b.call(ecBlockArray_2);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n        // All blocks have the same amount of data, except that the last n\r\n        // (where n may be 0) have 1 less byte. Figure out where these start.\r\n        // TODO(bbrown): There is only one case where there is a difference for Data Matrix for size 144\r\n        var longerBlocksTotalCodewords = result[0].codewords.length;\r\n        // int shorterBlocksTotalCodewords = longerBlocksTotalCodewords - 1;\r\n        var longerBlocksNumDataCodewords = longerBlocksTotalCodewords - ecBlocks.getECCodewords();\r\n        var shorterBlocksNumDataCodewords = longerBlocksNumDataCodewords - 1;\r\n        // The last elements of result may be 1 element shorter for 144 matrix\r\n        // first fill out as many elements as all of them have minus 1\r\n        var rawCodewordsOffset = 0;\r\n        for (var i = 0; i < shorterBlocksNumDataCodewords; i++) {\r\n            for (var j = 0; j < numResultBlocks; j++) {\r\n                result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];\r\n            }\r\n        }\r\n        // Fill out the last data block in the longer ones\r\n        var specialVersion = version.getVersionNumber() === 24;\r\n        var numLongerBlocks = specialVersion ? 8 : numResultBlocks;\r\n        for (var j = 0; j < numLongerBlocks; j++) {\r\n            result[j].codewords[longerBlocksNumDataCodewords - 1] = rawCodewords[rawCodewordsOffset++];\r\n        }\r\n        // Now add in error correction blocks\r\n        var max = result[0].codewords.length;\r\n        for (var i = longerBlocksNumDataCodewords; i < max; i++) {\r\n            for (var j = 0; j < numResultBlocks; j++) {\r\n                var jOffset = specialVersion ? (j + 8) % numResultBlocks : j;\r\n                var iOffset = specialVersion && jOffset > 7 ? i - 1 : i;\r\n                result[jOffset].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];\r\n            }\r\n        }\r\n        if (rawCodewordsOffset !== rawCodewords.length) {\r\n            throw new IllegalArgumentException_1.default();\r\n        }\r\n        return result;\r\n    };\r\n    DataBlock.prototype.getNumDataCodewords = function () {\r\n        return this.numDataCodewords;\r\n    };\r\n    DataBlock.prototype.getCodewords = function () {\r\n        return this.codewords;\r\n    };\r\n    return DataBlock;\r\n}());\r\nexports.default = DataBlock;\r\n//# sourceMappingURL=DataBlock.js.map"]},"metadata":{},"sourceType":"script"}
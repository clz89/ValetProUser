{"ast":null,"code":"\"use strict\";\n/*\r\n* Copyright 2009 ZXing authors\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*      http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n*/\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // import com.google.zxing.NotFoundException;\n// import com.google.zxing.ResultPoint;\n\nvar ResultPoint_1 = require(\"../../ResultPoint\");\n\nvar System_1 = require(\"../../util/System\");\n\nvar Arrays_1 = require(\"../../util/Arrays\");\n\nvar PDF417DetectorResult_1 = require(\"./PDF417DetectorResult\"); // import java.util.ArrayList;\n// import java.util.Arrays;\n// import java.util.List;\n// import java.util.Map;\n\n/**\r\n * <p>Encapsulates logic that can detect a PDF417 Code in an image, even if the\r\n * PDF417 Code is rotated or skewed, or partially obscured.</p>\r\n *\r\n * @author SITA Lab (kevin.osullivan@sita.aero)\r\n * @author dswitkin@google.com (Daniel Switkin)\r\n * @author Guenther Grau\r\n */\n\n\nvar Detector =\n/** @class */\nfunction () {\n  function Detector() {}\n  /**\r\n   * <p>Detects a PDF417 Code in an image. Only checks 0 and 180 degree rotations.</p>\r\n   *\r\n   * @param image barcode image to decode\r\n   * @param hints optional hints to detector\r\n   * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will\r\n   * be found and returned\r\n   * @return {@link PDF417DetectorResult} encapsulating results of detecting a PDF417 code\r\n   * @throws NotFoundException if no PDF417 Code can be found\r\n   */\n\n\n  Detector.detectMultiple = function (image, hints, multiple) {\n    // TODO detection improvement, tryHarder could try several different luminance thresholds/blackpoints or even\n    // different binarizers\n    // boolean tryHarder = hints != null && hints.containsKey(DecodeHintType.TRY_HARDER);\n    var bitMatrix = image.getBlackMatrix();\n    var barcodeCoordinates = Detector.detect(multiple, bitMatrix);\n\n    if (!barcodeCoordinates.length) {\n      bitMatrix = bitMatrix.clone();\n      bitMatrix.rotate180();\n      barcodeCoordinates = Detector.detect(multiple, bitMatrix);\n    }\n\n    return new PDF417DetectorResult_1.default(bitMatrix, barcodeCoordinates);\n  };\n  /**\r\n   * Detects PDF417 codes in an image. Only checks 0 degree rotation\r\n   * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will\r\n   * be found and returned\r\n   * @param bitMatrix bit matrix to detect barcodes in\r\n   * @return List of ResultPoint arrays containing the coordinates of found barcodes\r\n   */\n\n\n  Detector.detect = function (multiple, bitMatrix) {\n    var e_1, _a;\n\n    var barcodeCoordinates = new Array();\n    var row = 0;\n    var column = 0;\n    var foundBarcodeInRow = false;\n\n    while (row < bitMatrix.getHeight()) {\n      var vertices = Detector.findVertices(bitMatrix, row, column);\n\n      if (vertices[0] == null && vertices[3] == null) {\n        if (!foundBarcodeInRow) {\n          // we didn't find any barcode so that's the end of searching\n          break;\n        } // we didn't find a barcode starting at the given column and row. Try again from the first column and slightly\n        // below the lowest barcode we found so far.\n\n\n        foundBarcodeInRow = false;\n        column = 0;\n\n        try {\n          for (var barcodeCoordinates_1 = __values(barcodeCoordinates), barcodeCoordinates_1_1 = barcodeCoordinates_1.next(); !barcodeCoordinates_1_1.done; barcodeCoordinates_1_1 = barcodeCoordinates_1.next()) {\n            var barcodeCoordinate = barcodeCoordinates_1_1.value;\n\n            if (barcodeCoordinate[1] != null) {\n              row = Math.trunc(Math.max(row, barcodeCoordinate[1].getY()));\n            }\n\n            if (barcodeCoordinate[3] != null) {\n              row = Math.max(row, Math.trunc(barcodeCoordinate[3].getY()));\n            }\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (barcodeCoordinates_1_1 && !barcodeCoordinates_1_1.done && (_a = barcodeCoordinates_1.return)) _a.call(barcodeCoordinates_1);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n\n        row += Detector.ROW_STEP;\n        continue;\n      }\n\n      foundBarcodeInRow = true;\n      barcodeCoordinates.push(vertices);\n\n      if (!multiple) {\n        break;\n      } // if we didn't find a right row indicator column, then continue the search for the next barcode after the\n      // start pattern of the barcode just found.\n\n\n      if (vertices[2] != null) {\n        column = Math.trunc(vertices[2].getX());\n        row = Math.trunc(vertices[2].getY());\n      } else {\n        column = Math.trunc(vertices[4].getX());\n        row = Math.trunc(vertices[4].getY());\n      }\n    }\n\n    return barcodeCoordinates;\n  };\n  /**\r\n   * Locate the vertices and the codewords area of a black blob using the Start\r\n   * and Stop patterns as locators.\r\n   *\r\n   * @param matrix the scanned barcode image.\r\n   * @return an array containing the vertices:\r\n   *           vertices[0] x, y top left barcode\r\n   *           vertices[1] x, y bottom left barcode\r\n   *           vertices[2] x, y top right barcode\r\n   *           vertices[3] x, y bottom right barcode\r\n   *           vertices[4] x, y top left codeword area\r\n   *           vertices[5] x, y bottom left codeword area\r\n   *           vertices[6] x, y top right codeword area\r\n   *           vertices[7] x, y bottom right codeword area\r\n   */\n\n\n  Detector.findVertices = function (matrix, startRow, startColumn) {\n    var height = matrix.getHeight();\n    var width = matrix.getWidth(); // const result = new ResultPoint[8];\n\n    var result = new Array(8);\n    Detector.copyToResult(result, Detector.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector.START_PATTERN), Detector.INDEXES_START_PATTERN);\n\n    if (result[4] != null) {\n      startColumn = Math.trunc(result[4].getX());\n      startRow = Math.trunc(result[4].getY());\n    }\n\n    Detector.copyToResult(result, Detector.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector.STOP_PATTERN), Detector.INDEXES_STOP_PATTERN);\n    return result;\n  };\n\n  Detector.copyToResult = function (result, tmpResult, destinationIndexes) {\n    for (var i = 0; i < destinationIndexes.length; i++) {\n      result[destinationIndexes[i]] = tmpResult[i];\n    }\n  };\n\n  Detector.findRowsWithPattern = function (matrix, height, width, startRow, startColumn, pattern) {\n    // const result = new ResultPoint[4];\n    var result = new Array(4);\n    var found = false;\n    var counters = new Int32Array(pattern.length);\n\n    for (; startRow < height; startRow += Detector.ROW_STEP) {\n      var loc = Detector.findGuardPattern(matrix, startColumn, startRow, width, false, pattern, counters);\n\n      if (loc != null) {\n        while (startRow > 0) {\n          var previousRowLoc = Detector.findGuardPattern(matrix, startColumn, --startRow, width, false, pattern, counters);\n\n          if (previousRowLoc != null) {\n            loc = previousRowLoc;\n          } else {\n            startRow++;\n            break;\n          }\n        }\n\n        result[0] = new ResultPoint_1.default(loc[0], startRow);\n        result[1] = new ResultPoint_1.default(loc[1], startRow);\n        found = true;\n        break;\n      }\n    }\n\n    var stopRow = startRow + 1; // Last row of the current symbol that contains pattern\n\n    if (found) {\n      var skippedRowCount = 0;\n      var previousRowLoc = Int32Array.from([Math.trunc(result[0].getX()), Math.trunc(result[1].getX())]);\n\n      for (; stopRow < height; stopRow++) {\n        var loc = Detector.findGuardPattern(matrix, previousRowLoc[0], stopRow, width, false, pattern, counters); // a found pattern is only considered to belong to the same barcode if the start and end positions\n        // don't differ too much. Pattern drift should be not bigger than two for consecutive rows. With\n        // a higher number of skipped rows drift could be larger. To keep it simple for now, we allow a slightly\n        // larger drift and don't check for skipped rows.\n\n        if (loc != null && Math.abs(previousRowLoc[0] - loc[0]) < Detector.MAX_PATTERN_DRIFT && Math.abs(previousRowLoc[1] - loc[1]) < Detector.MAX_PATTERN_DRIFT) {\n          previousRowLoc = loc;\n          skippedRowCount = 0;\n        } else {\n          if (skippedRowCount > Detector.SKIPPED_ROW_COUNT_MAX) {\n            break;\n          } else {\n            skippedRowCount++;\n          }\n        }\n      }\n\n      stopRow -= skippedRowCount + 1;\n      result[2] = new ResultPoint_1.default(previousRowLoc[0], stopRow);\n      result[3] = new ResultPoint_1.default(previousRowLoc[1], stopRow);\n    }\n\n    if (stopRow - startRow < Detector.BARCODE_MIN_HEIGHT) {\n      Arrays_1.default.fill(result, null);\n    }\n\n    return result;\n  };\n  /**\r\n   * @param matrix row of black/white values to search\r\n   * @param column x position to start search\r\n   * @param row y position to start search\r\n   * @param width the number of pixels to search on this row\r\n   * @param pattern pattern of counts of number of black and white pixels that are\r\n   *                 being searched for as a pattern\r\n   * @param counters array of counters, as long as pattern, to re-use\r\n   * @return start/end horizontal offset of guard pattern, as an array of two ints.\r\n   */\n\n\n  Detector.findGuardPattern = function (matrix, column, row, width, whiteFirst, pattern, counters) {\n    Arrays_1.default.fillWithin(counters, 0, counters.length, 0);\n    var patternStart = column;\n    var pixelDrift = 0; // if there are black pixels left of the current pixel shift to the left, but only for MAX_PIXEL_DRIFT pixels\n\n    while (matrix.get(patternStart, row) && patternStart > 0 && pixelDrift++ < Detector.MAX_PIXEL_DRIFT) {\n      patternStart--;\n    }\n\n    var x = patternStart;\n    var counterPosition = 0;\n    var patternLength = pattern.length;\n\n    for (var isWhite = whiteFirst; x < width; x++) {\n      var pixel = matrix.get(x, row);\n\n      if (pixel !== isWhite) {\n        counters[counterPosition]++;\n      } else {\n        if (counterPosition === patternLength - 1) {\n          if (Detector.patternMatchVariance(counters, pattern, Detector.MAX_INDIVIDUAL_VARIANCE) < Detector.MAX_AVG_VARIANCE) {\n            return new Int32Array([patternStart, x]);\n          }\n\n          patternStart += counters[0] + counters[1];\n          System_1.default.arraycopy(counters, 2, counters, 0, counterPosition - 1);\n          counters[counterPosition - 1] = 0;\n          counters[counterPosition] = 0;\n          counterPosition--;\n        } else {\n          counterPosition++;\n        }\n\n        counters[counterPosition] = 1;\n        isWhite = !isWhite;\n      }\n    }\n\n    if (counterPosition === patternLength - 1 && Detector.patternMatchVariance(counters, pattern, Detector.MAX_INDIVIDUAL_VARIANCE) < Detector.MAX_AVG_VARIANCE) {\n      return new Int32Array([patternStart, x - 1]);\n    }\n\n    return null;\n  };\n  /**\r\n   * Determines how closely a set of observed counts of runs of black/white\r\n   * values matches a given target pattern. This is reported as the ratio of\r\n   * the total variance from the expected pattern proportions across all\r\n   * pattern elements, to the length of the pattern.\r\n   *\r\n   * @param counters observed counters\r\n   * @param pattern expected pattern\r\n   * @param maxIndividualVariance The most any counter can differ before we give up\r\n   * @return ratio of total variance between counters and pattern compared to total pattern size\r\n   */\n\n\n  Detector.patternMatchVariance = function (counters, pattern, maxIndividualVariance) {\n    var numCounters = counters.length;\n    var total = 0;\n    var patternLength = 0;\n\n    for (var i = 0; i < numCounters; i++) {\n      total += counters[i];\n      patternLength += pattern[i];\n    }\n\n    if (total < patternLength) {\n      // If we don't even have one pixel per unit of bar width, assume this\n      // is too small to reliably match, so fail:\n      return (\n        /*Float.POSITIVE_INFINITY*/\n        Infinity\n      );\n    } // We're going to fake floating-point math in integers. We just need to use more bits.\n    // Scale up patternLength so that intermediate values below like scaledCounter will have\n    // more \"significant digits\".\n\n\n    var unitBarWidth = total / patternLength;\n    maxIndividualVariance *= unitBarWidth;\n    var totalVariance = 0.0;\n\n    for (var x = 0; x < numCounters; x++) {\n      var counter = counters[x];\n      var scaledPattern = pattern[x] * unitBarWidth;\n      var variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;\n\n      if (variance > maxIndividualVariance) {\n        return (\n          /*Float.POSITIVE_INFINITY*/\n          Infinity\n        );\n      }\n\n      totalVariance += variance;\n    }\n\n    return totalVariance / total;\n  };\n\n  Detector.INDEXES_START_PATTERN = Int32Array.from([0, 4, 1, 5]);\n  Detector.INDEXES_STOP_PATTERN = Int32Array.from([6, 2, 7, 3]);\n  Detector.MAX_AVG_VARIANCE = 0.42;\n  Detector.MAX_INDIVIDUAL_VARIANCE = 0.8; // B S B S B S B S Bar/Space pattern\n  // 11111111 0 1 0 1 0 1 000\n\n  Detector.START_PATTERN = Int32Array.from([8, 1, 1, 1, 1, 1, 1, 3]); // 1111111 0 1 000 1 0 1 00 1\n\n  Detector.STOP_PATTERN = Int32Array.from([7, 1, 1, 3, 1, 1, 1, 2, 1]);\n  Detector.MAX_PIXEL_DRIFT = 3;\n  Detector.MAX_PATTERN_DRIFT = 5; // if we set the value too low, then we don't detect the correct height of the bar if the start patterns are damaged.\n  // if we set the value too high, then we might detect the start pattern from a neighbor barcode.\n\n  Detector.SKIPPED_ROW_COUNT_MAX = 25; // A PDF471 barcode should have at least 3 rows, with each row being >= 3 times the module width. Therefore it should be at least\n  // 9 pixels tall. To be conservative, we use about half the size to ensure we don't miss it.\n\n  Detector.ROW_STEP = 5;\n  Detector.BARCODE_MIN_HEIGHT = 10;\n  return Detector;\n}();\n\nexports.default = Detector;","map":{"version":3,"sources":["../../../../src/core/pdf417/detector/Detector.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/*\r\n* Copyright 2009 ZXing authors\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*      http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n*/\r\nvar __values = (this && this.__values) || function (o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// import com.google.zxing.NotFoundException;\r\n// import com.google.zxing.ResultPoint;\r\nvar ResultPoint_1 = require(\"../../ResultPoint\");\r\nvar System_1 = require(\"../../util/System\");\r\nvar Arrays_1 = require(\"../../util/Arrays\");\r\nvar PDF417DetectorResult_1 = require(\"./PDF417DetectorResult\");\r\n// import java.util.ArrayList;\r\n// import java.util.Arrays;\r\n// import java.util.List;\r\n// import java.util.Map;\r\n/**\r\n * <p>Encapsulates logic that can detect a PDF417 Code in an image, even if the\r\n * PDF417 Code is rotated or skewed, or partially obscured.</p>\r\n *\r\n * @author SITA Lab (kevin.osullivan@sita.aero)\r\n * @author dswitkin@google.com (Daniel Switkin)\r\n * @author Guenther Grau\r\n */\r\nvar Detector = /** @class */ (function () {\r\n    function Detector() {\r\n    }\r\n    /**\r\n     * <p>Detects a PDF417 Code in an image. Only checks 0 and 180 degree rotations.</p>\r\n     *\r\n     * @param image barcode image to decode\r\n     * @param hints optional hints to detector\r\n     * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will\r\n     * be found and returned\r\n     * @return {@link PDF417DetectorResult} encapsulating results of detecting a PDF417 code\r\n     * @throws NotFoundException if no PDF417 Code can be found\r\n     */\r\n    Detector.detectMultiple = function (image, hints, multiple) {\r\n        // TODO detection improvement, tryHarder could try several different luminance thresholds/blackpoints or even\r\n        // different binarizers\r\n        // boolean tryHarder = hints != null && hints.containsKey(DecodeHintType.TRY_HARDER);\r\n        var bitMatrix = image.getBlackMatrix();\r\n        var barcodeCoordinates = Detector.detect(multiple, bitMatrix);\r\n        if (!barcodeCoordinates.length) {\r\n            bitMatrix = bitMatrix.clone();\r\n            bitMatrix.rotate180();\r\n            barcodeCoordinates = Detector.detect(multiple, bitMatrix);\r\n        }\r\n        return new PDF417DetectorResult_1.default(bitMatrix, barcodeCoordinates);\r\n    };\r\n    /**\r\n     * Detects PDF417 codes in an image. Only checks 0 degree rotation\r\n     * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will\r\n     * be found and returned\r\n     * @param bitMatrix bit matrix to detect barcodes in\r\n     * @return List of ResultPoint arrays containing the coordinates of found barcodes\r\n     */\r\n    Detector.detect = function (multiple, bitMatrix) {\r\n        var e_1, _a;\r\n        var barcodeCoordinates = new Array();\r\n        var row = 0;\r\n        var column = 0;\r\n        var foundBarcodeInRow = false;\r\n        while (row < bitMatrix.getHeight()) {\r\n            var vertices = Detector.findVertices(bitMatrix, row, column);\r\n            if (vertices[0] == null && vertices[3] == null) {\r\n                if (!foundBarcodeInRow) {\r\n                    // we didn't find any barcode so that's the end of searching\r\n                    break;\r\n                }\r\n                // we didn't find a barcode starting at the given column and row. Try again from the first column and slightly\r\n                // below the lowest barcode we found so far.\r\n                foundBarcodeInRow = false;\r\n                column = 0;\r\n                try {\r\n                    for (var barcodeCoordinates_1 = __values(barcodeCoordinates), barcodeCoordinates_1_1 = barcodeCoordinates_1.next(); !barcodeCoordinates_1_1.done; barcodeCoordinates_1_1 = barcodeCoordinates_1.next()) {\r\n                        var barcodeCoordinate = barcodeCoordinates_1_1.value;\r\n                        if (barcodeCoordinate[1] != null) {\r\n                            row = Math.trunc(Math.max(row, barcodeCoordinate[1].getY()));\r\n                        }\r\n                        if (barcodeCoordinate[3] != null) {\r\n                            row = Math.max(row, Math.trunc(barcodeCoordinate[3].getY()));\r\n                        }\r\n                    }\r\n                }\r\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n                finally {\r\n                    try {\r\n                        if (barcodeCoordinates_1_1 && !barcodeCoordinates_1_1.done && (_a = barcodeCoordinates_1.return)) _a.call(barcodeCoordinates_1);\r\n                    }\r\n                    finally { if (e_1) throw e_1.error; }\r\n                }\r\n                row += Detector.ROW_STEP;\r\n                continue;\r\n            }\r\n            foundBarcodeInRow = true;\r\n            barcodeCoordinates.push(vertices);\r\n            if (!multiple) {\r\n                break;\r\n            }\r\n            // if we didn't find a right row indicator column, then continue the search for the next barcode after the\r\n            // start pattern of the barcode just found.\r\n            if (vertices[2] != null) {\r\n                column = Math.trunc(vertices[2].getX());\r\n                row = Math.trunc(vertices[2].getY());\r\n            }\r\n            else {\r\n                column = Math.trunc(vertices[4].getX());\r\n                row = Math.trunc(vertices[4].getY());\r\n            }\r\n        }\r\n        return barcodeCoordinates;\r\n    };\r\n    /**\r\n     * Locate the vertices and the codewords area of a black blob using the Start\r\n     * and Stop patterns as locators.\r\n     *\r\n     * @param matrix the scanned barcode image.\r\n     * @return an array containing the vertices:\r\n     *           vertices[0] x, y top left barcode\r\n     *           vertices[1] x, y bottom left barcode\r\n     *           vertices[2] x, y top right barcode\r\n     *           vertices[3] x, y bottom right barcode\r\n     *           vertices[4] x, y top left codeword area\r\n     *           vertices[5] x, y bottom left codeword area\r\n     *           vertices[6] x, y top right codeword area\r\n     *           vertices[7] x, y bottom right codeword area\r\n     */\r\n    Detector.findVertices = function (matrix, startRow, startColumn) {\r\n        var height = matrix.getHeight();\r\n        var width = matrix.getWidth();\r\n        // const result = new ResultPoint[8];\r\n        var result = new Array(8);\r\n        Detector.copyToResult(result, Detector.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector.START_PATTERN), Detector.INDEXES_START_PATTERN);\r\n        if (result[4] != null) {\r\n            startColumn = Math.trunc(result[4].getX());\r\n            startRow = Math.trunc(result[4].getY());\r\n        }\r\n        Detector.copyToResult(result, Detector.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector.STOP_PATTERN), Detector.INDEXES_STOP_PATTERN);\r\n        return result;\r\n    };\r\n    Detector.copyToResult = function (result, tmpResult, destinationIndexes) {\r\n        for (var i = 0; i < destinationIndexes.length; i++) {\r\n            result[destinationIndexes[i]] = tmpResult[i];\r\n        }\r\n    };\r\n    Detector.findRowsWithPattern = function (matrix, height, width, startRow, startColumn, pattern) {\r\n        // const result = new ResultPoint[4];\r\n        var result = new Array(4);\r\n        var found = false;\r\n        var counters = new Int32Array(pattern.length);\r\n        for (; startRow < height; startRow += Detector.ROW_STEP) {\r\n            var loc = Detector.findGuardPattern(matrix, startColumn, startRow, width, false, pattern, counters);\r\n            if (loc != null) {\r\n                while (startRow > 0) {\r\n                    var previousRowLoc = Detector.findGuardPattern(matrix, startColumn, --startRow, width, false, pattern, counters);\r\n                    if (previousRowLoc != null) {\r\n                        loc = previousRowLoc;\r\n                    }\r\n                    else {\r\n                        startRow++;\r\n                        break;\r\n                    }\r\n                }\r\n                result[0] = new ResultPoint_1.default(loc[0], startRow);\r\n                result[1] = new ResultPoint_1.default(loc[1], startRow);\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        var stopRow = startRow + 1;\r\n        // Last row of the current symbol that contains pattern\r\n        if (found) {\r\n            var skippedRowCount = 0;\r\n            var previousRowLoc = Int32Array.from([Math.trunc(result[0].getX()), Math.trunc(result[1].getX())]);\r\n            for (; stopRow < height; stopRow++) {\r\n                var loc = Detector.findGuardPattern(matrix, previousRowLoc[0], stopRow, width, false, pattern, counters);\r\n                // a found pattern is only considered to belong to the same barcode if the start and end positions\r\n                // don't differ too much. Pattern drift should be not bigger than two for consecutive rows. With\r\n                // a higher number of skipped rows drift could be larger. To keep it simple for now, we allow a slightly\r\n                // larger drift and don't check for skipped rows.\r\n                if (loc != null &&\r\n                    Math.abs(previousRowLoc[0] - loc[0]) < Detector.MAX_PATTERN_DRIFT &&\r\n                    Math.abs(previousRowLoc[1] - loc[1]) < Detector.MAX_PATTERN_DRIFT) {\r\n                    previousRowLoc = loc;\r\n                    skippedRowCount = 0;\r\n                }\r\n                else {\r\n                    if (skippedRowCount > Detector.SKIPPED_ROW_COUNT_MAX) {\r\n                        break;\r\n                    }\r\n                    else {\r\n                        skippedRowCount++;\r\n                    }\r\n                }\r\n            }\r\n            stopRow -= skippedRowCount + 1;\r\n            result[2] = new ResultPoint_1.default(previousRowLoc[0], stopRow);\r\n            result[3] = new ResultPoint_1.default(previousRowLoc[1], stopRow);\r\n        }\r\n        if (stopRow - startRow < Detector.BARCODE_MIN_HEIGHT) {\r\n            Arrays_1.default.fill(result, null);\r\n        }\r\n        return result;\r\n    };\r\n    /**\r\n     * @param matrix row of black/white values to search\r\n     * @param column x position to start search\r\n     * @param row y position to start search\r\n     * @param width the number of pixels to search on this row\r\n     * @param pattern pattern of counts of number of black and white pixels that are\r\n     *                 being searched for as a pattern\r\n     * @param counters array of counters, as long as pattern, to re-use\r\n     * @return start/end horizontal offset of guard pattern, as an array of two ints.\r\n     */\r\n    Detector.findGuardPattern = function (matrix, column, row, width, whiteFirst, pattern, counters) {\r\n        Arrays_1.default.fillWithin(counters, 0, counters.length, 0);\r\n        var patternStart = column;\r\n        var pixelDrift = 0;\r\n        // if there are black pixels left of the current pixel shift to the left, but only for MAX_PIXEL_DRIFT pixels\r\n        while (matrix.get(patternStart, row) && patternStart > 0 && pixelDrift++ < Detector.MAX_PIXEL_DRIFT) {\r\n            patternStart--;\r\n        }\r\n        var x = patternStart;\r\n        var counterPosition = 0;\r\n        var patternLength = pattern.length;\r\n        for (var isWhite = whiteFirst; x < width; x++) {\r\n            var pixel = matrix.get(x, row);\r\n            if (pixel !== isWhite) {\r\n                counters[counterPosition]++;\r\n            }\r\n            else {\r\n                if (counterPosition === patternLength - 1) {\r\n                    if (Detector.patternMatchVariance(counters, pattern, Detector.MAX_INDIVIDUAL_VARIANCE) < Detector.MAX_AVG_VARIANCE) {\r\n                        return new Int32Array([patternStart, x]);\r\n                    }\r\n                    patternStart += counters[0] + counters[1];\r\n                    System_1.default.arraycopy(counters, 2, counters, 0, counterPosition - 1);\r\n                    counters[counterPosition - 1] = 0;\r\n                    counters[counterPosition] = 0;\r\n                    counterPosition--;\r\n                }\r\n                else {\r\n                    counterPosition++;\r\n                }\r\n                counters[counterPosition] = 1;\r\n                isWhite = !isWhite;\r\n            }\r\n        }\r\n        if (counterPosition === patternLength - 1 &&\r\n            Detector.patternMatchVariance(counters, pattern, Detector.MAX_INDIVIDUAL_VARIANCE) < Detector.MAX_AVG_VARIANCE) {\r\n            return new Int32Array([patternStart, x - 1]);\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Determines how closely a set of observed counts of runs of black/white\r\n     * values matches a given target pattern. This is reported as the ratio of\r\n     * the total variance from the expected pattern proportions across all\r\n     * pattern elements, to the length of the pattern.\r\n     *\r\n     * @param counters observed counters\r\n     * @param pattern expected pattern\r\n     * @param maxIndividualVariance The most any counter can differ before we give up\r\n     * @return ratio of total variance between counters and pattern compared to total pattern size\r\n     */\r\n    Detector.patternMatchVariance = function (counters, pattern, maxIndividualVariance) {\r\n        var numCounters = counters.length;\r\n        var total = 0;\r\n        var patternLength = 0;\r\n        for (var i = 0; i < numCounters; i++) {\r\n            total += counters[i];\r\n            patternLength += pattern[i];\r\n        }\r\n        if (total < patternLength) {\r\n            // If we don't even have one pixel per unit of bar width, assume this\r\n            // is too small to reliably match, so fail:\r\n            return /*Float.POSITIVE_INFINITY*/ Infinity;\r\n        }\r\n        // We're going to fake floating-point math in integers. We just need to use more bits.\r\n        // Scale up patternLength so that intermediate values below like scaledCounter will have\r\n        // more \"significant digits\".\r\n        var unitBarWidth = total / patternLength;\r\n        maxIndividualVariance *= unitBarWidth;\r\n        var totalVariance = 0.0;\r\n        for (var x = 0; x < numCounters; x++) {\r\n            var counter = counters[x];\r\n            var scaledPattern = pattern[x] * unitBarWidth;\r\n            var variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;\r\n            if (variance > maxIndividualVariance) {\r\n                return /*Float.POSITIVE_INFINITY*/ Infinity;\r\n            }\r\n            totalVariance += variance;\r\n        }\r\n        return totalVariance / total;\r\n    };\r\n    Detector.INDEXES_START_PATTERN = Int32Array.from([0, 4, 1, 5]);\r\n    Detector.INDEXES_STOP_PATTERN = Int32Array.from([6, 2, 7, 3]);\r\n    Detector.MAX_AVG_VARIANCE = 0.42;\r\n    Detector.MAX_INDIVIDUAL_VARIANCE = 0.8;\r\n    // B S B S B S B S Bar/Space pattern\r\n    // 11111111 0 1 0 1 0 1 000\r\n    Detector.START_PATTERN = Int32Array.from([8, 1, 1, 1, 1, 1, 1, 3]);\r\n    // 1111111 0 1 000 1 0 1 00 1\r\n    Detector.STOP_PATTERN = Int32Array.from([7, 1, 1, 3, 1, 1, 1, 2, 1]);\r\n    Detector.MAX_PIXEL_DRIFT = 3;\r\n    Detector.MAX_PATTERN_DRIFT = 5;\r\n    // if we set the value too low, then we don't detect the correct height of the bar if the start patterns are damaged.\r\n    // if we set the value too high, then we might detect the start pattern from a neighbor barcode.\r\n    Detector.SKIPPED_ROW_COUNT_MAX = 25;\r\n    // A PDF471 barcode should have at least 3 rows, with each row being >= 3 times the module width. Therefore it should be at least\r\n    // 9 pixels tall. To be conservative, we use about half the size to ensure we don't miss it.\r\n    Detector.ROW_STEP = 5;\r\n    Detector.BARCODE_MIN_HEIGHT = 10;\r\n    return Detector;\r\n}());\r\nexports.default = Detector;\r\n//# sourceMappingURL=Detector.js.map"]},"metadata":{},"sourceType":"script"}
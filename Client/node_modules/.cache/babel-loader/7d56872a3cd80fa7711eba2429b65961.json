{"ast":null,"code":"\"use strict\";\n/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.qrcode {*/\n\nvar BarcodeFormat_1 = require(\"../BarcodeFormat\");\n\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\n\nvar Result_1 = require(\"../Result\");\n\nvar ResultMetadataType_1 = require(\"../ResultMetadataType\");\n\nvar BitMatrix_1 = require(\"../common/BitMatrix\");\n\nvar Decoder_1 = require(\"./decoder/Decoder\");\n\nvar QRCodeDecoderMetaData_1 = require(\"./decoder/QRCodeDecoderMetaData\");\n\nvar Detector_1 = require(\"./detector/Detector\");\n\nvar NotFoundException_1 = require(\"../NotFoundException\");\n/*import java.util.List;*/\n\n/*import java.util.Map;*/\n\n/**\r\n * This implementation can detect and decode QR Codes in an image.\r\n *\r\n * @author Sean Owen\r\n */\n\n\nvar QRCodeReader =\n/** @class */\nfunction () {\n  function QRCodeReader() {\n    this.decoder = new Decoder_1.default();\n  }\n\n  QRCodeReader.prototype.getDecoder = function () {\n    return this.decoder;\n  };\n  /**\r\n   * Locates and decodes a QR code in an image.\r\n   *\r\n   * @return a representing: string the content encoded by the QR code\r\n   * @throws NotFoundException if a QR code cannot be found\r\n   * @throws FormatException if a QR code cannot be decoded\r\n   * @throws ChecksumException if error correction fails\r\n   */\n\n  /*@Override*/\n  // public decode(image: BinaryBitmap): Result /*throws NotFoundException, ChecksumException, FormatException */ {\n  //   return this.decode(image, null)\n  // }\n\n  /*@Override*/\n\n\n  QRCodeReader.prototype.decode = function (image, hints) {\n    var decoderResult;\n    var points;\n\n    if (hints !== undefined && hints !== null && undefined !== hints.get(DecodeHintType_1.default.PURE_BARCODE)) {\n      var bits = QRCodeReader.extractPureBits(image.getBlackMatrix());\n      decoderResult = this.decoder.decodeBitMatrix(bits, hints);\n      points = QRCodeReader.NO_POINTS;\n    } else {\n      var detectorResult = new Detector_1.default(image.getBlackMatrix()).detect(hints);\n      decoderResult = this.decoder.decodeBitMatrix(detectorResult.getBits(), hints);\n      points = detectorResult.getPoints();\n    } // If the code was mirrored: swap the bottom-left and the top-right points.\n\n\n    if (decoderResult.getOther() instanceof QRCodeDecoderMetaData_1.default) {\n      decoderResult.getOther().applyMirroredCorrection(points);\n    }\n\n    var result = new Result_1.default(decoderResult.getText(), decoderResult.getRawBytes(), undefined, points, BarcodeFormat_1.default.QR_CODE, undefined);\n    var byteSegments = decoderResult.getByteSegments();\n\n    if (byteSegments !== null) {\n      result.putMetadata(ResultMetadataType_1.default.BYTE_SEGMENTS, byteSegments);\n    }\n\n    var ecLevel = decoderResult.getECLevel();\n\n    if (ecLevel !== null) {\n      result.putMetadata(ResultMetadataType_1.default.ERROR_CORRECTION_LEVEL, ecLevel);\n    }\n\n    if (decoderResult.hasStructuredAppend()) {\n      result.putMetadata(ResultMetadataType_1.default.STRUCTURED_APPEND_SEQUENCE, decoderResult.getStructuredAppendSequenceNumber());\n      result.putMetadata(ResultMetadataType_1.default.STRUCTURED_APPEND_PARITY, decoderResult.getStructuredAppendParity());\n    }\n\n    return result;\n  };\n  /*@Override*/\n\n\n  QRCodeReader.prototype.reset = function () {// do nothing\n  };\n  /**\r\n   * This method detects a code in a \"pure\" image -- that is, pure monochrome image\r\n   * which contains only an unrotated, unskewed, image of a code, with some white border\r\n   * around it. This is a specialized method that works exceptionally fast in this special\r\n   * case.\r\n   *\r\n   * @see com.google.zxing.datamatrix.DataMatrixReader#extractPureBits(BitMatrix)\r\n   */\n\n\n  QRCodeReader.extractPureBits = function (image) {\n    var leftTopBlack = image.getTopLeftOnBit();\n    var rightBottomBlack = image.getBottomRightOnBit();\n\n    if (leftTopBlack === null || rightBottomBlack === null) {\n      throw new NotFoundException_1.default();\n    }\n\n    var moduleSize = this.moduleSize(leftTopBlack, image);\n    var top = leftTopBlack[1];\n    var bottom = rightBottomBlack[1];\n    var left = leftTopBlack[0];\n    var right = rightBottomBlack[0]; // Sanity check!\n\n    if (left >= right || top >= bottom) {\n      throw new NotFoundException_1.default();\n    }\n\n    if (bottom - top !== right - left) {\n      // Special case, where bottom-right module wasn't black so we found something else in the last row\n      // Assume it's a square, so use height as the width\n      right = left + (bottom - top);\n\n      if (right >= image.getWidth()) {\n        // Abort if that would not make sense -- off image\n        throw new NotFoundException_1.default();\n      }\n    }\n\n    var matrixWidth = Math.round((right - left + 1) / moduleSize);\n    var matrixHeight = Math.round((bottom - top + 1) / moduleSize);\n\n    if (matrixWidth <= 0 || matrixHeight <= 0) {\n      throw new NotFoundException_1.default();\n    }\n\n    if (matrixHeight !== matrixWidth) {\n      // Only possibly decode square regions\n      throw new NotFoundException_1.default();\n    } // Push in the \"border\" by half the module width so that we start\n    // sampling in the middle of the module. Just in case the image is a\n    // little off, this will help recover.\n\n\n    var nudge =\n    /*(int) */\n    Math.floor(moduleSize / 2.0);\n    top += nudge;\n    left += nudge; // But careful that this does not sample off the edge\n    // \"right\" is the farthest-right valid pixel location -- right+1 is not necessarily\n    // This is positive by how much the inner x loop below would be too large\n\n    var nudgedTooFarRight = left +\n    /*(int) */\n    Math.floor((matrixWidth - 1) * moduleSize) - right;\n\n    if (nudgedTooFarRight > 0) {\n      if (nudgedTooFarRight > nudge) {\n        // Neither way fits; abort\n        throw new NotFoundException_1.default();\n      }\n\n      left -= nudgedTooFarRight;\n    } // See logic above\n\n\n    var nudgedTooFarDown = top +\n    /*(int) */\n    Math.floor((matrixHeight - 1) * moduleSize) - bottom;\n\n    if (nudgedTooFarDown > 0) {\n      if (nudgedTooFarDown > nudge) {\n        // Neither way fits; abort\n        throw new NotFoundException_1.default();\n      }\n\n      top -= nudgedTooFarDown;\n    } // Now just read off the bits\n\n\n    var bits = new BitMatrix_1.default(matrixWidth, matrixHeight);\n\n    for (var y = 0; y < matrixHeight; y++) {\n      var iOffset = top +\n      /*(int) */\n      Math.floor(y * moduleSize);\n\n      for (var x = 0; x < matrixWidth; x++) {\n        if (image.get(left +\n        /*(int) */\n        Math.floor(x * moduleSize), iOffset)) {\n          bits.set(x, y);\n        }\n      }\n    }\n\n    return bits;\n  };\n\n  QRCodeReader.moduleSize = function (leftTopBlack, image) {\n    var height = image.getHeight();\n    var width = image.getWidth();\n    var x = leftTopBlack[0];\n    var y = leftTopBlack[1];\n    var inBlack = true;\n    var transitions = 0;\n\n    while (x < width && y < height) {\n      if (inBlack !== image.get(x, y)) {\n        if (++transitions === 5) {\n          break;\n        }\n\n        inBlack = !inBlack;\n      }\n\n      x++;\n      y++;\n    }\n\n    if (x === width || y === height) {\n      throw new NotFoundException_1.default();\n    }\n\n    return (x - leftTopBlack[0]) / 7.0;\n  };\n\n  QRCodeReader.NO_POINTS = new Array();\n  return QRCodeReader;\n}();\n\nexports.default = QRCodeReader;","map":{"version":3,"sources":["../../../src/core/qrcode/QRCodeReader.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*namespace com.google.zxing.qrcode {*/\r\nvar BarcodeFormat_1 = require(\"../BarcodeFormat\");\r\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\r\nvar Result_1 = require(\"../Result\");\r\nvar ResultMetadataType_1 = require(\"../ResultMetadataType\");\r\nvar BitMatrix_1 = require(\"../common/BitMatrix\");\r\nvar Decoder_1 = require(\"./decoder/Decoder\");\r\nvar QRCodeDecoderMetaData_1 = require(\"./decoder/QRCodeDecoderMetaData\");\r\nvar Detector_1 = require(\"./detector/Detector\");\r\nvar NotFoundException_1 = require(\"../NotFoundException\");\r\n/*import java.util.List;*/\r\n/*import java.util.Map;*/\r\n/**\r\n * This implementation can detect and decode QR Codes in an image.\r\n *\r\n * @author Sean Owen\r\n */\r\nvar QRCodeReader = /** @class */ (function () {\r\n    function QRCodeReader() {\r\n        this.decoder = new Decoder_1.default();\r\n    }\r\n    QRCodeReader.prototype.getDecoder = function () {\r\n        return this.decoder;\r\n    };\r\n    /**\r\n     * Locates and decodes a QR code in an image.\r\n     *\r\n     * @return a representing: string the content encoded by the QR code\r\n     * @throws NotFoundException if a QR code cannot be found\r\n     * @throws FormatException if a QR code cannot be decoded\r\n     * @throws ChecksumException if error correction fails\r\n     */\r\n    /*@Override*/\r\n    // public decode(image: BinaryBitmap): Result /*throws NotFoundException, ChecksumException, FormatException */ {\r\n    //   return this.decode(image, null)\r\n    // }\r\n    /*@Override*/\r\n    QRCodeReader.prototype.decode = function (image, hints) {\r\n        var decoderResult;\r\n        var points;\r\n        if (hints !== undefined && hints !== null && undefined !== hints.get(DecodeHintType_1.default.PURE_BARCODE)) {\r\n            var bits = QRCodeReader.extractPureBits(image.getBlackMatrix());\r\n            decoderResult = this.decoder.decodeBitMatrix(bits, hints);\r\n            points = QRCodeReader.NO_POINTS;\r\n        }\r\n        else {\r\n            var detectorResult = new Detector_1.default(image.getBlackMatrix()).detect(hints);\r\n            decoderResult = this.decoder.decodeBitMatrix(detectorResult.getBits(), hints);\r\n            points = detectorResult.getPoints();\r\n        }\r\n        // If the code was mirrored: swap the bottom-left and the top-right points.\r\n        if (decoderResult.getOther() instanceof QRCodeDecoderMetaData_1.default) {\r\n            decoderResult.getOther().applyMirroredCorrection(points);\r\n        }\r\n        var result = new Result_1.default(decoderResult.getText(), decoderResult.getRawBytes(), undefined, points, BarcodeFormat_1.default.QR_CODE, undefined);\r\n        var byteSegments = decoderResult.getByteSegments();\r\n        if (byteSegments !== null) {\r\n            result.putMetadata(ResultMetadataType_1.default.BYTE_SEGMENTS, byteSegments);\r\n        }\r\n        var ecLevel = decoderResult.getECLevel();\r\n        if (ecLevel !== null) {\r\n            result.putMetadata(ResultMetadataType_1.default.ERROR_CORRECTION_LEVEL, ecLevel);\r\n        }\r\n        if (decoderResult.hasStructuredAppend()) {\r\n            result.putMetadata(ResultMetadataType_1.default.STRUCTURED_APPEND_SEQUENCE, decoderResult.getStructuredAppendSequenceNumber());\r\n            result.putMetadata(ResultMetadataType_1.default.STRUCTURED_APPEND_PARITY, decoderResult.getStructuredAppendParity());\r\n        }\r\n        return result;\r\n    };\r\n    /*@Override*/\r\n    QRCodeReader.prototype.reset = function () {\r\n        // do nothing\r\n    };\r\n    /**\r\n     * This method detects a code in a \"pure\" image -- that is, pure monochrome image\r\n     * which contains only an unrotated, unskewed, image of a code, with some white border\r\n     * around it. This is a specialized method that works exceptionally fast in this special\r\n     * case.\r\n     *\r\n     * @see com.google.zxing.datamatrix.DataMatrixReader#extractPureBits(BitMatrix)\r\n     */\r\n    QRCodeReader.extractPureBits = function (image) {\r\n        var leftTopBlack = image.getTopLeftOnBit();\r\n        var rightBottomBlack = image.getBottomRightOnBit();\r\n        if (leftTopBlack === null || rightBottomBlack === null) {\r\n            throw new NotFoundException_1.default();\r\n        }\r\n        var moduleSize = this.moduleSize(leftTopBlack, image);\r\n        var top = leftTopBlack[1];\r\n        var bottom = rightBottomBlack[1];\r\n        var left = leftTopBlack[0];\r\n        var right = rightBottomBlack[0];\r\n        // Sanity check!\r\n        if (left >= right || top >= bottom) {\r\n            throw new NotFoundException_1.default();\r\n        }\r\n        if (bottom - top !== right - left) {\r\n            // Special case, where bottom-right module wasn't black so we found something else in the last row\r\n            // Assume it's a square, so use height as the width\r\n            right = left + (bottom - top);\r\n            if (right >= image.getWidth()) {\r\n                // Abort if that would not make sense -- off image\r\n                throw new NotFoundException_1.default();\r\n            }\r\n        }\r\n        var matrixWidth = Math.round((right - left + 1) / moduleSize);\r\n        var matrixHeight = Math.round((bottom - top + 1) / moduleSize);\r\n        if (matrixWidth <= 0 || matrixHeight <= 0) {\r\n            throw new NotFoundException_1.default();\r\n        }\r\n        if (matrixHeight !== matrixWidth) {\r\n            // Only possibly decode square regions\r\n            throw new NotFoundException_1.default();\r\n        }\r\n        // Push in the \"border\" by half the module width so that we start\r\n        // sampling in the middle of the module. Just in case the image is a\r\n        // little off, this will help recover.\r\n        var nudge = /*(int) */ Math.floor(moduleSize / 2.0);\r\n        top += nudge;\r\n        left += nudge;\r\n        // But careful that this does not sample off the edge\r\n        // \"right\" is the farthest-right valid pixel location -- right+1 is not necessarily\r\n        // This is positive by how much the inner x loop below would be too large\r\n        var nudgedTooFarRight = left + /*(int) */ Math.floor((matrixWidth - 1) * moduleSize) - right;\r\n        if (nudgedTooFarRight > 0) {\r\n            if (nudgedTooFarRight > nudge) {\r\n                // Neither way fits; abort\r\n                throw new NotFoundException_1.default();\r\n            }\r\n            left -= nudgedTooFarRight;\r\n        }\r\n        // See logic above\r\n        var nudgedTooFarDown = top + /*(int) */ Math.floor((matrixHeight - 1) * moduleSize) - bottom;\r\n        if (nudgedTooFarDown > 0) {\r\n            if (nudgedTooFarDown > nudge) {\r\n                // Neither way fits; abort\r\n                throw new NotFoundException_1.default();\r\n            }\r\n            top -= nudgedTooFarDown;\r\n        }\r\n        // Now just read off the bits\r\n        var bits = new BitMatrix_1.default(matrixWidth, matrixHeight);\r\n        for (var y = 0; y < matrixHeight; y++) {\r\n            var iOffset = top + /*(int) */ Math.floor(y * moduleSize);\r\n            for (var x = 0; x < matrixWidth; x++) {\r\n                if (image.get(left + /*(int) */ Math.floor(x * moduleSize), iOffset)) {\r\n                    bits.set(x, y);\r\n                }\r\n            }\r\n        }\r\n        return bits;\r\n    };\r\n    QRCodeReader.moduleSize = function (leftTopBlack, image) {\r\n        var height = image.getHeight();\r\n        var width = image.getWidth();\r\n        var x = leftTopBlack[0];\r\n        var y = leftTopBlack[1];\r\n        var inBlack = true;\r\n        var transitions = 0;\r\n        while (x < width && y < height) {\r\n            if (inBlack !== image.get(x, y)) {\r\n                if (++transitions === 5) {\r\n                    break;\r\n                }\r\n                inBlack = !inBlack;\r\n            }\r\n            x++;\r\n            y++;\r\n        }\r\n        if (x === width || y === height) {\r\n            throw new NotFoundException_1.default();\r\n        }\r\n        return (x - leftTopBlack[0]) / 7.0;\r\n    };\r\n    QRCodeReader.NO_POINTS = new Array();\r\n    return QRCodeReader;\r\n}());\r\nexports.default = QRCodeReader;\r\n//# sourceMappingURL=QRCodeReader.js.map"]},"metadata":{},"sourceType":"script"}
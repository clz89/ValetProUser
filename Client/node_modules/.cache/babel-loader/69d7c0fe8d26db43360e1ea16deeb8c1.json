{"ast":null,"code":"\"use strict\";\n/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.common.reedsolomon {*/\n\nvar GenericGF_1 = require(\"./GenericGF\");\n\nvar GenericGFPoly_1 = require(\"./GenericGFPoly\");\n\nvar ReedSolomonException_1 = require(\"../../ReedSolomonException\");\n\nvar IllegalStateException_1 = require(\"../../IllegalStateException\");\n/**\r\n * <p>Implements Reed-Solomon decoding, as the name implies.</p>\r\n *\r\n * <p>The algorithm will not be explained here, but the following references were helpful\r\n * in creating this implementation:</p>\r\n *\r\n * <ul>\r\n * <li>Bruce Maggs.\r\n * <a href=\"http://www.cs.cmu.edu/afs/cs.cmu.edu/project/pscico-guyb/realworld/www/rs_decode.ps\">\r\n * \"Decoding Reed-Solomon Codes\"</a> (see discussion of Forney's Formula)</li>\r\n * <li>J.I. Hall. <a href=\"www.mth.msu.edu/~jhall/classes/codenotes/GRS.pdf\">\r\n * \"Chapter 5. Generalized Reed-Solomon Codes\"</a>\r\n * (see discussion of Euclidean algorithm)</li>\r\n * </ul>\r\n *\r\n * <p>Much credit is due to William Rucklidge since portions of this code are an indirect\r\n * port of his C++ Reed-Solomon implementation.</p>\r\n *\r\n * @author Sean Owen\r\n * @author William Rucklidge\r\n * @author sanfordsquires\r\n */\n\n\nvar ReedSolomonDecoder =\n/** @class */\nfunction () {\n  function ReedSolomonDecoder(field) {\n    this.field = field;\n  }\n  /**\r\n   * <p>Decodes given set of received codewords, which include both data and error-correction\r\n   * codewords. Really, this means it uses Reed-Solomon to detect and correct errors, in-place,\r\n   * in the input.</p>\r\n   *\r\n   * @param received data and error-correction codewords\r\n   * @param twoS number of error-correction codewords available\r\n   * @throws ReedSolomonException if decoding fails for any reason\r\n   */\n\n\n  ReedSolomonDecoder.prototype.decode = function (received, twoS\n  /*int*/\n  ) {\n    var field = this.field;\n    var poly = new GenericGFPoly_1.default(field, received);\n    var syndromeCoefficients = new Int32Array(twoS);\n    var noError = true;\n\n    for (var i = 0; i < twoS; i++) {\n      var evalResult = poly.evaluateAt(field.exp(i + field.getGeneratorBase()));\n      syndromeCoefficients[syndromeCoefficients.length - 1 - i] = evalResult;\n\n      if (evalResult !== 0) {\n        noError = false;\n      }\n    }\n\n    if (noError) {\n      return;\n    }\n\n    var syndrome = new GenericGFPoly_1.default(field, syndromeCoefficients);\n    var sigmaOmega = this.runEuclideanAlgorithm(field.buildMonomial(twoS, 1), syndrome, twoS);\n    var sigma = sigmaOmega[0];\n    var omega = sigmaOmega[1];\n    var errorLocations = this.findErrorLocations(sigma);\n    var errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations);\n\n    for (var i = 0; i < errorLocations.length; i++) {\n      var position = received.length - 1 - field.log(errorLocations[i]);\n\n      if (position < 0) {\n        throw new ReedSolomonException_1.default('Bad error location');\n      }\n\n      received[position] = GenericGF_1.default.addOrSubtract(received[position], errorMagnitudes[i]);\n    }\n  };\n\n  ReedSolomonDecoder.prototype.runEuclideanAlgorithm = function (a, b, R\n  /*int*/\n  ) {\n    // Assume a's degree is >= b's\n    if (a.getDegree() < b.getDegree()) {\n      var temp = a;\n      a = b;\n      b = temp;\n    }\n\n    var field = this.field;\n    var rLast = a;\n    var r = b;\n    var tLast = field.getZero();\n    var t = field.getOne(); // Run Euclidean algorithm until r's degree is less than R/2\n\n    while (r.getDegree() >= (R / 2 | 0)) {\n      var rLastLast = rLast;\n      var tLastLast = tLast;\n      rLast = r;\n      tLast = t; // Divide rLastLast by rLast, with quotient in q and remainder in r\n\n      if (rLast.isZero()) {\n        // Oops, Euclidean algorithm already terminated?\n        throw new ReedSolomonException_1.default('r_{i-1} was zero');\n      }\n\n      r = rLastLast;\n      var q = field.getZero();\n      var denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());\n      var dltInverse = field.inverse(denominatorLeadingTerm);\n\n      while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {\n        var degreeDiff = r.getDegree() - rLast.getDegree();\n        var scale = field.multiply(r.getCoefficient(r.getDegree()), dltInverse);\n        q = q.addOrSubtract(field.buildMonomial(degreeDiff, scale));\n        r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));\n      }\n\n      t = q.multiply(tLast).addOrSubtract(tLastLast);\n\n      if (r.getDegree() >= rLast.getDegree()) {\n        throw new IllegalStateException_1.default('Division algorithm failed to reduce polynomial?');\n      }\n    }\n\n    var sigmaTildeAtZero = t.getCoefficient(0);\n\n    if (sigmaTildeAtZero === 0) {\n      throw new ReedSolomonException_1.default('sigmaTilde(0) was zero');\n    }\n\n    var inverse = field.inverse(sigmaTildeAtZero);\n    var sigma = t.multiplyScalar(inverse);\n    var omega = r.multiplyScalar(inverse);\n    return [sigma, omega];\n  };\n\n  ReedSolomonDecoder.prototype.findErrorLocations = function (errorLocator) {\n    // This is a direct application of Chien's search\n    var numErrors = errorLocator.getDegree();\n\n    if (numErrors === 1) {\n      // shortcut\n      return Int32Array.from([errorLocator.getCoefficient(1)]);\n    }\n\n    var result = new Int32Array(numErrors);\n    var e = 0;\n    var field = this.field;\n\n    for (var i = 1; i < field.getSize() && e < numErrors; i++) {\n      if (errorLocator.evaluateAt(i) === 0) {\n        result[e] = field.inverse(i);\n        e++;\n      }\n    }\n\n    if (e !== numErrors) {\n      throw new ReedSolomonException_1.default('Error locator degree does not match number of roots');\n    }\n\n    return result;\n  };\n\n  ReedSolomonDecoder.prototype.findErrorMagnitudes = function (errorEvaluator, errorLocations) {\n    // This is directly applying Forney's Formula\n    var s = errorLocations.length;\n    var result = new Int32Array(s);\n    var field = this.field;\n\n    for (var i = 0; i < s; i++) {\n      var xiInverse = field.inverse(errorLocations[i]);\n      var denominator = 1;\n\n      for (var j = 0; j < s; j++) {\n        if (i !== j) {\n          // denominator = field.multiply(denominator,\n          //    GenericGF.addOrSubtract(1, field.multiply(errorLocations[j], xiInverse)))\n          // Above should work but fails on some Apple and Linux JDKs due to a Hotspot bug.\n          // Below is a funny-looking workaround from Steven Parkes\n          var term = field.multiply(errorLocations[j], xiInverse);\n          var termPlus1 = (term & 0x1) === 0 ? term | 1 : term & ~1;\n          denominator = field.multiply(denominator, termPlus1);\n        }\n      }\n\n      result[i] = field.multiply(errorEvaluator.evaluateAt(xiInverse), field.inverse(denominator));\n\n      if (field.getGeneratorBase() !== 0) {\n        result[i] = field.multiply(result[i], xiInverse);\n      }\n    }\n\n    return result;\n  };\n\n  return ReedSolomonDecoder;\n}();\n\nexports.default = ReedSolomonDecoder;","map":{"version":3,"sources":["../../../../src/core/common/reedsolomon/ReedSolomonDecoder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*namespace com.google.zxing.common.reedsolomon {*/\r\nvar GenericGF_1 = require(\"./GenericGF\");\r\nvar GenericGFPoly_1 = require(\"./GenericGFPoly\");\r\nvar ReedSolomonException_1 = require(\"../../ReedSolomonException\");\r\nvar IllegalStateException_1 = require(\"../../IllegalStateException\");\r\n/**\r\n * <p>Implements Reed-Solomon decoding, as the name implies.</p>\r\n *\r\n * <p>The algorithm will not be explained here, but the following references were helpful\r\n * in creating this implementation:</p>\r\n *\r\n * <ul>\r\n * <li>Bruce Maggs.\r\n * <a href=\"http://www.cs.cmu.edu/afs/cs.cmu.edu/project/pscico-guyb/realworld/www/rs_decode.ps\">\r\n * \"Decoding Reed-Solomon Codes\"</a> (see discussion of Forney's Formula)</li>\r\n * <li>J.I. Hall. <a href=\"www.mth.msu.edu/~jhall/classes/codenotes/GRS.pdf\">\r\n * \"Chapter 5. Generalized Reed-Solomon Codes\"</a>\r\n * (see discussion of Euclidean algorithm)</li>\r\n * </ul>\r\n *\r\n * <p>Much credit is due to William Rucklidge since portions of this code are an indirect\r\n * port of his C++ Reed-Solomon implementation.</p>\r\n *\r\n * @author Sean Owen\r\n * @author William Rucklidge\r\n * @author sanfordsquires\r\n */\r\nvar ReedSolomonDecoder = /** @class */ (function () {\r\n    function ReedSolomonDecoder(field) {\r\n        this.field = field;\r\n    }\r\n    /**\r\n     * <p>Decodes given set of received codewords, which include both data and error-correction\r\n     * codewords. Really, this means it uses Reed-Solomon to detect and correct errors, in-place,\r\n     * in the input.</p>\r\n     *\r\n     * @param received data and error-correction codewords\r\n     * @param twoS number of error-correction codewords available\r\n     * @throws ReedSolomonException if decoding fails for any reason\r\n     */\r\n    ReedSolomonDecoder.prototype.decode = function (received, twoS /*int*/) {\r\n        var field = this.field;\r\n        var poly = new GenericGFPoly_1.default(field, received);\r\n        var syndromeCoefficients = new Int32Array(twoS);\r\n        var noError = true;\r\n        for (var i = 0; i < twoS; i++) {\r\n            var evalResult = poly.evaluateAt(field.exp(i + field.getGeneratorBase()));\r\n            syndromeCoefficients[syndromeCoefficients.length - 1 - i] = evalResult;\r\n            if (evalResult !== 0) {\r\n                noError = false;\r\n            }\r\n        }\r\n        if (noError) {\r\n            return;\r\n        }\r\n        var syndrome = new GenericGFPoly_1.default(field, syndromeCoefficients);\r\n        var sigmaOmega = this.runEuclideanAlgorithm(field.buildMonomial(twoS, 1), syndrome, twoS);\r\n        var sigma = sigmaOmega[0];\r\n        var omega = sigmaOmega[1];\r\n        var errorLocations = this.findErrorLocations(sigma);\r\n        var errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations);\r\n        for (var i = 0; i < errorLocations.length; i++) {\r\n            var position = received.length - 1 - field.log(errorLocations[i]);\r\n            if (position < 0) {\r\n                throw new ReedSolomonException_1.default('Bad error location');\r\n            }\r\n            received[position] = GenericGF_1.default.addOrSubtract(received[position], errorMagnitudes[i]);\r\n        }\r\n    };\r\n    ReedSolomonDecoder.prototype.runEuclideanAlgorithm = function (a, b, R /*int*/) {\r\n        // Assume a's degree is >= b's\r\n        if (a.getDegree() < b.getDegree()) {\r\n            var temp = a;\r\n            a = b;\r\n            b = temp;\r\n        }\r\n        var field = this.field;\r\n        var rLast = a;\r\n        var r = b;\r\n        var tLast = field.getZero();\r\n        var t = field.getOne();\r\n        // Run Euclidean algorithm until r's degree is less than R/2\r\n        while (r.getDegree() >= (R / 2 | 0)) {\r\n            var rLastLast = rLast;\r\n            var tLastLast = tLast;\r\n            rLast = r;\r\n            tLast = t;\r\n            // Divide rLastLast by rLast, with quotient in q and remainder in r\r\n            if (rLast.isZero()) {\r\n                // Oops, Euclidean algorithm already terminated?\r\n                throw new ReedSolomonException_1.default('r_{i-1} was zero');\r\n            }\r\n            r = rLastLast;\r\n            var q = field.getZero();\r\n            var denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());\r\n            var dltInverse = field.inverse(denominatorLeadingTerm);\r\n            while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {\r\n                var degreeDiff = r.getDegree() - rLast.getDegree();\r\n                var scale = field.multiply(r.getCoefficient(r.getDegree()), dltInverse);\r\n                q = q.addOrSubtract(field.buildMonomial(degreeDiff, scale));\r\n                r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));\r\n            }\r\n            t = q.multiply(tLast).addOrSubtract(tLastLast);\r\n            if (r.getDegree() >= rLast.getDegree()) {\r\n                throw new IllegalStateException_1.default('Division algorithm failed to reduce polynomial?');\r\n            }\r\n        }\r\n        var sigmaTildeAtZero = t.getCoefficient(0);\r\n        if (sigmaTildeAtZero === 0) {\r\n            throw new ReedSolomonException_1.default('sigmaTilde(0) was zero');\r\n        }\r\n        var inverse = field.inverse(sigmaTildeAtZero);\r\n        var sigma = t.multiplyScalar(inverse);\r\n        var omega = r.multiplyScalar(inverse);\r\n        return [sigma, omega];\r\n    };\r\n    ReedSolomonDecoder.prototype.findErrorLocations = function (errorLocator) {\r\n        // This is a direct application of Chien's search\r\n        var numErrors = errorLocator.getDegree();\r\n        if (numErrors === 1) { // shortcut\r\n            return Int32Array.from([errorLocator.getCoefficient(1)]);\r\n        }\r\n        var result = new Int32Array(numErrors);\r\n        var e = 0;\r\n        var field = this.field;\r\n        for (var i = 1; i < field.getSize() && e < numErrors; i++) {\r\n            if (errorLocator.evaluateAt(i) === 0) {\r\n                result[e] = field.inverse(i);\r\n                e++;\r\n            }\r\n        }\r\n        if (e !== numErrors) {\r\n            throw new ReedSolomonException_1.default('Error locator degree does not match number of roots');\r\n        }\r\n        return result;\r\n    };\r\n    ReedSolomonDecoder.prototype.findErrorMagnitudes = function (errorEvaluator, errorLocations) {\r\n        // This is directly applying Forney's Formula\r\n        var s = errorLocations.length;\r\n        var result = new Int32Array(s);\r\n        var field = this.field;\r\n        for (var i = 0; i < s; i++) {\r\n            var xiInverse = field.inverse(errorLocations[i]);\r\n            var denominator = 1;\r\n            for (var j = 0; j < s; j++) {\r\n                if (i !== j) {\r\n                    // denominator = field.multiply(denominator,\r\n                    //    GenericGF.addOrSubtract(1, field.multiply(errorLocations[j], xiInverse)))\r\n                    // Above should work but fails on some Apple and Linux JDKs due to a Hotspot bug.\r\n                    // Below is a funny-looking workaround from Steven Parkes\r\n                    var term = field.multiply(errorLocations[j], xiInverse);\r\n                    var termPlus1 = (term & 0x1) === 0 ? term | 1 : term & ~1;\r\n                    denominator = field.multiply(denominator, termPlus1);\r\n                }\r\n            }\r\n            result[i] = field.multiply(errorEvaluator.evaluateAt(xiInverse), field.inverse(denominator));\r\n            if (field.getGeneratorBase() !== 0) {\r\n                result[i] = field.multiply(result[i], xiInverse);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    return ReedSolomonDecoder;\r\n}());\r\nexports.default = ReedSolomonDecoder;\r\n//# sourceMappingURL=ReedSolomonDecoder.js.map"]},"metadata":{},"sourceType":"script"}
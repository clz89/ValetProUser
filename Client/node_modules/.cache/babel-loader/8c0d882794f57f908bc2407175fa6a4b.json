{"ast":null,"code":"\"use strict\";\n/*\r\n * Copyright 2009 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar IllegalArgumentException_1 = require(\"./IllegalArgumentException\");\n\nvar BinaryBitmap =\n/** @class */\nfunction () {\n  function BinaryBitmap(binarizer) {\n    this.binarizer = binarizer;\n\n    if (binarizer === null) {\n      throw new IllegalArgumentException_1.default('Binarizer must be non-null.');\n    }\n  }\n  /**\r\n   * @return The width of the bitmap.\r\n   */\n\n\n  BinaryBitmap.prototype.getWidth = function () {\n    return this.binarizer.getWidth();\n  };\n  /**\r\n   * @return The height of the bitmap.\r\n   */\n\n\n  BinaryBitmap.prototype.getHeight = function () {\n    return this.binarizer.getHeight();\n  };\n  /**\r\n   * Converts one row of luminance data to 1 bit data. May actually do the conversion, or return\r\n   * cached data. Callers should assume this method is expensive and call it as seldom as possible.\r\n   * This method is intended for decoding 1D barcodes and may choose to apply sharpening.\r\n   *\r\n   * @param y The row to fetch, which must be in [0, bitmap height)\r\n   * @param row An optional preallocated array. If null or too small, it will be ignored.\r\n   *            If used, the Binarizer will call BitArray.clear(). Always use the returned object.\r\n   * @return The array of bits for this row (true means black).\r\n   * @throws NotFoundException if row can't be binarized\r\n   */\n\n\n  BinaryBitmap.prototype.getBlackRow = function (y\n  /*int*/\n  , row) {\n    return this.binarizer.getBlackRow(y, row);\n  };\n  /**\r\n   * Converts a 2D array of luminance data to 1 bit. As above, assume this method is expensive\r\n   * and do not call it repeatedly. This method is intended for decoding 2D barcodes and may or\r\n   * may not apply sharpening. Therefore, a row from this matrix may not be identical to one\r\n   * fetched using getBlackRow(), so don't mix and match between them.\r\n   *\r\n   * @return The 2D array of bits for the image (true means black).\r\n   * @throws NotFoundException if image can't be binarized to make a matrix\r\n   */\n\n\n  BinaryBitmap.prototype.getBlackMatrix = function () {\n    // The matrix is created on demand the first time it is requested, then cached. There are two\n    // reasons for this:\n    // 1. This work will never be done if the caller only installs 1D Reader objects, or if a\n    //    1D Reader finds a barcode before the 2D Readers run.\n    // 2. This work will only be done once even if the caller installs multiple 2D Readers.\n    if (this.matrix === null || this.matrix === undefined) {\n      this.matrix = this.binarizer.getBlackMatrix();\n    }\n\n    return this.matrix;\n  };\n  /**\r\n   * @return Whether this bitmap can be cropped.\r\n   */\n\n\n  BinaryBitmap.prototype.isCropSupported = function () {\n    return this.binarizer.getLuminanceSource().isCropSupported();\n  };\n  /**\r\n   * Returns a new object with cropped image data. Implementations may keep a reference to the\r\n   * original data rather than a copy. Only callable if isCropSupported() is true.\r\n   *\r\n   * @param left The left coordinate, which must be in [0,getWidth())\r\n   * @param top The top coordinate, which must be in [0,getHeight())\r\n   * @param width The width of the rectangle to crop.\r\n   * @param height The height of the rectangle to crop.\r\n   * @return A cropped version of this object.\r\n   */\n\n\n  BinaryBitmap.prototype.crop = function (left\n  /*int*/\n  , top\n  /*int*/\n  , width\n  /*int*/\n  , height\n  /*int*/\n  ) {\n    var newSource = this.binarizer.getLuminanceSource().crop(left, top, width, height);\n    return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\n  };\n  /**\r\n   * @return Whether this bitmap supports counter-clockwise rotation.\r\n   */\n\n\n  BinaryBitmap.prototype.isRotateSupported = function () {\n    return this.binarizer.getLuminanceSource().isRotateSupported();\n  };\n  /**\r\n   * Returns a new object with rotated image data by 90 degrees counterclockwise.\r\n   * Only callable if {@link #isRotateSupported()} is true.\r\n   *\r\n   * @return A rotated version of this object.\r\n   */\n\n\n  BinaryBitmap.prototype.rotateCounterClockwise = function () {\n    var newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise();\n    return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\n  };\n  /**\r\n   * Returns a new object with rotated image data by 45 degrees counterclockwise.\r\n   * Only callable if {@link #isRotateSupported()} is true.\r\n   *\r\n   * @return A rotated version of this object.\r\n   */\n\n\n  BinaryBitmap.prototype.rotateCounterClockwise45 = function () {\n    var newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise45();\n    return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\n  };\n  /*@Override*/\n\n\n  BinaryBitmap.prototype.toString = function () {\n    try {\n      return this.getBlackMatrix().toString();\n    } catch (e\n    /*: NotFoundException*/\n    ) {\n      return '';\n    }\n  };\n\n  return BinaryBitmap;\n}();\n\nexports.default = BinaryBitmap;","map":{"version":3,"sources":["../../src/core/BinaryBitmap.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/*\r\n * Copyright 2009 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar IllegalArgumentException_1 = require(\"./IllegalArgumentException\");\r\nvar BinaryBitmap = /** @class */ (function () {\r\n    function BinaryBitmap(binarizer) {\r\n        this.binarizer = binarizer;\r\n        if (binarizer === null) {\r\n            throw new IllegalArgumentException_1.default('Binarizer must be non-null.');\r\n        }\r\n    }\r\n    /**\r\n     * @return The width of the bitmap.\r\n     */\r\n    BinaryBitmap.prototype.getWidth = function () {\r\n        return this.binarizer.getWidth();\r\n    };\r\n    /**\r\n     * @return The height of the bitmap.\r\n     */\r\n    BinaryBitmap.prototype.getHeight = function () {\r\n        return this.binarizer.getHeight();\r\n    };\r\n    /**\r\n     * Converts one row of luminance data to 1 bit data. May actually do the conversion, or return\r\n     * cached data. Callers should assume this method is expensive and call it as seldom as possible.\r\n     * This method is intended for decoding 1D barcodes and may choose to apply sharpening.\r\n     *\r\n     * @param y The row to fetch, which must be in [0, bitmap height)\r\n     * @param row An optional preallocated array. If null or too small, it will be ignored.\r\n     *            If used, the Binarizer will call BitArray.clear(). Always use the returned object.\r\n     * @return The array of bits for this row (true means black).\r\n     * @throws NotFoundException if row can't be binarized\r\n     */\r\n    BinaryBitmap.prototype.getBlackRow = function (y /*int*/, row) {\r\n        return this.binarizer.getBlackRow(y, row);\r\n    };\r\n    /**\r\n     * Converts a 2D array of luminance data to 1 bit. As above, assume this method is expensive\r\n     * and do not call it repeatedly. This method is intended for decoding 2D barcodes and may or\r\n     * may not apply sharpening. Therefore, a row from this matrix may not be identical to one\r\n     * fetched using getBlackRow(), so don't mix and match between them.\r\n     *\r\n     * @return The 2D array of bits for the image (true means black).\r\n     * @throws NotFoundException if image can't be binarized to make a matrix\r\n     */\r\n    BinaryBitmap.prototype.getBlackMatrix = function () {\r\n        // The matrix is created on demand the first time it is requested, then cached. There are two\r\n        // reasons for this:\r\n        // 1. This work will never be done if the caller only installs 1D Reader objects, or if a\r\n        //    1D Reader finds a barcode before the 2D Readers run.\r\n        // 2. This work will only be done once even if the caller installs multiple 2D Readers.\r\n        if (this.matrix === null || this.matrix === undefined) {\r\n            this.matrix = this.binarizer.getBlackMatrix();\r\n        }\r\n        return this.matrix;\r\n    };\r\n    /**\r\n     * @return Whether this bitmap can be cropped.\r\n     */\r\n    BinaryBitmap.prototype.isCropSupported = function () {\r\n        return this.binarizer.getLuminanceSource().isCropSupported();\r\n    };\r\n    /**\r\n     * Returns a new object with cropped image data. Implementations may keep a reference to the\r\n     * original data rather than a copy. Only callable if isCropSupported() is true.\r\n     *\r\n     * @param left The left coordinate, which must be in [0,getWidth())\r\n     * @param top The top coordinate, which must be in [0,getHeight())\r\n     * @param width The width of the rectangle to crop.\r\n     * @param height The height of the rectangle to crop.\r\n     * @return A cropped version of this object.\r\n     */\r\n    BinaryBitmap.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\r\n        var newSource = this.binarizer.getLuminanceSource().crop(left, top, width, height);\r\n        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\r\n    };\r\n    /**\r\n     * @return Whether this bitmap supports counter-clockwise rotation.\r\n     */\r\n    BinaryBitmap.prototype.isRotateSupported = function () {\r\n        return this.binarizer.getLuminanceSource().isRotateSupported();\r\n    };\r\n    /**\r\n     * Returns a new object with rotated image data by 90 degrees counterclockwise.\r\n     * Only callable if {@link #isRotateSupported()} is true.\r\n     *\r\n     * @return A rotated version of this object.\r\n     */\r\n    BinaryBitmap.prototype.rotateCounterClockwise = function () {\r\n        var newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise();\r\n        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\r\n    };\r\n    /**\r\n     * Returns a new object with rotated image data by 45 degrees counterclockwise.\r\n     * Only callable if {@link #isRotateSupported()} is true.\r\n     *\r\n     * @return A rotated version of this object.\r\n     */\r\n    BinaryBitmap.prototype.rotateCounterClockwise45 = function () {\r\n        var newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise45();\r\n        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\r\n    };\r\n    /*@Override*/\r\n    BinaryBitmap.prototype.toString = function () {\r\n        try {\r\n            return this.getBlackMatrix().toString();\r\n        }\r\n        catch (e /*: NotFoundException*/) {\r\n            return '';\r\n        }\r\n    };\r\n    return BinaryBitmap;\r\n}());\r\nexports.default = BinaryBitmap;\r\n//# sourceMappingURL=BinaryBitmap.js.map"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n/*\r\n* Copyright 2012 ZXing authors\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*      http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n*/\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // package com.google.zxing.pdf417.decoder.ec;\n// import com.google.zxing.ChecksumException;\n\nvar ChecksumException_1 = require(\"../../../ChecksumException\");\n\nvar ModulusPoly_1 = require(\"./ModulusPoly\");\n\nvar ModulusGF_1 = require(\"./ModulusGF\");\n/**\r\n * <p>PDF417 error correction implementation.</p>\r\n *\r\n * <p>This <a href=\"http://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction#Example\">example</a>\r\n * is quite useful in understanding the algorithm.</p>\r\n *\r\n * @author Sean Owen\r\n * @see com.google.zxing.common.reedsolomon.ReedSolomonDecoder\r\n */\n\n\nvar ErrorCorrection =\n/** @class */\nfunction () {\n  function ErrorCorrection() {\n    this.field = ModulusGF_1.default.PDF417_GF;\n  }\n  /**\r\n   * @param received received codewords\r\n   * @param numECCodewords number of those codewords used for EC\r\n   * @param erasures location of erasures\r\n   * @return number of errors\r\n   * @throws ChecksumException if errors cannot be corrected, maybe because of too many errors\r\n   */\n\n\n  ErrorCorrection.prototype.decode = function (received, numECCodewords, erasures) {\n    var e_1, _a;\n\n    var poly = new ModulusPoly_1.default(this.field, received);\n    var S = new Int32Array(numECCodewords);\n    var error = false;\n\n    for (var i\n    /*int*/\n    = numECCodewords; i > 0; i--) {\n      var evaluation = poly.evaluateAt(this.field.exp(i));\n      S[numECCodewords - i] = evaluation;\n\n      if (evaluation !== 0) {\n        error = true;\n      }\n    }\n\n    if (!error) {\n      return 0;\n    }\n\n    var knownErrors = this.field.getOne();\n\n    if (erasures != null) {\n      try {\n        for (var erasures_1 = __values(erasures), erasures_1_1 = erasures_1.next(); !erasures_1_1.done; erasures_1_1 = erasures_1.next()) {\n          var erasure = erasures_1_1.value;\n          var b = this.field.exp(received.length - 1 - erasure); // Add (1 - bx) term:\n\n          var term = new ModulusPoly_1.default(this.field, new Int32Array([this.field.subtract(0, b), 1]));\n          knownErrors = knownErrors.multiply(term);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (erasures_1_1 && !erasures_1_1.done && (_a = erasures_1.return)) _a.call(erasures_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    var syndrome = new ModulusPoly_1.default(this.field, S); // syndrome = syndrome.multiply(knownErrors);\n\n    var sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(numECCodewords, 1), syndrome, numECCodewords);\n    var sigma = sigmaOmega[0];\n    var omega = sigmaOmega[1]; // sigma = sigma.multiply(knownErrors);\n\n    var errorLocations = this.findErrorLocations(sigma);\n    var errorMagnitudes = this.findErrorMagnitudes(omega, sigma, errorLocations);\n\n    for (var i\n    /*int*/\n    = 0; i < errorLocations.length; i++) {\n      var position = received.length - 1 - this.field.log(errorLocations[i]);\n\n      if (position < 0) {\n        throw ChecksumException_1.default.getChecksumInstance();\n      }\n\n      received[position] = this.field.subtract(received[position], errorMagnitudes[i]);\n    }\n\n    return errorLocations.length;\n  };\n  /**\r\n   *\r\n   * @param ModulusPoly\r\n   * @param a\r\n   * @param ModulusPoly\r\n   * @param b\r\n   * @param int\r\n   * @param R\r\n   * @throws ChecksumException\r\n   */\n\n\n  ErrorCorrection.prototype.runEuclideanAlgorithm = function (a, b, R) {\n    // Assume a's degree is >= b's\n    if (a.getDegree() < b.getDegree()) {\n      var temp = a;\n      a = b;\n      b = temp;\n    }\n\n    var rLast = a;\n    var r = b;\n    var tLast = this.field.getZero();\n    var t = this.field.getOne(); // Run Euclidean algorithm until r's degree is less than R/2\n\n    while (r.getDegree() >= Math.round(R / 2)) {\n      var rLastLast = rLast;\n      var tLastLast = tLast;\n      rLast = r;\n      tLast = t; // Divide rLastLast by rLast, with quotient in q and remainder in r\n\n      if (rLast.isZero()) {\n        // Oops, Euclidean algorithm already terminated?\n        throw ChecksumException_1.default.getChecksumInstance();\n      }\n\n      r = rLastLast;\n      var q = this.field.getZero();\n      var denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());\n      var dltInverse = this.field.inverse(denominatorLeadingTerm);\n\n      while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {\n        var degreeDiff = r.getDegree() - rLast.getDegree();\n        var scale = this.field.multiply(r.getCoefficient(r.getDegree()), dltInverse);\n        q = q.add(this.field.buildMonomial(degreeDiff, scale));\n        r = r.subtract(rLast.multiplyByMonomial(degreeDiff, scale));\n      }\n\n      t = q.multiply(tLast).subtract(tLastLast).negative();\n    }\n\n    var sigmaTildeAtZero = t.getCoefficient(0);\n\n    if (sigmaTildeAtZero === 0) {\n      throw ChecksumException_1.default.getChecksumInstance();\n    }\n\n    var inverse = this.field.inverse(sigmaTildeAtZero);\n    var sigma = t.multiply(inverse);\n    var omega = r.multiply(inverse);\n    return [sigma, omega];\n  };\n  /**\r\n   *\r\n   * @param errorLocator\r\n   * @throws ChecksumException\r\n   */\n\n\n  ErrorCorrection.prototype.findErrorLocations = function (errorLocator) {\n    // This is a direct application of Chien's search\n    var numErrors = errorLocator.getDegree();\n    var result = new Int32Array(numErrors);\n    var e = 0;\n\n    for (var i\n    /*int*/\n    = 1; i < this.field.getSize() && e < numErrors; i++) {\n      if (errorLocator.evaluateAt(i) === 0) {\n        result[e] = this.field.inverse(i);\n        e++;\n      }\n    }\n\n    if (e !== numErrors) {\n      throw ChecksumException_1.default.getChecksumInstance();\n    }\n\n    return result;\n  };\n\n  ErrorCorrection.prototype.findErrorMagnitudes = function (errorEvaluator, errorLocator, errorLocations) {\n    var errorLocatorDegree = errorLocator.getDegree();\n    var formalDerivativeCoefficients = new Int32Array(errorLocatorDegree);\n\n    for (var i\n    /*int*/\n    = 1; i <= errorLocatorDegree; i++) {\n      formalDerivativeCoefficients[errorLocatorDegree - i] = this.field.multiply(i, errorLocator.getCoefficient(i));\n    }\n\n    var formalDerivative = new ModulusPoly_1.default(this.field, formalDerivativeCoefficients); // This is directly applying Forney's Formula\n\n    var s = errorLocations.length;\n    var result = new Int32Array(s);\n\n    for (var i\n    /*int*/\n    = 0; i < s; i++) {\n      var xiInverse = this.field.inverse(errorLocations[i]);\n      var numerator = this.field.subtract(0, errorEvaluator.evaluateAt(xiInverse));\n      var denominator = this.field.inverse(formalDerivative.evaluateAt(xiInverse));\n      result[i] = this.field.multiply(numerator, denominator);\n    }\n\n    return result;\n  };\n\n  return ErrorCorrection;\n}();\n\nexports.default = ErrorCorrection;","map":{"version":3,"sources":["../../../../../src/core/pdf417/decoder/ec/ErrorCorrection.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/*\r\n* Copyright 2012 ZXing authors\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*      http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n*/\r\nvar __values = (this && this.__values) || function (o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// package com.google.zxing.pdf417.decoder.ec;\r\n// import com.google.zxing.ChecksumException;\r\nvar ChecksumException_1 = require(\"../../../ChecksumException\");\r\nvar ModulusPoly_1 = require(\"./ModulusPoly\");\r\nvar ModulusGF_1 = require(\"./ModulusGF\");\r\n/**\r\n * <p>PDF417 error correction implementation.</p>\r\n *\r\n * <p>This <a href=\"http://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction#Example\">example</a>\r\n * is quite useful in understanding the algorithm.</p>\r\n *\r\n * @author Sean Owen\r\n * @see com.google.zxing.common.reedsolomon.ReedSolomonDecoder\r\n */\r\nvar ErrorCorrection = /** @class */ (function () {\r\n    function ErrorCorrection() {\r\n        this.field = ModulusGF_1.default.PDF417_GF;\r\n    }\r\n    /**\r\n     * @param received received codewords\r\n     * @param numECCodewords number of those codewords used for EC\r\n     * @param erasures location of erasures\r\n     * @return number of errors\r\n     * @throws ChecksumException if errors cannot be corrected, maybe because of too many errors\r\n     */\r\n    ErrorCorrection.prototype.decode = function (received, numECCodewords, erasures) {\r\n        var e_1, _a;\r\n        var poly = new ModulusPoly_1.default(this.field, received);\r\n        var S = new Int32Array(numECCodewords);\r\n        var error = false;\r\n        for (var i /*int*/ = numECCodewords; i > 0; i--) {\r\n            var evaluation = poly.evaluateAt(this.field.exp(i));\r\n            S[numECCodewords - i] = evaluation;\r\n            if (evaluation !== 0) {\r\n                error = true;\r\n            }\r\n        }\r\n        if (!error) {\r\n            return 0;\r\n        }\r\n        var knownErrors = this.field.getOne();\r\n        if (erasures != null) {\r\n            try {\r\n                for (var erasures_1 = __values(erasures), erasures_1_1 = erasures_1.next(); !erasures_1_1.done; erasures_1_1 = erasures_1.next()) {\r\n                    var erasure = erasures_1_1.value;\r\n                    var b = this.field.exp(received.length - 1 - erasure);\r\n                    // Add (1 - bx) term:\r\n                    var term = new ModulusPoly_1.default(this.field, new Int32Array([this.field.subtract(0, b), 1]));\r\n                    knownErrors = knownErrors.multiply(term);\r\n                }\r\n            }\r\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n            finally {\r\n                try {\r\n                    if (erasures_1_1 && !erasures_1_1.done && (_a = erasures_1.return)) _a.call(erasures_1);\r\n                }\r\n                finally { if (e_1) throw e_1.error; }\r\n            }\r\n        }\r\n        var syndrome = new ModulusPoly_1.default(this.field, S);\r\n        // syndrome = syndrome.multiply(knownErrors);\r\n        var sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(numECCodewords, 1), syndrome, numECCodewords);\r\n        var sigma = sigmaOmega[0];\r\n        var omega = sigmaOmega[1];\r\n        // sigma = sigma.multiply(knownErrors);\r\n        var errorLocations = this.findErrorLocations(sigma);\r\n        var errorMagnitudes = this.findErrorMagnitudes(omega, sigma, errorLocations);\r\n        for (var i /*int*/ = 0; i < errorLocations.length; i++) {\r\n            var position = received.length - 1 - this.field.log(errorLocations[i]);\r\n            if (position < 0) {\r\n                throw ChecksumException_1.default.getChecksumInstance();\r\n            }\r\n            received[position] = this.field.subtract(received[position], errorMagnitudes[i]);\r\n        }\r\n        return errorLocations.length;\r\n    };\r\n    /**\r\n     *\r\n     * @param ModulusPoly\r\n     * @param a\r\n     * @param ModulusPoly\r\n     * @param b\r\n     * @param int\r\n     * @param R\r\n     * @throws ChecksumException\r\n     */\r\n    ErrorCorrection.prototype.runEuclideanAlgorithm = function (a, b, R) {\r\n        // Assume a's degree is >= b's\r\n        if (a.getDegree() < b.getDegree()) {\r\n            var temp = a;\r\n            a = b;\r\n            b = temp;\r\n        }\r\n        var rLast = a;\r\n        var r = b;\r\n        var tLast = this.field.getZero();\r\n        var t = this.field.getOne();\r\n        // Run Euclidean algorithm until r's degree is less than R/2\r\n        while (r.getDegree() >= Math.round(R / 2)) {\r\n            var rLastLast = rLast;\r\n            var tLastLast = tLast;\r\n            rLast = r;\r\n            tLast = t;\r\n            // Divide rLastLast by rLast, with quotient in q and remainder in r\r\n            if (rLast.isZero()) {\r\n                // Oops, Euclidean algorithm already terminated?\r\n                throw ChecksumException_1.default.getChecksumInstance();\r\n            }\r\n            r = rLastLast;\r\n            var q = this.field.getZero();\r\n            var denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());\r\n            var dltInverse = this.field.inverse(denominatorLeadingTerm);\r\n            while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {\r\n                var degreeDiff = r.getDegree() - rLast.getDegree();\r\n                var scale = this.field.multiply(r.getCoefficient(r.getDegree()), dltInverse);\r\n                q = q.add(this.field.buildMonomial(degreeDiff, scale));\r\n                r = r.subtract(rLast.multiplyByMonomial(degreeDiff, scale));\r\n            }\r\n            t = q.multiply(tLast).subtract(tLastLast).negative();\r\n        }\r\n        var sigmaTildeAtZero = t.getCoefficient(0);\r\n        if (sigmaTildeAtZero === 0) {\r\n            throw ChecksumException_1.default.getChecksumInstance();\r\n        }\r\n        var inverse = this.field.inverse(sigmaTildeAtZero);\r\n        var sigma = t.multiply(inverse);\r\n        var omega = r.multiply(inverse);\r\n        return [sigma, omega];\r\n    };\r\n    /**\r\n     *\r\n     * @param errorLocator\r\n     * @throws ChecksumException\r\n     */\r\n    ErrorCorrection.prototype.findErrorLocations = function (errorLocator) {\r\n        // This is a direct application of Chien's search\r\n        var numErrors = errorLocator.getDegree();\r\n        var result = new Int32Array(numErrors);\r\n        var e = 0;\r\n        for (var i /*int*/ = 1; i < this.field.getSize() && e < numErrors; i++) {\r\n            if (errorLocator.evaluateAt(i) === 0) {\r\n                result[e] = this.field.inverse(i);\r\n                e++;\r\n            }\r\n        }\r\n        if (e !== numErrors) {\r\n            throw ChecksumException_1.default.getChecksumInstance();\r\n        }\r\n        return result;\r\n    };\r\n    ErrorCorrection.prototype.findErrorMagnitudes = function (errorEvaluator, errorLocator, errorLocations) {\r\n        var errorLocatorDegree = errorLocator.getDegree();\r\n        var formalDerivativeCoefficients = new Int32Array(errorLocatorDegree);\r\n        for (var i /*int*/ = 1; i <= errorLocatorDegree; i++) {\r\n            formalDerivativeCoefficients[errorLocatorDegree - i] =\r\n                this.field.multiply(i, errorLocator.getCoefficient(i));\r\n        }\r\n        var formalDerivative = new ModulusPoly_1.default(this.field, formalDerivativeCoefficients);\r\n        // This is directly applying Forney's Formula\r\n        var s = errorLocations.length;\r\n        var result = new Int32Array(s);\r\n        for (var i /*int*/ = 0; i < s; i++) {\r\n            var xiInverse = this.field.inverse(errorLocations[i]);\r\n            var numerator = this.field.subtract(0, errorEvaluator.evaluateAt(xiInverse));\r\n            var denominator = this.field.inverse(formalDerivative.evaluateAt(xiInverse));\r\n            result[i] = this.field.multiply(numerator, denominator);\r\n        }\r\n        return result;\r\n    };\r\n    return ErrorCorrection;\r\n}());\r\nexports.default = ErrorCorrection;\r\n//# sourceMappingURL=ErrorCorrection.js.map"]},"metadata":{},"sourceType":"script"}
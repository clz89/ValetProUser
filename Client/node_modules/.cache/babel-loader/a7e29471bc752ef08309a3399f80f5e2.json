{"ast":null,"code":"\"use strict\";\n/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar NotFoundException_1 = require(\"../NotFoundException\");\n/**\r\n * Implementations of this class can, given locations of finder patterns for a QR code in an\r\n * image, sample the right points in the image to reconstruct the QR code, accounting for\r\n * perspective distortion. It is abstracted since it is relatively expensive and should be allowed\r\n * to take advantage of platform-specific optimized implementations, like Sun's Java Advanced\r\n * Imaging library, but which may not be available in other environments such as J2ME, and vice\r\n * versa.\r\n *\r\n * The implementation used can be controlled by calling {@link #setGridSampler(GridSampler)}\r\n * with an instance of a class which implements this interface.\r\n *\r\n * @author Sean Owen\r\n */\n\n\nvar GridSampler =\n/** @class */\nfunction () {\n  function GridSampler() {}\n  /**\r\n   * <p>Checks a set of points that have been transformed to sample points on an image against\r\n   * the image's dimensions to see if the point are even within the image.</p>\r\n   *\r\n   * <p>This method will actually \"nudge\" the endpoints back onto the image if they are found to be\r\n   * barely (less than 1 pixel) off the image. This accounts for imperfect detection of finder\r\n   * patterns in an image where the QR Code runs all the way to the image border.</p>\r\n   *\r\n   * <p>For efficiency, the method will check points from either end of the line until one is found\r\n   * to be within the image. Because the set of points are assumed to be linear, this is valid.</p>\r\n   *\r\n   * @param image image into which the points should map\r\n   * @param points actual points in x1,y1,...,xn,yn form\r\n   * @throws NotFoundException if an endpoint is lies outside the image boundaries\r\n   */\n\n\n  GridSampler.checkAndNudgePoints = function (image, points) {\n    var width = image.getWidth();\n    var height = image.getHeight(); // Check and nudge points from start until we see some that are OK:\n\n    var nudged = true;\n\n    for (var offset = 0; offset < points.length && nudged; offset += 2) {\n      var x = Math.floor(points[offset]);\n      var y = Math.floor(points[offset + 1]);\n\n      if (x < -1 || x > width || y < -1 || y > height) {\n        throw new NotFoundException_1.default();\n      }\n\n      nudged = false;\n\n      if (x === -1) {\n        points[offset] = 0.0;\n        nudged = true;\n      } else if (x === width) {\n        points[offset] = width - 1;\n        nudged = true;\n      }\n\n      if (y === -1) {\n        points[offset + 1] = 0.0;\n        nudged = true;\n      } else if (y === height) {\n        points[offset + 1] = height - 1;\n        nudged = true;\n      }\n    } // Check and nudge points from end:\n\n\n    nudged = true;\n\n    for (var offset = points.length - 2; offset >= 0 && nudged; offset -= 2) {\n      var x = Math.floor(points[offset]);\n      var y = Math.floor(points[offset + 1]);\n\n      if (x < -1 || x > width || y < -1 || y > height) {\n        throw new NotFoundException_1.default();\n      }\n\n      nudged = false;\n\n      if (x === -1) {\n        points[offset] = 0.0;\n        nudged = true;\n      } else if (x === width) {\n        points[offset] = width - 1;\n        nudged = true;\n      }\n\n      if (y === -1) {\n        points[offset + 1] = 0.0;\n        nudged = true;\n      } else if (y === height) {\n        points[offset + 1] = height - 1;\n        nudged = true;\n      }\n    }\n  };\n\n  return GridSampler;\n}();\n\nexports.default = GridSampler;","map":{"version":3,"sources":["../../../src/core/common/GridSampler.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar NotFoundException_1 = require(\"../NotFoundException\");\r\n/**\r\n * Implementations of this class can, given locations of finder patterns for a QR code in an\r\n * image, sample the right points in the image to reconstruct the QR code, accounting for\r\n * perspective distortion. It is abstracted since it is relatively expensive and should be allowed\r\n * to take advantage of platform-specific optimized implementations, like Sun's Java Advanced\r\n * Imaging library, but which may not be available in other environments such as J2ME, and vice\r\n * versa.\r\n *\r\n * The implementation used can be controlled by calling {@link #setGridSampler(GridSampler)}\r\n * with an instance of a class which implements this interface.\r\n *\r\n * @author Sean Owen\r\n */\r\nvar GridSampler = /** @class */ (function () {\r\n    function GridSampler() {\r\n    }\r\n    /**\r\n     * <p>Checks a set of points that have been transformed to sample points on an image against\r\n     * the image's dimensions to see if the point are even within the image.</p>\r\n     *\r\n     * <p>This method will actually \"nudge\" the endpoints back onto the image if they are found to be\r\n     * barely (less than 1 pixel) off the image. This accounts for imperfect detection of finder\r\n     * patterns in an image where the QR Code runs all the way to the image border.</p>\r\n     *\r\n     * <p>For efficiency, the method will check points from either end of the line until one is found\r\n     * to be within the image. Because the set of points are assumed to be linear, this is valid.</p>\r\n     *\r\n     * @param image image into which the points should map\r\n     * @param points actual points in x1,y1,...,xn,yn form\r\n     * @throws NotFoundException if an endpoint is lies outside the image boundaries\r\n     */\r\n    GridSampler.checkAndNudgePoints = function (image, points) {\r\n        var width = image.getWidth();\r\n        var height = image.getHeight();\r\n        // Check and nudge points from start until we see some that are OK:\r\n        var nudged = true;\r\n        for (var offset = 0; offset < points.length && nudged; offset += 2) {\r\n            var x = Math.floor(points[offset]);\r\n            var y = Math.floor(points[offset + 1]);\r\n            if (x < -1 || x > width || y < -1 || y > height) {\r\n                throw new NotFoundException_1.default();\r\n            }\r\n            nudged = false;\r\n            if (x === -1) {\r\n                points[offset] = 0.0;\r\n                nudged = true;\r\n            }\r\n            else if (x === width) {\r\n                points[offset] = width - 1;\r\n                nudged = true;\r\n            }\r\n            if (y === -1) {\r\n                points[offset + 1] = 0.0;\r\n                nudged = true;\r\n            }\r\n            else if (y === height) {\r\n                points[offset + 1] = height - 1;\r\n                nudged = true;\r\n            }\r\n        }\r\n        // Check and nudge points from end:\r\n        nudged = true;\r\n        for (var offset = points.length - 2; offset >= 0 && nudged; offset -= 2) {\r\n            var x = Math.floor(points[offset]);\r\n            var y = Math.floor(points[offset + 1]);\r\n            if (x < -1 || x > width || y < -1 || y > height) {\r\n                throw new NotFoundException_1.default();\r\n            }\r\n            nudged = false;\r\n            if (x === -1) {\r\n                points[offset] = 0.0;\r\n                nudged = true;\r\n            }\r\n            else if (x === width) {\r\n                points[offset] = width - 1;\r\n                nudged = true;\r\n            }\r\n            if (y === -1) {\r\n                points[offset + 1] = 0.0;\r\n                nudged = true;\r\n            }\r\n            else if (y === height) {\r\n                points[offset + 1] = height - 1;\r\n                nudged = true;\r\n            }\r\n        }\r\n    };\r\n    return GridSampler;\r\n}());\r\nexports.default = GridSampler;\r\n//# sourceMappingURL=GridSampler.js.map"]},"metadata":{},"sourceType":"script"}
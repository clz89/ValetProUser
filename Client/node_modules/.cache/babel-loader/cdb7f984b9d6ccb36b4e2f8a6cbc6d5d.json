{"ast":null,"code":"\"use strict\";\n/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar IllegalArgumentException_1 = require(\"../../IllegalArgumentException\");\n\nvar ModeValues;\n\n(function (ModeValues) {\n  ModeValues[ModeValues[\"TERMINATOR\"] = 0] = \"TERMINATOR\";\n  ModeValues[ModeValues[\"NUMERIC\"] = 1] = \"NUMERIC\";\n  ModeValues[ModeValues[\"ALPHANUMERIC\"] = 2] = \"ALPHANUMERIC\";\n  ModeValues[ModeValues[\"STRUCTURED_APPEND\"] = 3] = \"STRUCTURED_APPEND\";\n  ModeValues[ModeValues[\"BYTE\"] = 4] = \"BYTE\";\n  ModeValues[ModeValues[\"ECI\"] = 5] = \"ECI\";\n  ModeValues[ModeValues[\"KANJI\"] = 6] = \"KANJI\";\n  ModeValues[ModeValues[\"FNC1_FIRST_POSITION\"] = 7] = \"FNC1_FIRST_POSITION\";\n  ModeValues[ModeValues[\"FNC1_SECOND_POSITION\"] = 8] = \"FNC1_SECOND_POSITION\";\n  /** See GBT 18284-2000; \"Hanzi\" is a transliteration of this mode name. */\n\n  ModeValues[ModeValues[\"HANZI\"] = 9] = \"HANZI\";\n})(ModeValues = exports.ModeValues || (exports.ModeValues = {}));\n/**\r\n * <p>See ISO 18004:2006, 6.4.1, Tables 2 and 3. This enum encapsulates the various modes in which\r\n * data can be encoded to bits in the QR code standard.</p>\r\n *\r\n * @author Sean Owen\r\n */\n\n\nvar Mode =\n/** @class */\nfunction () {\n  function Mode(value, stringValue, characterCountBitsForVersions, bits\n  /*int*/\n  ) {\n    this.value = value;\n    this.stringValue = stringValue;\n    this.characterCountBitsForVersions = characterCountBitsForVersions;\n    this.bits = bits;\n    Mode.FOR_BITS.set(bits, this);\n    Mode.FOR_VALUE.set(value, this);\n  }\n  /**\r\n   * @param bits four bits encoding a QR Code data mode\r\n   * @return Mode encoded by these bits\r\n   * @throws IllegalArgumentException if bits do not correspond to a known mode\r\n   */\n\n\n  Mode.forBits = function (bits\n  /*int*/\n  ) {\n    var mode = Mode.FOR_BITS.get(bits);\n\n    if (undefined === mode) {\n      throw new IllegalArgumentException_1.default();\n    }\n\n    return mode;\n  };\n  /**\r\n   * @param version version in question\r\n   * @return number of bits used, in this QR Code symbol {@link Version}, to encode the\r\n   *         count of characters that will follow encoded in this Mode\r\n   */\n\n\n  Mode.prototype.getCharacterCountBits = function (version) {\n    var versionNumber = version.getVersionNumber();\n    var offset;\n\n    if (versionNumber <= 9) {\n      offset = 0;\n    } else if (versionNumber <= 26) {\n      offset = 1;\n    } else {\n      offset = 2;\n    }\n\n    return this.characterCountBitsForVersions[offset];\n  };\n\n  Mode.prototype.getValue = function () {\n    return this.value;\n  };\n\n  Mode.prototype.getBits = function () {\n    return this.bits;\n  };\n\n  Mode.prototype.equals = function (o) {\n    if (!(o instanceof Mode)) {\n      return false;\n    }\n\n    var other = o;\n    return this.value === other.value;\n  };\n\n  Mode.prototype.toString = function () {\n    return this.stringValue;\n  };\n\n  Mode.FOR_BITS = new Map();\n  Mode.FOR_VALUE = new Map();\n  Mode.TERMINATOR = new Mode(ModeValues.TERMINATOR, 'TERMINATOR', Int32Array.from([0, 0, 0]), 0x00); // Not really a mode...\n\n  Mode.NUMERIC = new Mode(ModeValues.NUMERIC, 'NUMERIC', Int32Array.from([10, 12, 14]), 0x01);\n  Mode.ALPHANUMERIC = new Mode(ModeValues.ALPHANUMERIC, 'ALPHANUMERIC', Int32Array.from([9, 11, 13]), 0x02);\n  Mode.STRUCTURED_APPEND = new Mode(ModeValues.STRUCTURED_APPEND, 'STRUCTURED_APPEND', Int32Array.from([0, 0, 0]), 0x03); // Not supported\n\n  Mode.BYTE = new Mode(ModeValues.BYTE, 'BYTE', Int32Array.from([8, 16, 16]), 0x04);\n  Mode.ECI = new Mode(ModeValues.ECI, 'ECI', Int32Array.from([0, 0, 0]), 0x07); // character counts don't apply\n\n  Mode.KANJI = new Mode(ModeValues.KANJI, 'KANJI', Int32Array.from([8, 10, 12]), 0x08);\n  Mode.FNC1_FIRST_POSITION = new Mode(ModeValues.FNC1_FIRST_POSITION, 'FNC1_FIRST_POSITION', Int32Array.from([0, 0, 0]), 0x05);\n  Mode.FNC1_SECOND_POSITION = new Mode(ModeValues.FNC1_SECOND_POSITION, 'FNC1_SECOND_POSITION', Int32Array.from([0, 0, 0]), 0x09);\n  /** See GBT 18284-2000; \"Hanzi\" is a transliteration of this mode name. */\n\n  Mode.HANZI = new Mode(ModeValues.HANZI, 'HANZI', Int32Array.from([8, 10, 12]), 0x0D);\n  return Mode;\n}();\n\nexports.default = Mode;","map":{"version":3,"sources":["../../../../src/core/qrcode/decoder/Mode.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar IllegalArgumentException_1 = require(\"../../IllegalArgumentException\");\r\nvar ModeValues;\r\n(function (ModeValues) {\r\n    ModeValues[ModeValues[\"TERMINATOR\"] = 0] = \"TERMINATOR\";\r\n    ModeValues[ModeValues[\"NUMERIC\"] = 1] = \"NUMERIC\";\r\n    ModeValues[ModeValues[\"ALPHANUMERIC\"] = 2] = \"ALPHANUMERIC\";\r\n    ModeValues[ModeValues[\"STRUCTURED_APPEND\"] = 3] = \"STRUCTURED_APPEND\";\r\n    ModeValues[ModeValues[\"BYTE\"] = 4] = \"BYTE\";\r\n    ModeValues[ModeValues[\"ECI\"] = 5] = \"ECI\";\r\n    ModeValues[ModeValues[\"KANJI\"] = 6] = \"KANJI\";\r\n    ModeValues[ModeValues[\"FNC1_FIRST_POSITION\"] = 7] = \"FNC1_FIRST_POSITION\";\r\n    ModeValues[ModeValues[\"FNC1_SECOND_POSITION\"] = 8] = \"FNC1_SECOND_POSITION\";\r\n    /** See GBT 18284-2000; \"Hanzi\" is a transliteration of this mode name. */\r\n    ModeValues[ModeValues[\"HANZI\"] = 9] = \"HANZI\";\r\n})(ModeValues = exports.ModeValues || (exports.ModeValues = {}));\r\n/**\r\n * <p>See ISO 18004:2006, 6.4.1, Tables 2 and 3. This enum encapsulates the various modes in which\r\n * data can be encoded to bits in the QR code standard.</p>\r\n *\r\n * @author Sean Owen\r\n */\r\nvar Mode = /** @class */ (function () {\r\n    function Mode(value, stringValue, characterCountBitsForVersions, bits /*int*/) {\r\n        this.value = value;\r\n        this.stringValue = stringValue;\r\n        this.characterCountBitsForVersions = characterCountBitsForVersions;\r\n        this.bits = bits;\r\n        Mode.FOR_BITS.set(bits, this);\r\n        Mode.FOR_VALUE.set(value, this);\r\n    }\r\n    /**\r\n     * @param bits four bits encoding a QR Code data mode\r\n     * @return Mode encoded by these bits\r\n     * @throws IllegalArgumentException if bits do not correspond to a known mode\r\n     */\r\n    Mode.forBits = function (bits /*int*/) {\r\n        var mode = Mode.FOR_BITS.get(bits);\r\n        if (undefined === mode) {\r\n            throw new IllegalArgumentException_1.default();\r\n        }\r\n        return mode;\r\n    };\r\n    /**\r\n     * @param version version in question\r\n     * @return number of bits used, in this QR Code symbol {@link Version}, to encode the\r\n     *         count of characters that will follow encoded in this Mode\r\n     */\r\n    Mode.prototype.getCharacterCountBits = function (version) {\r\n        var versionNumber = version.getVersionNumber();\r\n        var offset;\r\n        if (versionNumber <= 9) {\r\n            offset = 0;\r\n        }\r\n        else if (versionNumber <= 26) {\r\n            offset = 1;\r\n        }\r\n        else {\r\n            offset = 2;\r\n        }\r\n        return this.characterCountBitsForVersions[offset];\r\n    };\r\n    Mode.prototype.getValue = function () {\r\n        return this.value;\r\n    };\r\n    Mode.prototype.getBits = function () {\r\n        return this.bits;\r\n    };\r\n    Mode.prototype.equals = function (o) {\r\n        if (!(o instanceof Mode)) {\r\n            return false;\r\n        }\r\n        var other = o;\r\n        return this.value === other.value;\r\n    };\r\n    Mode.prototype.toString = function () {\r\n        return this.stringValue;\r\n    };\r\n    Mode.FOR_BITS = new Map();\r\n    Mode.FOR_VALUE = new Map();\r\n    Mode.TERMINATOR = new Mode(ModeValues.TERMINATOR, 'TERMINATOR', Int32Array.from([0, 0, 0]), 0x00); // Not really a mode...\r\n    Mode.NUMERIC = new Mode(ModeValues.NUMERIC, 'NUMERIC', Int32Array.from([10, 12, 14]), 0x01);\r\n    Mode.ALPHANUMERIC = new Mode(ModeValues.ALPHANUMERIC, 'ALPHANUMERIC', Int32Array.from([9, 11, 13]), 0x02);\r\n    Mode.STRUCTURED_APPEND = new Mode(ModeValues.STRUCTURED_APPEND, 'STRUCTURED_APPEND', Int32Array.from([0, 0, 0]), 0x03); // Not supported\r\n    Mode.BYTE = new Mode(ModeValues.BYTE, 'BYTE', Int32Array.from([8, 16, 16]), 0x04);\r\n    Mode.ECI = new Mode(ModeValues.ECI, 'ECI', Int32Array.from([0, 0, 0]), 0x07); // character counts don't apply\r\n    Mode.KANJI = new Mode(ModeValues.KANJI, 'KANJI', Int32Array.from([8, 10, 12]), 0x08);\r\n    Mode.FNC1_FIRST_POSITION = new Mode(ModeValues.FNC1_FIRST_POSITION, 'FNC1_FIRST_POSITION', Int32Array.from([0, 0, 0]), 0x05);\r\n    Mode.FNC1_SECOND_POSITION = new Mode(ModeValues.FNC1_SECOND_POSITION, 'FNC1_SECOND_POSITION', Int32Array.from([0, 0, 0]), 0x09);\r\n    /** See GBT 18284-2000; \"Hanzi\" is a transliteration of this mode name. */\r\n    Mode.HANZI = new Mode(ModeValues.HANZI, 'HANZI', Int32Array.from([8, 10, 12]), 0x0D);\r\n    return Mode;\r\n}());\r\nexports.default = Mode;\r\n//# sourceMappingURL=Mode.js.map"]},"metadata":{},"sourceType":"script"}
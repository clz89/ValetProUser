{"ast":null,"code":"\"use strict\";\n/*\r\n * Copyright 2010 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ResultPoint_1 = require(\"../../ResultPoint\");\n\nvar AztecDetectorResult_1 = require(\"../AztecDetectorResult\");\n\nvar MathUtils_1 = require(\"../../common/detector/MathUtils\");\n\nvar WhiteRectangleDetector_1 = require(\"../../common/detector/WhiteRectangleDetector\");\n\nvar GenericGF_1 = require(\"../../common/reedsolomon/GenericGF\");\n\nvar ReedSolomonDecoder_1 = require(\"../../common/reedsolomon/ReedSolomonDecoder\");\n\nvar NotFoundException_1 = require(\"../../NotFoundException\");\n\nvar GridSamplerInstance_1 = require(\"../../common/GridSamplerInstance\");\n\nvar Integer_1 = require(\"../../util/Integer\");\n\nvar Point =\n/** @class */\nfunction () {\n  function Point(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  Point.prototype.toResultPoint = function () {\n    return new ResultPoint_1.default(this.getX(), this.getY());\n  };\n\n  Point.prototype.getX = function () {\n    return this.x;\n  };\n\n  Point.prototype.getY = function () {\n    return this.y;\n  };\n\n  return Point;\n}();\n\nexports.Point = Point;\n/**\r\n * Encapsulates logic that can detect an Aztec Code in an image, even if the Aztec Code\r\n * is rotated or skewed, or partially obscured.\r\n *\r\n * @author David Olivier\r\n * @author Frank Yellin\r\n */\n\nvar Detector =\n/** @class */\nfunction () {\n  function Detector(image) {\n    this.EXPECTED_CORNER_BITS = new Int32Array([0xee0, 0x1dc, 0x83b, 0x707]);\n    this.image = image;\n  }\n\n  Detector.prototype.detect = function () {\n    return this.detectMirror(false);\n  };\n  /**\r\n   * Detects an Aztec Code in an image.\r\n   *\r\n   * @param isMirror if true, image is a mirror-image of original\r\n   * @return {@link AztecDetectorResult} encapsulating results of detecting an Aztec Code\r\n   * @throws NotFoundException if no Aztec Code can be found\r\n   */\n\n\n  Detector.prototype.detectMirror = function (isMirror) {\n    // 1. Get the center of the aztec matrix\n    var pCenter = this.getMatrixCenter(); // 2. Get the center points of the four diagonal points just outside the bull's eye\n    //  [topRight, bottomRight, bottomLeft, topLeft]\n\n    var bullsEyeCorners = this.getBullsEyeCorners(pCenter);\n\n    if (isMirror) {\n      var temp = bullsEyeCorners[0];\n      bullsEyeCorners[0] = bullsEyeCorners[2];\n      bullsEyeCorners[2] = temp;\n    } // 3. Get the size of the matrix and other parameters from the bull's eye\n\n\n    this.extractParameters(bullsEyeCorners); // 4. Sample the grid\n\n    var bits = this.sampleGrid(this.image, bullsEyeCorners[this.shift % 4], bullsEyeCorners[(this.shift + 1) % 4], bullsEyeCorners[(this.shift + 2) % 4], bullsEyeCorners[(this.shift + 3) % 4]); // 5. Get the corners of the matrix.\n\n    var corners = this.getMatrixCornerPoints(bullsEyeCorners);\n    return new AztecDetectorResult_1.default(bits, corners, this.compact, this.nbDataBlocks, this.nbLayers);\n  };\n  /**\r\n   * Extracts the number of data layers and data blocks from the layer around the bull's eye.\r\n   *\r\n   * @param bullsEyeCorners the array of bull's eye corners\r\n   * @throws NotFoundException in case of too many errors or invalid parameters\r\n   */\n\n\n  Detector.prototype.extractParameters = function (bullsEyeCorners) {\n    if (!this.isValidPoint(bullsEyeCorners[0]) || !this.isValidPoint(bullsEyeCorners[1]) || !this.isValidPoint(bullsEyeCorners[2]) || !this.isValidPoint(bullsEyeCorners[3])) {\n      throw new NotFoundException_1.default();\n    }\n\n    var length = 2 * this.nbCenterLayers; // Get the bits around the bull's eye\n\n    var sides = new Int32Array([this.sampleLine(bullsEyeCorners[0], bullsEyeCorners[1], length), this.sampleLine(bullsEyeCorners[1], bullsEyeCorners[2], length), this.sampleLine(bullsEyeCorners[2], bullsEyeCorners[3], length), this.sampleLine(bullsEyeCorners[3], bullsEyeCorners[0], length) // Top\n    ]); // bullsEyeCorners[shift] is the corner of the bulls'eye that has three\n    // orientation marks.\n    // sides[shift] is the row/column that goes from the corner with three\n    // orientation marks to the corner with two.\n\n    this.shift = this.getRotation(sides, length); // Flatten the parameter bits into a single 28- or 40-bit long\n\n    var parameterData = 0;\n\n    for (var i = 0; i < 4; i++) {\n      var side = sides[(this.shift + i) % 4];\n\n      if (this.compact) {\n        // Each side of the form ..XXXXXXX. where Xs are parameter data\n        parameterData <<= 7;\n        parameterData += side >> 1 & 0x7F;\n      } else {\n        // Each side of the form ..XXXXX.XXXXX. where Xs are parameter data\n        parameterData <<= 10;\n        parameterData += (side >> 2 & 0x1f << 5) + (side >> 1 & 0x1F);\n      }\n    } // Corrects parameter data using RS.  Returns just the data portion\n    // without the error correction.\n\n\n    var correctedData = this.getCorrectedParameterData(parameterData, this.compact);\n\n    if (this.compact) {\n      // 8 bits:  2 bits layers and 6 bits data blocks\n      this.nbLayers = (correctedData >> 6) + 1;\n      this.nbDataBlocks = (correctedData & 0x3F) + 1;\n    } else {\n      // 16 bits:  5 bits layers and 11 bits data blocks\n      this.nbLayers = (correctedData >> 11) + 1;\n      this.nbDataBlocks = (correctedData & 0x7FF) + 1;\n    }\n  };\n\n  Detector.prototype.getRotation = function (sides, length) {\n    // In a normal pattern, we expect to See\n    //   **    .*             D       A\n    //   *      *\n    //\n    //   .      *\n    //   ..    ..             C       B\n    //\n    // Grab the 3 bits from each of the sides the form the locator pattern and concatenate\n    // into a 12-bit integer.  Start with the bit at A\n    var cornerBits = 0;\n    sides.forEach(function (side, idx, arr) {\n      // XX......X where X's are orientation marks\n      var t = (side >> length - 2 << 1) + (side & 1);\n      cornerBits = (cornerBits << 3) + t;\n    }); // for (var side in sides) {\n    //     // XX......X where X's are orientation marks\n    //     var t = ((side >> (length - 2)) << 1) + (side & 1);\n    //     cornerBits = (cornerBits << 3) + t;\n    // }\n    // Mov the bottom bit to the top, so that the three bits of the locator pattern at A are\n    // together.  cornerBits is now:\n    //  3 orientation bits at A || 3 orientation bits at B || ... || 3 orientation bits at D\n\n    cornerBits = ((cornerBits & 1) << 11) + (cornerBits >> 1); // The result shift indicates which element of BullsEyeCorners[] goes into the top-left\n    // corner. Since the four rotation values have a Hamming distance of 8, we\n    // can easily tolerate two errors.\n\n    for (var shift = 0; shift < 4; shift++) {\n      if (Integer_1.default.bitCount(cornerBits ^ this.EXPECTED_CORNER_BITS[shift]) <= 2) {\n        return shift;\n      }\n    }\n\n    throw new NotFoundException_1.default();\n  };\n  /**\r\n   * Corrects the parameter bits using Reed-Solomon algorithm.\r\n   *\r\n   * @param parameterData parameter bits\r\n   * @param compact true if this is a compact Aztec code\r\n   * @throws NotFoundException if the array contains too many errors\r\n   */\n\n\n  Detector.prototype.getCorrectedParameterData = function (parameterData, compact) {\n    var numCodewords;\n    var numDataCodewords;\n\n    if (compact) {\n      numCodewords = 7;\n      numDataCodewords = 2;\n    } else {\n      numCodewords = 10;\n      numDataCodewords = 4;\n    }\n\n    var numECCodewords = numCodewords - numDataCodewords;\n    var parameterWords = new Int32Array(numCodewords);\n\n    for (var i = numCodewords - 1; i >= 0; --i) {\n      parameterWords[i] = parameterData & 0xF;\n      parameterData >>= 4;\n    }\n\n    try {\n      var rsDecoder = new ReedSolomonDecoder_1.default(GenericGF_1.default.AZTEC_PARAM);\n      rsDecoder.decode(parameterWords, numECCodewords);\n    } catch (ignored) {\n      throw new NotFoundException_1.default();\n    } // Toss the error correction.  Just return the data as an integer\n\n\n    var result = 0;\n\n    for (var i = 0; i < numDataCodewords; i++) {\n      result = (result << 4) + parameterWords[i];\n    }\n\n    return result;\n  };\n  /**\r\n   * Finds the corners of a bull-eye centered on the passed point.\r\n   * This returns the centers of the diagonal points just outside the bull's eye\r\n   * Returns [topRight, bottomRight, bottomLeft, topLeft]\r\n   *\r\n   * @param pCenter Center point\r\n   * @return The corners of the bull-eye\r\n   * @throws NotFoundException If no valid bull-eye can be found\r\n   */\n\n\n  Detector.prototype.getBullsEyeCorners = function (pCenter) {\n    var pina = pCenter;\n    var pinb = pCenter;\n    var pinc = pCenter;\n    var pind = pCenter;\n    var color = true;\n\n    for (this.nbCenterLayers = 1; this.nbCenterLayers < 9; this.nbCenterLayers++) {\n      var pouta = this.getFirstDifferent(pina, color, 1, -1);\n      var poutb = this.getFirstDifferent(pinb, color, 1, 1);\n      var poutc = this.getFirstDifferent(pinc, color, -1, 1);\n      var poutd = this.getFirstDifferent(pind, color, -1, -1); // d      a\n      //\n      // c      b\n\n      if (this.nbCenterLayers > 2) {\n        var q = this.distancePoint(poutd, pouta) * this.nbCenterLayers / (this.distancePoint(pind, pina) * (this.nbCenterLayers + 2));\n\n        if (q < 0.75 || q > 1.25 || !this.isWhiteOrBlackRectangle(pouta, poutb, poutc, poutd)) {\n          break;\n        }\n      }\n\n      pina = pouta;\n      pinb = poutb;\n      pinc = poutc;\n      pind = poutd;\n      color = !color;\n    }\n\n    if (this.nbCenterLayers !== 5 && this.nbCenterLayers !== 7) {\n      throw new NotFoundException_1.default();\n    }\n\n    this.compact = this.nbCenterLayers === 5; // Expand the square by .5 pixel in each direction so that we're on the border\n    // between the white square and the black square\n\n    var pinax = new ResultPoint_1.default(pina.getX() + 0.5, pina.getY() - 0.5);\n    var pinbx = new ResultPoint_1.default(pinb.getX() + 0.5, pinb.getY() + 0.5);\n    var pincx = new ResultPoint_1.default(pinc.getX() - 0.5, pinc.getY() + 0.5);\n    var pindx = new ResultPoint_1.default(pind.getX() - 0.5, pind.getY() - 0.5); // Expand the square so that its corners are the centers of the points\n    // just outside the bull's eye.\n\n    return this.expandSquare([pinax, pinbx, pincx, pindx], 2 * this.nbCenterLayers - 3, 2 * this.nbCenterLayers);\n  };\n  /**\r\n   * Finds a candidate center point of an Aztec code from an image\r\n   *\r\n   * @return the center point\r\n   */\n\n\n  Detector.prototype.getMatrixCenter = function () {\n    var pointA;\n    var pointB;\n    var pointC;\n    var pointD; // Get a white rectangle that can be the border of the matrix in center bull's eye or\n\n    try {\n      var cornerPoints = new WhiteRectangleDetector_1.default(this.image).detect();\n      pointA = cornerPoints[0];\n      pointB = cornerPoints[1];\n      pointC = cornerPoints[2];\n      pointD = cornerPoints[3];\n    } catch (e) {\n      // This exception can be in case the initial rectangle is white\n      // In that case, surely in the bull's eye, we try to expand the rectangle.\n      var cx_1 = this.image.getWidth() / 2;\n      var cy_1 = this.image.getHeight() / 2;\n      pointA = this.getFirstDifferent(new Point(cx_1 + 7, cy_1 - 7), false, 1, -1).toResultPoint();\n      pointB = this.getFirstDifferent(new Point(cx_1 + 7, cy_1 + 7), false, 1, 1).toResultPoint();\n      pointC = this.getFirstDifferent(new Point(cx_1 - 7, cy_1 + 7), false, -1, 1).toResultPoint();\n      pointD = this.getFirstDifferent(new Point(cx_1 - 7, cy_1 - 7), false, -1, -1).toResultPoint();\n    } // Compute the center of the rectangle\n\n\n    var cx = MathUtils_1.default.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);\n    var cy = MathUtils_1.default.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0); // Redetermine the white rectangle starting from previously computed center.\n    // This will ensure that we end up with a white rectangle in center bull's eye\n    // in order to compute a more accurate center.\n\n    try {\n      var cornerPoints = new WhiteRectangleDetector_1.default(this.image, 15, cx, cy).detect();\n      pointA = cornerPoints[0];\n      pointB = cornerPoints[1];\n      pointC = cornerPoints[2];\n      pointD = cornerPoints[3];\n    } catch (e) {\n      // This exception can be in case the initial rectangle is white\n      // In that case we try to expand the rectangle.\n      pointA = this.getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();\n      pointB = this.getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();\n      pointC = this.getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();\n      pointD = this.getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();\n    } // Recompute the center of the rectangle\n\n\n    cx = MathUtils_1.default.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);\n    cy = MathUtils_1.default.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0);\n    return new Point(cx, cy);\n  };\n  /**\r\n   * Gets the Aztec code corners from the bull's eye corners and the parameters.\r\n   *\r\n   * @param bullsEyeCorners the array of bull's eye corners\r\n   * @return the array of aztec code corners\r\n   */\n\n\n  Detector.prototype.getMatrixCornerPoints = function (bullsEyeCorners) {\n    return this.expandSquare(bullsEyeCorners, 2 * this.nbCenterLayers, this.getDimension());\n  };\n  /**\r\n   * Creates a BitMatrix by sampling the provided image.\r\n   * topLeft, topRight, bottomRight, and bottomLeft are the centers of the squares on the\r\n   * diagonal just outside the bull's eye.\r\n   */\n\n\n  Detector.prototype.sampleGrid = function (image, topLeft, topRight, bottomRight, bottomLeft) {\n    var sampler = GridSamplerInstance_1.default.getInstance();\n    var dimension = this.getDimension();\n    var low = dimension / 2 - this.nbCenterLayers;\n    var high = dimension / 2 + this.nbCenterLayers;\n    return sampler.sampleGrid(image, dimension, dimension, low, low, // topleft\n    high, low, // topright\n    high, high, // bottomright\n    low, high, // bottomleft\n    topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());\n  };\n  /**\r\n   * Samples a line.\r\n   *\r\n   * @param p1   start point (inclusive)\r\n   * @param p2   end point (exclusive)\r\n   * @param size number of bits\r\n   * @return the array of bits as an int (first bit is high-order bit of result)\r\n   */\n\n\n  Detector.prototype.sampleLine = function (p1, p2, size) {\n    var result = 0;\n    var d = this.distanceResultPoint(p1, p2);\n    var moduleSize = d / size;\n    var px = p1.getX();\n    var py = p1.getY();\n    var dx = moduleSize * (p2.getX() - p1.getX()) / d;\n    var dy = moduleSize * (p2.getY() - p1.getY()) / d;\n\n    for (var i = 0; i < size; i++) {\n      if (this.image.get(MathUtils_1.default.round(px + i * dx), MathUtils_1.default.round(py + i * dy))) {\n        result |= 1 << size - i - 1;\n      }\n    }\n\n    return result;\n  };\n  /**\r\n   * @return true if the border of the rectangle passed in parameter is compound of white points only\r\n   *         or black points only\r\n   */\n\n\n  Detector.prototype.isWhiteOrBlackRectangle = function (p1, p2, p3, p4) {\n    var corr = 3;\n    p1 = new Point(p1.getX() - corr, p1.getY() + corr);\n    p2 = new Point(p2.getX() - corr, p2.getY() - corr);\n    p3 = new Point(p3.getX() + corr, p3.getY() - corr);\n    p4 = new Point(p4.getX() + corr, p4.getY() + corr);\n    var cInit = this.getColor(p4, p1);\n\n    if (cInit === 0) {\n      return false;\n    }\n\n    var c = this.getColor(p1, p2);\n\n    if (c !== cInit) {\n      return false;\n    }\n\n    c = this.getColor(p2, p3);\n\n    if (c !== cInit) {\n      return false;\n    }\n\n    c = this.getColor(p3, p4);\n    return c === cInit;\n  };\n  /**\r\n   * Gets the color of a segment\r\n   *\r\n   * @return 1 if segment more than 90% black, -1 if segment is more than 90% white, 0 else\r\n   */\n\n\n  Detector.prototype.getColor = function (p1, p2) {\n    var d = this.distancePoint(p1, p2);\n    var dx = (p2.getX() - p1.getX()) / d;\n    var dy = (p2.getY() - p1.getY()) / d;\n    var error = 0;\n    var px = p1.getX();\n    var py = p1.getY();\n    var colorModel = this.image.get(p1.getX(), p1.getY());\n    var iMax = Math.ceil(d);\n\n    for (var i = 0; i < iMax; i++) {\n      px += dx;\n      py += dy;\n\n      if (this.image.get(MathUtils_1.default.round(px), MathUtils_1.default.round(py)) !== colorModel) {\n        error++;\n      }\n    }\n\n    var errRatio = error / d;\n\n    if (errRatio > 0.1 && errRatio < 0.9) {\n      return 0;\n    }\n\n    return errRatio <= 0.1 === colorModel ? 1 : -1;\n  };\n  /**\r\n   * Gets the coordinate of the first point with a different color in the given direction\r\n   */\n\n\n  Detector.prototype.getFirstDifferent = function (init, color, dx, dy) {\n    var x = init.getX() + dx;\n    var y = init.getY() + dy;\n\n    while (this.isValid(x, y) && this.image.get(x, y) === color) {\n      x += dx;\n      y += dy;\n    }\n\n    x -= dx;\n    y -= dy;\n\n    while (this.isValid(x, y) && this.image.get(x, y) === color) {\n      x += dx;\n    }\n\n    x -= dx;\n\n    while (this.isValid(x, y) && this.image.get(x, y) === color) {\n      y += dy;\n    }\n\n    y -= dy;\n    return new Point(x, y);\n  };\n  /**\r\n   * Expand the square represented by the corner points by pushing out equally in all directions\r\n   *\r\n   * @param cornerPoints the corners of the square, which has the bull's eye at its center\r\n   * @param oldSide the original length of the side of the square in the target bit matrix\r\n   * @param newSide the new length of the size of the square in the target bit matrix\r\n   * @return the corners of the expanded square\r\n   */\n\n\n  Detector.prototype.expandSquare = function (cornerPoints, oldSide, newSide) {\n    var ratio = newSide / (2.0 * oldSide);\n    var dx = cornerPoints[0].getX() - cornerPoints[2].getX();\n    var dy = cornerPoints[0].getY() - cornerPoints[2].getY();\n    var centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2.0;\n    var centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2.0;\n    var result0 = new ResultPoint_1.default(centerx + ratio * dx, centery + ratio * dy);\n    var result2 = new ResultPoint_1.default(centerx - ratio * dx, centery - ratio * dy);\n    dx = cornerPoints[1].getX() - cornerPoints[3].getX();\n    dy = cornerPoints[1].getY() - cornerPoints[3].getY();\n    centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2.0;\n    centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2.0;\n    var result1 = new ResultPoint_1.default(centerx + ratio * dx, centery + ratio * dy);\n    var result3 = new ResultPoint_1.default(centerx - ratio * dx, centery - ratio * dy);\n    var results = [result0, result1, result2, result3];\n    return results;\n  };\n\n  Detector.prototype.isValid = function (x, y) {\n    return x >= 0 && x < this.image.getWidth() && y > 0 && y < this.image.getHeight();\n  };\n\n  Detector.prototype.isValidPoint = function (point) {\n    var x = MathUtils_1.default.round(point.getX());\n    var y = MathUtils_1.default.round(point.getY());\n    return this.isValid(x, y);\n  };\n\n  Detector.prototype.distancePoint = function (a, b) {\n    return MathUtils_1.default.distance(a.getX(), a.getY(), b.getX(), b.getY());\n  };\n\n  Detector.prototype.distanceResultPoint = function (a, b) {\n    return MathUtils_1.default.distance(a.getX(), a.getY(), b.getX(), b.getY());\n  };\n\n  Detector.prototype.getDimension = function () {\n    if (this.compact) {\n      return 4 * this.nbLayers + 11;\n    }\n\n    if (this.nbLayers <= 4) {\n      return 4 * this.nbLayers + 15;\n    }\n\n    return 4 * this.nbLayers + 2 * (Integer_1.default.truncDivision(this.nbLayers - 4, 8) + 1) + 15;\n  };\n\n  return Detector;\n}();\n\nexports.default = Detector;","map":{"version":3,"sources":["../../../../src/core/aztec/detector/Detector.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/*\r\n * Copyright 2010 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ResultPoint_1 = require(\"../../ResultPoint\");\r\nvar AztecDetectorResult_1 = require(\"../AztecDetectorResult\");\r\nvar MathUtils_1 = require(\"../../common/detector/MathUtils\");\r\nvar WhiteRectangleDetector_1 = require(\"../../common/detector/WhiteRectangleDetector\");\r\nvar GenericGF_1 = require(\"../../common/reedsolomon/GenericGF\");\r\nvar ReedSolomonDecoder_1 = require(\"../../common/reedsolomon/ReedSolomonDecoder\");\r\nvar NotFoundException_1 = require(\"../../NotFoundException\");\r\nvar GridSamplerInstance_1 = require(\"../../common/GridSamplerInstance\");\r\nvar Integer_1 = require(\"../../util/Integer\");\r\nvar Point = /** @class */ (function () {\r\n    function Point(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    Point.prototype.toResultPoint = function () {\r\n        return new ResultPoint_1.default(this.getX(), this.getY());\r\n    };\r\n    Point.prototype.getX = function () {\r\n        return this.x;\r\n    };\r\n    Point.prototype.getY = function () {\r\n        return this.y;\r\n    };\r\n    return Point;\r\n}());\r\nexports.Point = Point;\r\n/**\r\n * Encapsulates logic that can detect an Aztec Code in an image, even if the Aztec Code\r\n * is rotated or skewed, or partially obscured.\r\n *\r\n * @author David Olivier\r\n * @author Frank Yellin\r\n */\r\nvar Detector = /** @class */ (function () {\r\n    function Detector(image) {\r\n        this.EXPECTED_CORNER_BITS = new Int32Array([\r\n            0xee0,\r\n            0x1dc,\r\n            0x83b,\r\n            0x707,\r\n        ]);\r\n        this.image = image;\r\n    }\r\n    Detector.prototype.detect = function () {\r\n        return this.detectMirror(false);\r\n    };\r\n    /**\r\n     * Detects an Aztec Code in an image.\r\n     *\r\n     * @param isMirror if true, image is a mirror-image of original\r\n     * @return {@link AztecDetectorResult} encapsulating results of detecting an Aztec Code\r\n     * @throws NotFoundException if no Aztec Code can be found\r\n     */\r\n    Detector.prototype.detectMirror = function (isMirror) {\r\n        // 1. Get the center of the aztec matrix\r\n        var pCenter = this.getMatrixCenter();\r\n        // 2. Get the center points of the four diagonal points just outside the bull's eye\r\n        //  [topRight, bottomRight, bottomLeft, topLeft]\r\n        var bullsEyeCorners = this.getBullsEyeCorners(pCenter);\r\n        if (isMirror) {\r\n            var temp = bullsEyeCorners[0];\r\n            bullsEyeCorners[0] = bullsEyeCorners[2];\r\n            bullsEyeCorners[2] = temp;\r\n        }\r\n        // 3. Get the size of the matrix and other parameters from the bull's eye\r\n        this.extractParameters(bullsEyeCorners);\r\n        // 4. Sample the grid\r\n        var bits = this.sampleGrid(this.image, bullsEyeCorners[this.shift % 4], bullsEyeCorners[(this.shift + 1) % 4], bullsEyeCorners[(this.shift + 2) % 4], bullsEyeCorners[(this.shift + 3) % 4]);\r\n        // 5. Get the corners of the matrix.\r\n        var corners = this.getMatrixCornerPoints(bullsEyeCorners);\r\n        return new AztecDetectorResult_1.default(bits, corners, this.compact, this.nbDataBlocks, this.nbLayers);\r\n    };\r\n    /**\r\n     * Extracts the number of data layers and data blocks from the layer around the bull's eye.\r\n     *\r\n     * @param bullsEyeCorners the array of bull's eye corners\r\n     * @throws NotFoundException in case of too many errors or invalid parameters\r\n     */\r\n    Detector.prototype.extractParameters = function (bullsEyeCorners) {\r\n        if (!this.isValidPoint(bullsEyeCorners[0]) || !this.isValidPoint(bullsEyeCorners[1]) ||\r\n            !this.isValidPoint(bullsEyeCorners[2]) || !this.isValidPoint(bullsEyeCorners[3])) {\r\n            throw new NotFoundException_1.default();\r\n        }\r\n        var length = 2 * this.nbCenterLayers;\r\n        // Get the bits around the bull's eye\r\n        var sides = new Int32Array([\r\n            this.sampleLine(bullsEyeCorners[0], bullsEyeCorners[1], length),\r\n            this.sampleLine(bullsEyeCorners[1], bullsEyeCorners[2], length),\r\n            this.sampleLine(bullsEyeCorners[2], bullsEyeCorners[3], length),\r\n            this.sampleLine(bullsEyeCorners[3], bullsEyeCorners[0], length) // Top\r\n        ]);\r\n        // bullsEyeCorners[shift] is the corner of the bulls'eye that has three\r\n        // orientation marks.\r\n        // sides[shift] is the row/column that goes from the corner with three\r\n        // orientation marks to the corner with two.\r\n        this.shift = this.getRotation(sides, length);\r\n        // Flatten the parameter bits into a single 28- or 40-bit long\r\n        var parameterData = 0;\r\n        for (var i = 0; i < 4; i++) {\r\n            var side = sides[(this.shift + i) % 4];\r\n            if (this.compact) {\r\n                // Each side of the form ..XXXXXXX. where Xs are parameter data\r\n                parameterData <<= 7;\r\n                parameterData += (side >> 1) & 0x7F;\r\n            }\r\n            else {\r\n                // Each side of the form ..XXXXX.XXXXX. where Xs are parameter data\r\n                parameterData <<= 10;\r\n                parameterData += ((side >> 2) & (0x1f << 5)) + ((side >> 1) & 0x1F);\r\n            }\r\n        }\r\n        // Corrects parameter data using RS.  Returns just the data portion\r\n        // without the error correction.\r\n        var correctedData = this.getCorrectedParameterData(parameterData, this.compact);\r\n        if (this.compact) {\r\n            // 8 bits:  2 bits layers and 6 bits data blocks\r\n            this.nbLayers = (correctedData >> 6) + 1;\r\n            this.nbDataBlocks = (correctedData & 0x3F) + 1;\r\n        }\r\n        else {\r\n            // 16 bits:  5 bits layers and 11 bits data blocks\r\n            this.nbLayers = (correctedData >> 11) + 1;\r\n            this.nbDataBlocks = (correctedData & 0x7FF) + 1;\r\n        }\r\n    };\r\n    Detector.prototype.getRotation = function (sides, length) {\r\n        // In a normal pattern, we expect to See\r\n        //   **    .*             D       A\r\n        //   *      *\r\n        //\r\n        //   .      *\r\n        //   ..    ..             C       B\r\n        //\r\n        // Grab the 3 bits from each of the sides the form the locator pattern and concatenate\r\n        // into a 12-bit integer.  Start with the bit at A\r\n        var cornerBits = 0;\r\n        sides.forEach(function (side, idx, arr) {\r\n            // XX......X where X's are orientation marks\r\n            var t = ((side >> (length - 2)) << 1) + (side & 1);\r\n            cornerBits = (cornerBits << 3) + t;\r\n        });\r\n        // for (var side in sides) {\r\n        //     // XX......X where X's are orientation marks\r\n        //     var t = ((side >> (length - 2)) << 1) + (side & 1);\r\n        //     cornerBits = (cornerBits << 3) + t;\r\n        // }\r\n        // Mov the bottom bit to the top, so that the three bits of the locator pattern at A are\r\n        // together.  cornerBits is now:\r\n        //  3 orientation bits at A || 3 orientation bits at B || ... || 3 orientation bits at D\r\n        cornerBits = ((cornerBits & 1) << 11) + (cornerBits >> 1);\r\n        // The result shift indicates which element of BullsEyeCorners[] goes into the top-left\r\n        // corner. Since the four rotation values have a Hamming distance of 8, we\r\n        // can easily tolerate two errors.\r\n        for (var shift = 0; shift < 4; shift++) {\r\n            if (Integer_1.default.bitCount(cornerBits ^ this.EXPECTED_CORNER_BITS[shift]) <= 2) {\r\n                return shift;\r\n            }\r\n        }\r\n        throw new NotFoundException_1.default();\r\n    };\r\n    /**\r\n     * Corrects the parameter bits using Reed-Solomon algorithm.\r\n     *\r\n     * @param parameterData parameter bits\r\n     * @param compact true if this is a compact Aztec code\r\n     * @throws NotFoundException if the array contains too many errors\r\n     */\r\n    Detector.prototype.getCorrectedParameterData = function (parameterData, compact) {\r\n        var numCodewords;\r\n        var numDataCodewords;\r\n        if (compact) {\r\n            numCodewords = 7;\r\n            numDataCodewords = 2;\r\n        }\r\n        else {\r\n            numCodewords = 10;\r\n            numDataCodewords = 4;\r\n        }\r\n        var numECCodewords = numCodewords - numDataCodewords;\r\n        var parameterWords = new Int32Array(numCodewords);\r\n        for (var i = numCodewords - 1; i >= 0; --i) {\r\n            parameterWords[i] = parameterData & 0xF;\r\n            parameterData >>= 4;\r\n        }\r\n        try {\r\n            var rsDecoder = new ReedSolomonDecoder_1.default(GenericGF_1.default.AZTEC_PARAM);\r\n            rsDecoder.decode(parameterWords, numECCodewords);\r\n        }\r\n        catch (ignored) {\r\n            throw new NotFoundException_1.default();\r\n        }\r\n        // Toss the error correction.  Just return the data as an integer\r\n        var result = 0;\r\n        for (var i = 0; i < numDataCodewords; i++) {\r\n            result = (result << 4) + parameterWords[i];\r\n        }\r\n        return result;\r\n    };\r\n    /**\r\n     * Finds the corners of a bull-eye centered on the passed point.\r\n     * This returns the centers of the diagonal points just outside the bull's eye\r\n     * Returns [topRight, bottomRight, bottomLeft, topLeft]\r\n     *\r\n     * @param pCenter Center point\r\n     * @return The corners of the bull-eye\r\n     * @throws NotFoundException If no valid bull-eye can be found\r\n     */\r\n    Detector.prototype.getBullsEyeCorners = function (pCenter) {\r\n        var pina = pCenter;\r\n        var pinb = pCenter;\r\n        var pinc = pCenter;\r\n        var pind = pCenter;\r\n        var color = true;\r\n        for (this.nbCenterLayers = 1; this.nbCenterLayers < 9; this.nbCenterLayers++) {\r\n            var pouta = this.getFirstDifferent(pina, color, 1, -1);\r\n            var poutb = this.getFirstDifferent(pinb, color, 1, 1);\r\n            var poutc = this.getFirstDifferent(pinc, color, -1, 1);\r\n            var poutd = this.getFirstDifferent(pind, color, -1, -1);\r\n            // d      a\r\n            //\r\n            // c      b\r\n            if (this.nbCenterLayers > 2) {\r\n                var q = (this.distancePoint(poutd, pouta) * this.nbCenterLayers) / (this.distancePoint(pind, pina) * (this.nbCenterLayers + 2));\r\n                if (q < 0.75 || q > 1.25 || !this.isWhiteOrBlackRectangle(pouta, poutb, poutc, poutd)) {\r\n                    break;\r\n                }\r\n            }\r\n            pina = pouta;\r\n            pinb = poutb;\r\n            pinc = poutc;\r\n            pind = poutd;\r\n            color = !color;\r\n        }\r\n        if (this.nbCenterLayers !== 5 && this.nbCenterLayers !== 7) {\r\n            throw new NotFoundException_1.default();\r\n        }\r\n        this.compact = this.nbCenterLayers === 5;\r\n        // Expand the square by .5 pixel in each direction so that we're on the border\r\n        // between the white square and the black square\r\n        var pinax = new ResultPoint_1.default(pina.getX() + 0.5, pina.getY() - 0.5);\r\n        var pinbx = new ResultPoint_1.default(pinb.getX() + 0.5, pinb.getY() + 0.5);\r\n        var pincx = new ResultPoint_1.default(pinc.getX() - 0.5, pinc.getY() + 0.5);\r\n        var pindx = new ResultPoint_1.default(pind.getX() - 0.5, pind.getY() - 0.5);\r\n        // Expand the square so that its corners are the centers of the points\r\n        // just outside the bull's eye.\r\n        return this.expandSquare([pinax, pinbx, pincx, pindx], 2 * this.nbCenterLayers - 3, 2 * this.nbCenterLayers);\r\n    };\r\n    /**\r\n     * Finds a candidate center point of an Aztec code from an image\r\n     *\r\n     * @return the center point\r\n     */\r\n    Detector.prototype.getMatrixCenter = function () {\r\n        var pointA;\r\n        var pointB;\r\n        var pointC;\r\n        var pointD;\r\n        // Get a white rectangle that can be the border of the matrix in center bull's eye or\r\n        try {\r\n            var cornerPoints = new WhiteRectangleDetector_1.default(this.image).detect();\r\n            pointA = cornerPoints[0];\r\n            pointB = cornerPoints[1];\r\n            pointC = cornerPoints[2];\r\n            pointD = cornerPoints[3];\r\n        }\r\n        catch (e) {\r\n            // This exception can be in case the initial rectangle is white\r\n            // In that case, surely in the bull's eye, we try to expand the rectangle.\r\n            var cx_1 = this.image.getWidth() / 2;\r\n            var cy_1 = this.image.getHeight() / 2;\r\n            pointA = this.getFirstDifferent(new Point(cx_1 + 7, cy_1 - 7), false, 1, -1).toResultPoint();\r\n            pointB = this.getFirstDifferent(new Point(cx_1 + 7, cy_1 + 7), false, 1, 1).toResultPoint();\r\n            pointC = this.getFirstDifferent(new Point(cx_1 - 7, cy_1 + 7), false, -1, 1).toResultPoint();\r\n            pointD = this.getFirstDifferent(new Point(cx_1 - 7, cy_1 - 7), false, -1, -1).toResultPoint();\r\n        }\r\n        // Compute the center of the rectangle\r\n        var cx = MathUtils_1.default.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);\r\n        var cy = MathUtils_1.default.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0);\r\n        // Redetermine the white rectangle starting from previously computed center.\r\n        // This will ensure that we end up with a white rectangle in center bull's eye\r\n        // in order to compute a more accurate center.\r\n        try {\r\n            var cornerPoints = new WhiteRectangleDetector_1.default(this.image, 15, cx, cy).detect();\r\n            pointA = cornerPoints[0];\r\n            pointB = cornerPoints[1];\r\n            pointC = cornerPoints[2];\r\n            pointD = cornerPoints[3];\r\n        }\r\n        catch (e) {\r\n            // This exception can be in case the initial rectangle is white\r\n            // In that case we try to expand the rectangle.\r\n            pointA = this.getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();\r\n            pointB = this.getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();\r\n            pointC = this.getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();\r\n            pointD = this.getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();\r\n        }\r\n        // Recompute the center of the rectangle\r\n        cx = MathUtils_1.default.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);\r\n        cy = MathUtils_1.default.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0);\r\n        return new Point(cx, cy);\r\n    };\r\n    /**\r\n     * Gets the Aztec code corners from the bull's eye corners and the parameters.\r\n     *\r\n     * @param bullsEyeCorners the array of bull's eye corners\r\n     * @return the array of aztec code corners\r\n     */\r\n    Detector.prototype.getMatrixCornerPoints = function (bullsEyeCorners) {\r\n        return this.expandSquare(bullsEyeCorners, 2 * this.nbCenterLayers, this.getDimension());\r\n    };\r\n    /**\r\n     * Creates a BitMatrix by sampling the provided image.\r\n     * topLeft, topRight, bottomRight, and bottomLeft are the centers of the squares on the\r\n     * diagonal just outside the bull's eye.\r\n     */\r\n    Detector.prototype.sampleGrid = function (image, topLeft, topRight, bottomRight, bottomLeft) {\r\n        var sampler = GridSamplerInstance_1.default.getInstance();\r\n        var dimension = this.getDimension();\r\n        var low = dimension / 2 - this.nbCenterLayers;\r\n        var high = dimension / 2 + this.nbCenterLayers;\r\n        return sampler.sampleGrid(image, dimension, dimension, low, low, // topleft\r\n        high, low, // topright\r\n        high, high, // bottomright\r\n        low, high, // bottomleft\r\n        topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());\r\n    };\r\n    /**\r\n     * Samples a line.\r\n     *\r\n     * @param p1   start point (inclusive)\r\n     * @param p2   end point (exclusive)\r\n     * @param size number of bits\r\n     * @return the array of bits as an int (first bit is high-order bit of result)\r\n     */\r\n    Detector.prototype.sampleLine = function (p1, p2, size) {\r\n        var result = 0;\r\n        var d = this.distanceResultPoint(p1, p2);\r\n        var moduleSize = d / size;\r\n        var px = p1.getX();\r\n        var py = p1.getY();\r\n        var dx = moduleSize * (p2.getX() - p1.getX()) / d;\r\n        var dy = moduleSize * (p2.getY() - p1.getY()) / d;\r\n        for (var i = 0; i < size; i++) {\r\n            if (this.image.get(MathUtils_1.default.round(px + i * dx), MathUtils_1.default.round(py + i * dy))) {\r\n                result |= 1 << (size - i - 1);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    /**\r\n     * @return true if the border of the rectangle passed in parameter is compound of white points only\r\n     *         or black points only\r\n     */\r\n    Detector.prototype.isWhiteOrBlackRectangle = function (p1, p2, p3, p4) {\r\n        var corr = 3;\r\n        p1 = new Point(p1.getX() - corr, p1.getY() + corr);\r\n        p2 = new Point(p2.getX() - corr, p2.getY() - corr);\r\n        p3 = new Point(p3.getX() + corr, p3.getY() - corr);\r\n        p4 = new Point(p4.getX() + corr, p4.getY() + corr);\r\n        var cInit = this.getColor(p4, p1);\r\n        if (cInit === 0) {\r\n            return false;\r\n        }\r\n        var c = this.getColor(p1, p2);\r\n        if (c !== cInit) {\r\n            return false;\r\n        }\r\n        c = this.getColor(p2, p3);\r\n        if (c !== cInit) {\r\n            return false;\r\n        }\r\n        c = this.getColor(p3, p4);\r\n        return c === cInit;\r\n    };\r\n    /**\r\n     * Gets the color of a segment\r\n     *\r\n     * @return 1 if segment more than 90% black, -1 if segment is more than 90% white, 0 else\r\n     */\r\n    Detector.prototype.getColor = function (p1, p2) {\r\n        var d = this.distancePoint(p1, p2);\r\n        var dx = (p2.getX() - p1.getX()) / d;\r\n        var dy = (p2.getY() - p1.getY()) / d;\r\n        var error = 0;\r\n        var px = p1.getX();\r\n        var py = p1.getY();\r\n        var colorModel = this.image.get(p1.getX(), p1.getY());\r\n        var iMax = Math.ceil(d);\r\n        for (var i = 0; i < iMax; i++) {\r\n            px += dx;\r\n            py += dy;\r\n            if (this.image.get(MathUtils_1.default.round(px), MathUtils_1.default.round(py)) !== colorModel) {\r\n                error++;\r\n            }\r\n        }\r\n        var errRatio = error / d;\r\n        if (errRatio > 0.1 && errRatio < 0.9) {\r\n            return 0;\r\n        }\r\n        return (errRatio <= 0.1) === colorModel ? 1 : -1;\r\n    };\r\n    /**\r\n     * Gets the coordinate of the first point with a different color in the given direction\r\n     */\r\n    Detector.prototype.getFirstDifferent = function (init, color, dx, dy) {\r\n        var x = init.getX() + dx;\r\n        var y = init.getY() + dy;\r\n        while (this.isValid(x, y) && this.image.get(x, y) === color) {\r\n            x += dx;\r\n            y += dy;\r\n        }\r\n        x -= dx;\r\n        y -= dy;\r\n        while (this.isValid(x, y) && this.image.get(x, y) === color) {\r\n            x += dx;\r\n        }\r\n        x -= dx;\r\n        while (this.isValid(x, y) && this.image.get(x, y) === color) {\r\n            y += dy;\r\n        }\r\n        y -= dy;\r\n        return new Point(x, y);\r\n    };\r\n    /**\r\n     * Expand the square represented by the corner points by pushing out equally in all directions\r\n     *\r\n     * @param cornerPoints the corners of the square, which has the bull's eye at its center\r\n     * @param oldSide the original length of the side of the square in the target bit matrix\r\n     * @param newSide the new length of the size of the square in the target bit matrix\r\n     * @return the corners of the expanded square\r\n     */\r\n    Detector.prototype.expandSquare = function (cornerPoints, oldSide, newSide) {\r\n        var ratio = newSide / (2.0 * oldSide);\r\n        var dx = cornerPoints[0].getX() - cornerPoints[2].getX();\r\n        var dy = cornerPoints[0].getY() - cornerPoints[2].getY();\r\n        var centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2.0;\r\n        var centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2.0;\r\n        var result0 = new ResultPoint_1.default(centerx + ratio * dx, centery + ratio * dy);\r\n        var result2 = new ResultPoint_1.default(centerx - ratio * dx, centery - ratio * dy);\r\n        dx = cornerPoints[1].getX() - cornerPoints[3].getX();\r\n        dy = cornerPoints[1].getY() - cornerPoints[3].getY();\r\n        centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2.0;\r\n        centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2.0;\r\n        var result1 = new ResultPoint_1.default(centerx + ratio * dx, centery + ratio * dy);\r\n        var result3 = new ResultPoint_1.default(centerx - ratio * dx, centery - ratio * dy);\r\n        var results = [result0, result1, result2, result3];\r\n        return results;\r\n    };\r\n    Detector.prototype.isValid = function (x, y) {\r\n        return x >= 0 && x < this.image.getWidth() && y > 0 && y < this.image.getHeight();\r\n    };\r\n    Detector.prototype.isValidPoint = function (point) {\r\n        var x = MathUtils_1.default.round(point.getX());\r\n        var y = MathUtils_1.default.round(point.getY());\r\n        return this.isValid(x, y);\r\n    };\r\n    Detector.prototype.distancePoint = function (a, b) {\r\n        return MathUtils_1.default.distance(a.getX(), a.getY(), b.getX(), b.getY());\r\n    };\r\n    Detector.prototype.distanceResultPoint = function (a, b) {\r\n        return MathUtils_1.default.distance(a.getX(), a.getY(), b.getX(), b.getY());\r\n    };\r\n    Detector.prototype.getDimension = function () {\r\n        if (this.compact) {\r\n            return 4 * this.nbLayers + 11;\r\n        }\r\n        if (this.nbLayers <= 4) {\r\n            return 4 * this.nbLayers + 15;\r\n        }\r\n        return 4 * this.nbLayers + 2 * (Integer_1.default.truncDivision((this.nbLayers - 4), 8) + 1) + 15;\r\n    };\r\n    return Detector;\r\n}());\r\nexports.default = Detector;\r\n//# sourceMappingURL=Detector.js.map"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n/*\r\n * Copyright 2009 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.common {*/\n\nvar Binarizer_1 = require(\"../Binarizer\");\n\nvar BitArray_1 = require(\"./BitArray\");\n\nvar BitMatrix_1 = require(\"./BitMatrix\");\n\nvar NotFoundException_1 = require(\"../NotFoundException\");\n/**\r\n * This Binarizer implementation uses the old ZXing global histogram approach. It is suitable\r\n * for low-end mobile devices which don't have enough CPU or memory to use a local thresholding\r\n * algorithm. However, because it picks a global black point, it cannot handle difficult shadows\r\n * and gradients.\r\n *\r\n * Faster mobile devices and all desktop applications should probably use HybridBinarizer instead.\r\n *\r\n * @author dswitkin@google.com (Daniel Switkin)\r\n * @author Sean Owen\r\n */\n\n\nvar GlobalHistogramBinarizer =\n/** @class */\nfunction (_super) {\n  __extends(GlobalHistogramBinarizer, _super);\n\n  function GlobalHistogramBinarizer(source) {\n    var _this = _super.call(this, source) || this;\n\n    _this.luminances = GlobalHistogramBinarizer.EMPTY;\n    _this.buckets = new Int32Array(GlobalHistogramBinarizer.LUMINANCE_BUCKETS);\n    return _this;\n  } // Applies simple sharpening to the row data to improve performance of the 1D Readers.\n\n  /*@Override*/\n\n\n  GlobalHistogramBinarizer.prototype.getBlackRow = function (y\n  /*int*/\n  , row) {\n    var source = this.getLuminanceSource();\n    var width = source.getWidth();\n\n    if (row === undefined || row === null || row.getSize() < width) {\n      row = new BitArray_1.default(width);\n    } else {\n      row.clear();\n    }\n\n    this.initArrays(width);\n    var localLuminances = source.getRow(y, this.luminances);\n    var localBuckets = this.buckets;\n\n    for (var x = 0; x < width; x++) {\n      localBuckets[(localLuminances[x] & 0xff) >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;\n    }\n\n    var blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);\n\n    if (width < 3) {\n      // Special case for very small images\n      for (var x = 0; x < width; x++) {\n        if ((localLuminances[x] & 0xff) < blackPoint) {\n          row.set(x);\n        }\n      }\n    } else {\n      var left = localLuminances[0] & 0xff;\n      var center = localLuminances[1] & 0xff;\n\n      for (var x = 1; x < width - 1; x++) {\n        var right = localLuminances[x + 1] & 0xff; // A simple -1 4 -1 box filter with a weight of 2.\n\n        if ((center * 4 - left - right) / 2 < blackPoint) {\n          row.set(x);\n        }\n\n        left = center;\n        center = right;\n      }\n    }\n\n    return row;\n  }; // Does not sharpen the data, as this call is intended to only be used by 2D Readers.\n\n  /*@Override*/\n\n\n  GlobalHistogramBinarizer.prototype.getBlackMatrix = function () {\n    var source = this.getLuminanceSource();\n    var width = source.getWidth();\n    var height = source.getHeight();\n    var matrix = new BitMatrix_1.default(width, height); // Quickly calculates the histogram by sampling four rows from the image. This proved to be\n    // more robust on the blackbox tests than sampling a diagonal as we used to do.\n\n    this.initArrays(width);\n    var localBuckets = this.buckets;\n\n    for (var y = 1; y < 5; y++) {\n      var row = Math.floor(height * y / 5);\n      var localLuminances_1 = source.getRow(row, this.luminances);\n      var right = Math.floor(width * 4 / 5);\n\n      for (var x = Math.floor(width / 5); x < right; x++) {\n        var pixel = localLuminances_1[x] & 0xff;\n        localBuckets[pixel >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;\n      }\n    }\n\n    var blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets); // We delay reading the entire image luminance until the black point estimation succeeds.\n    // Although we end up reading four rows twice, it is consistent with our motto of\n    // \"fail quickly\" which is necessary for continuous scanning.\n\n    var localLuminances = source.getMatrix();\n\n    for (var y = 0; y < height; y++) {\n      var offset = y * width;\n\n      for (var x = 0; x < width; x++) {\n        var pixel = localLuminances[offset + x] & 0xff;\n\n        if (pixel < blackPoint) {\n          matrix.set(x, y);\n        }\n      }\n    }\n\n    return matrix;\n  };\n  /*@Override*/\n\n\n  GlobalHistogramBinarizer.prototype.createBinarizer = function (source) {\n    return new GlobalHistogramBinarizer(source);\n  };\n\n  GlobalHistogramBinarizer.prototype.initArrays = function (luminanceSize\n  /*int*/\n  ) {\n    if (this.luminances.length < luminanceSize) {\n      this.luminances = new Uint8ClampedArray(luminanceSize);\n    }\n\n    var buckets = this.buckets;\n\n    for (var x = 0; x < GlobalHistogramBinarizer.LUMINANCE_BUCKETS; x++) {\n      buckets[x] = 0;\n    }\n  };\n\n  GlobalHistogramBinarizer.estimateBlackPoint = function (buckets) {\n    // Find the tallest peak in the histogram.\n    var numBuckets = buckets.length;\n    var maxBucketCount = 0;\n    var firstPeak = 0;\n    var firstPeakSize = 0;\n\n    for (var x = 0; x < numBuckets; x++) {\n      if (buckets[x] > firstPeakSize) {\n        firstPeak = x;\n        firstPeakSize = buckets[x];\n      }\n\n      if (buckets[x] > maxBucketCount) {\n        maxBucketCount = buckets[x];\n      }\n    } // Find the second-tallest peak which is somewhat far from the tallest peak.\n\n\n    var secondPeak = 0;\n    var secondPeakScore = 0;\n\n    for (var x = 0; x < numBuckets; x++) {\n      var distanceToBiggest = x - firstPeak; // Encourage more distant second peaks by multiplying by square of distance.\n\n      var score = buckets[x] * distanceToBiggest * distanceToBiggest;\n\n      if (score > secondPeakScore) {\n        secondPeak = x;\n        secondPeakScore = score;\n      }\n    } // Make sure firstPeak corresponds to the black peak.\n\n\n    if (firstPeak > secondPeak) {\n      var temp = firstPeak;\n      firstPeak = secondPeak;\n      secondPeak = temp;\n    } // If there is too little contrast in the image to pick a meaningful black point, throw rather\n    // than waste time trying to decode the image, and risk false positives.\n\n\n    if (secondPeak - firstPeak <= numBuckets / 16) {\n      throw new NotFoundException_1.default();\n    } // Find a valley between them that is low and closer to the white peak.\n\n\n    var bestValley = secondPeak - 1;\n    var bestValleyScore = -1;\n\n    for (var x = secondPeak - 1; x > firstPeak; x--) {\n      var fromFirst = x - firstPeak;\n      var score = fromFirst * fromFirst * (secondPeak - x) * (maxBucketCount - buckets[x]);\n\n      if (score > bestValleyScore) {\n        bestValley = x;\n        bestValleyScore = score;\n      }\n    }\n\n    return bestValley << GlobalHistogramBinarizer.LUMINANCE_SHIFT;\n  };\n\n  GlobalHistogramBinarizer.LUMINANCE_BITS = 5;\n  GlobalHistogramBinarizer.LUMINANCE_SHIFT = 8 - GlobalHistogramBinarizer.LUMINANCE_BITS;\n  GlobalHistogramBinarizer.LUMINANCE_BUCKETS = 1 << GlobalHistogramBinarizer.LUMINANCE_BITS;\n  GlobalHistogramBinarizer.EMPTY = Uint8ClampedArray.from([0]);\n  return GlobalHistogramBinarizer;\n}(Binarizer_1.default);\n\nexports.default = GlobalHistogramBinarizer;","map":{"version":3,"sources":["../../../src/core/common/GlobalHistogramBinarizer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/*\r\n * Copyright 2009 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*namespace com.google.zxing.common {*/\r\nvar Binarizer_1 = require(\"../Binarizer\");\r\nvar BitArray_1 = require(\"./BitArray\");\r\nvar BitMatrix_1 = require(\"./BitMatrix\");\r\nvar NotFoundException_1 = require(\"../NotFoundException\");\r\n/**\r\n * This Binarizer implementation uses the old ZXing global histogram approach. It is suitable\r\n * for low-end mobile devices which don't have enough CPU or memory to use a local thresholding\r\n * algorithm. However, because it picks a global black point, it cannot handle difficult shadows\r\n * and gradients.\r\n *\r\n * Faster mobile devices and all desktop applications should probably use HybridBinarizer instead.\r\n *\r\n * @author dswitkin@google.com (Daniel Switkin)\r\n * @author Sean Owen\r\n */\r\nvar GlobalHistogramBinarizer = /** @class */ (function (_super) {\r\n    __extends(GlobalHistogramBinarizer, _super);\r\n    function GlobalHistogramBinarizer(source) {\r\n        var _this = _super.call(this, source) || this;\r\n        _this.luminances = GlobalHistogramBinarizer.EMPTY;\r\n        _this.buckets = new Int32Array(GlobalHistogramBinarizer.LUMINANCE_BUCKETS);\r\n        return _this;\r\n    }\r\n    // Applies simple sharpening to the row data to improve performance of the 1D Readers.\r\n    /*@Override*/\r\n    GlobalHistogramBinarizer.prototype.getBlackRow = function (y /*int*/, row) {\r\n        var source = this.getLuminanceSource();\r\n        var width = source.getWidth();\r\n        if (row === undefined || row === null || row.getSize() < width) {\r\n            row = new BitArray_1.default(width);\r\n        }\r\n        else {\r\n            row.clear();\r\n        }\r\n        this.initArrays(width);\r\n        var localLuminances = source.getRow(y, this.luminances);\r\n        var localBuckets = this.buckets;\r\n        for (var x = 0; x < width; x++) {\r\n            localBuckets[(localLuminances[x] & 0xff) >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;\r\n        }\r\n        var blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);\r\n        if (width < 3) {\r\n            // Special case for very small images\r\n            for (var x = 0; x < width; x++) {\r\n                if ((localLuminances[x] & 0xff) < blackPoint) {\r\n                    row.set(x);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var left = localLuminances[0] & 0xff;\r\n            var center = localLuminances[1] & 0xff;\r\n            for (var x = 1; x < width - 1; x++) {\r\n                var right = localLuminances[x + 1] & 0xff;\r\n                // A simple -1 4 -1 box filter with a weight of 2.\r\n                if (((center * 4) - left - right) / 2 < blackPoint) {\r\n                    row.set(x);\r\n                }\r\n                left = center;\r\n                center = right;\r\n            }\r\n        }\r\n        return row;\r\n    };\r\n    // Does not sharpen the data, as this call is intended to only be used by 2D Readers.\r\n    /*@Override*/\r\n    GlobalHistogramBinarizer.prototype.getBlackMatrix = function () {\r\n        var source = this.getLuminanceSource();\r\n        var width = source.getWidth();\r\n        var height = source.getHeight();\r\n        var matrix = new BitMatrix_1.default(width, height);\r\n        // Quickly calculates the histogram by sampling four rows from the image. This proved to be\r\n        // more robust on the blackbox tests than sampling a diagonal as we used to do.\r\n        this.initArrays(width);\r\n        var localBuckets = this.buckets;\r\n        for (var y = 1; y < 5; y++) {\r\n            var row = Math.floor((height * y) / 5);\r\n            var localLuminances_1 = source.getRow(row, this.luminances);\r\n            var right = Math.floor((width * 4) / 5);\r\n            for (var x = Math.floor(width / 5); x < right; x++) {\r\n                var pixel = localLuminances_1[x] & 0xff;\r\n                localBuckets[pixel >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;\r\n            }\r\n        }\r\n        var blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);\r\n        // We delay reading the entire image luminance until the black point estimation succeeds.\r\n        // Although we end up reading four rows twice, it is consistent with our motto of\r\n        // \"fail quickly\" which is necessary for continuous scanning.\r\n        var localLuminances = source.getMatrix();\r\n        for (var y = 0; y < height; y++) {\r\n            var offset = y * width;\r\n            for (var x = 0; x < width; x++) {\r\n                var pixel = localLuminances[offset + x] & 0xff;\r\n                if (pixel < blackPoint) {\r\n                    matrix.set(x, y);\r\n                }\r\n            }\r\n        }\r\n        return matrix;\r\n    };\r\n    /*@Override*/\r\n    GlobalHistogramBinarizer.prototype.createBinarizer = function (source) {\r\n        return new GlobalHistogramBinarizer(source);\r\n    };\r\n    GlobalHistogramBinarizer.prototype.initArrays = function (luminanceSize /*int*/) {\r\n        if (this.luminances.length < luminanceSize) {\r\n            this.luminances = new Uint8ClampedArray(luminanceSize);\r\n        }\r\n        var buckets = this.buckets;\r\n        for (var x = 0; x < GlobalHistogramBinarizer.LUMINANCE_BUCKETS; x++) {\r\n            buckets[x] = 0;\r\n        }\r\n    };\r\n    GlobalHistogramBinarizer.estimateBlackPoint = function (buckets) {\r\n        // Find the tallest peak in the histogram.\r\n        var numBuckets = buckets.length;\r\n        var maxBucketCount = 0;\r\n        var firstPeak = 0;\r\n        var firstPeakSize = 0;\r\n        for (var x = 0; x < numBuckets; x++) {\r\n            if (buckets[x] > firstPeakSize) {\r\n                firstPeak = x;\r\n                firstPeakSize = buckets[x];\r\n            }\r\n            if (buckets[x] > maxBucketCount) {\r\n                maxBucketCount = buckets[x];\r\n            }\r\n        }\r\n        // Find the second-tallest peak which is somewhat far from the tallest peak.\r\n        var secondPeak = 0;\r\n        var secondPeakScore = 0;\r\n        for (var x = 0; x < numBuckets; x++) {\r\n            var distanceToBiggest = x - firstPeak;\r\n            // Encourage more distant second peaks by multiplying by square of distance.\r\n            var score = buckets[x] * distanceToBiggest * distanceToBiggest;\r\n            if (score > secondPeakScore) {\r\n                secondPeak = x;\r\n                secondPeakScore = score;\r\n            }\r\n        }\r\n        // Make sure firstPeak corresponds to the black peak.\r\n        if (firstPeak > secondPeak) {\r\n            var temp = firstPeak;\r\n            firstPeak = secondPeak;\r\n            secondPeak = temp;\r\n        }\r\n        // If there is too little contrast in the image to pick a meaningful black point, throw rather\r\n        // than waste time trying to decode the image, and risk false positives.\r\n        if (secondPeak - firstPeak <= numBuckets / 16) {\r\n            throw new NotFoundException_1.default();\r\n        }\r\n        // Find a valley between them that is low and closer to the white peak.\r\n        var bestValley = secondPeak - 1;\r\n        var bestValleyScore = -1;\r\n        for (var x = secondPeak - 1; x > firstPeak; x--) {\r\n            var fromFirst = x - firstPeak;\r\n            var score = fromFirst * fromFirst * (secondPeak - x) * (maxBucketCount - buckets[x]);\r\n            if (score > bestValleyScore) {\r\n                bestValley = x;\r\n                bestValleyScore = score;\r\n            }\r\n        }\r\n        return bestValley << GlobalHistogramBinarizer.LUMINANCE_SHIFT;\r\n    };\r\n    GlobalHistogramBinarizer.LUMINANCE_BITS = 5;\r\n    GlobalHistogramBinarizer.LUMINANCE_SHIFT = 8 - GlobalHistogramBinarizer.LUMINANCE_BITS;\r\n    GlobalHistogramBinarizer.LUMINANCE_BUCKETS = 1 << GlobalHistogramBinarizer.LUMINANCE_BITS;\r\n    GlobalHistogramBinarizer.EMPTY = Uint8ClampedArray.from([0]);\r\n    return GlobalHistogramBinarizer;\r\n}(Binarizer_1.default));\r\nexports.default = GlobalHistogramBinarizer;\r\n//# sourceMappingURL=GlobalHistogramBinarizer.js.map"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.qrcode.decoder {*/\n\nvar ErrorCorrectionLevel_1 = require(\"./ErrorCorrectionLevel\");\n\nvar Integer_1 = require(\"../../util/Integer\");\n/**\r\n * <p>Encapsulates a QR Code's format information, including the data mask used and\r\n * error correction level.</p>\r\n *\r\n * @author Sean Owen\r\n * @see DataMask\r\n * @see ErrorCorrectionLevel\r\n */\n\n\nvar FormatInformation =\n/** @class */\nfunction () {\n  function FormatInformation(formatInfo\n  /*int*/\n  ) {\n    // Bits 3,4\n    this.errorCorrectionLevel = ErrorCorrectionLevel_1.default.forBits(formatInfo >> 3 & 0x03); // Bottom 3 bits\n\n    this.dataMask =\n    /*(byte) */\n    formatInfo & 0x07;\n  }\n\n  FormatInformation.numBitsDiffering = function (a\n  /*int*/\n  , b\n  /*int*/\n  ) {\n    return Integer_1.default.bitCount(a ^ b);\n  };\n  /**\r\n   * @param maskedFormatInfo1 format info indicator, with mask still applied\r\n   * @param maskedFormatInfo2 second copy of same info; both are checked at the same time\r\n   *  to establish best match\r\n   * @return information about the format it specifies, or {@code null}\r\n   *  if doesn't seem to match any known pattern\r\n   */\n\n\n  FormatInformation.decodeFormatInformation = function (maskedFormatInfo1\n  /*int*/\n  , maskedFormatInfo2\n  /*int*/\n  ) {\n    var formatInfo = FormatInformation.doDecodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2);\n\n    if (formatInfo !== null) {\n      return formatInfo;\n    } // Should return null, but, some QR codes apparently\n    // do not mask this info. Try again by actually masking the pattern\n    // first\n\n\n    return FormatInformation.doDecodeFormatInformation(maskedFormatInfo1 ^ FormatInformation.FORMAT_INFO_MASK_QR, maskedFormatInfo2 ^ FormatInformation.FORMAT_INFO_MASK_QR);\n  };\n\n  FormatInformation.doDecodeFormatInformation = function (maskedFormatInfo1\n  /*int*/\n  , maskedFormatInfo2\n  /*int*/\n  ) {\n    var e_1, _a; // Find the int in FORMAT_INFO_DECODE_LOOKUP with fewest bits differing\n\n\n    var bestDifference = Number.MAX_SAFE_INTEGER;\n    var bestFormatInfo = 0;\n\n    try {\n      for (var _b = __values(FormatInformation.FORMAT_INFO_DECODE_LOOKUP), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var decodeInfo = _c.value;\n        var targetInfo = decodeInfo[0];\n\n        if (targetInfo === maskedFormatInfo1 || targetInfo === maskedFormatInfo2) {\n          // Found an exact match\n          return new FormatInformation(decodeInfo[1]);\n        }\n\n        var bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo1, targetInfo);\n\n        if (bitsDifference < bestDifference) {\n          bestFormatInfo = decodeInfo[1];\n          bestDifference = bitsDifference;\n        }\n\n        if (maskedFormatInfo1 !== maskedFormatInfo2) {\n          // also try the other option\n          bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo2, targetInfo);\n\n          if (bitsDifference < bestDifference) {\n            bestFormatInfo = decodeInfo[1];\n            bestDifference = bitsDifference;\n          }\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    } // Hamming distance of the 32 masked codes is 7, by construction, so <= 3 bits\n    // differing means we found a match\n\n\n    if (bestDifference <= 3) {\n      return new FormatInformation(bestFormatInfo);\n    }\n\n    return null;\n  };\n\n  FormatInformation.prototype.getErrorCorrectionLevel = function () {\n    return this.errorCorrectionLevel;\n  };\n\n  FormatInformation.prototype.getDataMask = function () {\n    return this.dataMask;\n  };\n  /*@Override*/\n\n\n  FormatInformation.prototype.hashCode = function () {\n    return this.errorCorrectionLevel.getBits() << 3 | this.dataMask;\n  };\n  /*@Override*/\n\n\n  FormatInformation.prototype.equals = function (o) {\n    if (!(o instanceof FormatInformation)) {\n      return false;\n    }\n\n    var other = o;\n    return this.errorCorrectionLevel === other.errorCorrectionLevel && this.dataMask === other.dataMask;\n  };\n\n  FormatInformation.FORMAT_INFO_MASK_QR = 0x5412;\n  /**\r\n   * See ISO 18004:2006, Annex C, Table C.1\r\n   */\n\n  FormatInformation.FORMAT_INFO_DECODE_LOOKUP = [Int32Array.from([0x5412, 0x00]), Int32Array.from([0x5125, 0x01]), Int32Array.from([0x5E7C, 0x02]), Int32Array.from([0x5B4B, 0x03]), Int32Array.from([0x45F9, 0x04]), Int32Array.from([0x40CE, 0x05]), Int32Array.from([0x4F97, 0x06]), Int32Array.from([0x4AA0, 0x07]), Int32Array.from([0x77C4, 0x08]), Int32Array.from([0x72F3, 0x09]), Int32Array.from([0x7DAA, 0x0A]), Int32Array.from([0x789D, 0x0B]), Int32Array.from([0x662F, 0x0C]), Int32Array.from([0x6318, 0x0D]), Int32Array.from([0x6C41, 0x0E]), Int32Array.from([0x6976, 0x0F]), Int32Array.from([0x1689, 0x10]), Int32Array.from([0x13BE, 0x11]), Int32Array.from([0x1CE7, 0x12]), Int32Array.from([0x19D0, 0x13]), Int32Array.from([0x0762, 0x14]), Int32Array.from([0x0255, 0x15]), Int32Array.from([0x0D0C, 0x16]), Int32Array.from([0x083B, 0x17]), Int32Array.from([0x355F, 0x18]), Int32Array.from([0x3068, 0x19]), Int32Array.from([0x3F31, 0x1A]), Int32Array.from([0x3A06, 0x1B]), Int32Array.from([0x24B4, 0x1C]), Int32Array.from([0x2183, 0x1D]), Int32Array.from([0x2EDA, 0x1E]), Int32Array.from([0x2BED, 0x1F])];\n  return FormatInformation;\n}();\n\nexports.default = FormatInformation;","map":{"version":3,"sources":["../../../../src/core/qrcode/decoder/FormatInformation.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar __values = (this && this.__values) || function (o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*namespace com.google.zxing.qrcode.decoder {*/\r\nvar ErrorCorrectionLevel_1 = require(\"./ErrorCorrectionLevel\");\r\nvar Integer_1 = require(\"../../util/Integer\");\r\n/**\r\n * <p>Encapsulates a QR Code's format information, including the data mask used and\r\n * error correction level.</p>\r\n *\r\n * @author Sean Owen\r\n * @see DataMask\r\n * @see ErrorCorrectionLevel\r\n */\r\nvar FormatInformation = /** @class */ (function () {\r\n    function FormatInformation(formatInfo /*int*/) {\r\n        // Bits 3,4\r\n        this.errorCorrectionLevel = ErrorCorrectionLevel_1.default.forBits((formatInfo >> 3) & 0x03);\r\n        // Bottom 3 bits\r\n        this.dataMask = /*(byte) */ (formatInfo & 0x07);\r\n    }\r\n    FormatInformation.numBitsDiffering = function (a /*int*/, b /*int*/) {\r\n        return Integer_1.default.bitCount(a ^ b);\r\n    };\r\n    /**\r\n     * @param maskedFormatInfo1 format info indicator, with mask still applied\r\n     * @param maskedFormatInfo2 second copy of same info; both are checked at the same time\r\n     *  to establish best match\r\n     * @return information about the format it specifies, or {@code null}\r\n     *  if doesn't seem to match any known pattern\r\n     */\r\n    FormatInformation.decodeFormatInformation = function (maskedFormatInfo1 /*int*/, maskedFormatInfo2 /*int*/) {\r\n        var formatInfo = FormatInformation.doDecodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2);\r\n        if (formatInfo !== null) {\r\n            return formatInfo;\r\n        }\r\n        // Should return null, but, some QR codes apparently\r\n        // do not mask this info. Try again by actually masking the pattern\r\n        // first\r\n        return FormatInformation.doDecodeFormatInformation(maskedFormatInfo1 ^ FormatInformation.FORMAT_INFO_MASK_QR, maskedFormatInfo2 ^ FormatInformation.FORMAT_INFO_MASK_QR);\r\n    };\r\n    FormatInformation.doDecodeFormatInformation = function (maskedFormatInfo1 /*int*/, maskedFormatInfo2 /*int*/) {\r\n        var e_1, _a;\r\n        // Find the int in FORMAT_INFO_DECODE_LOOKUP with fewest bits differing\r\n        var bestDifference = Number.MAX_SAFE_INTEGER;\r\n        var bestFormatInfo = 0;\r\n        try {\r\n            for (var _b = __values(FormatInformation.FORMAT_INFO_DECODE_LOOKUP), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var decodeInfo = _c.value;\r\n                var targetInfo = decodeInfo[0];\r\n                if (targetInfo === maskedFormatInfo1 || targetInfo === maskedFormatInfo2) {\r\n                    // Found an exact match\r\n                    return new FormatInformation(decodeInfo[1]);\r\n                }\r\n                var bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo1, targetInfo);\r\n                if (bitsDifference < bestDifference) {\r\n                    bestFormatInfo = decodeInfo[1];\r\n                    bestDifference = bitsDifference;\r\n                }\r\n                if (maskedFormatInfo1 !== maskedFormatInfo2) {\r\n                    // also try the other option\r\n                    bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo2, targetInfo);\r\n                    if (bitsDifference < bestDifference) {\r\n                        bestFormatInfo = decodeInfo[1];\r\n                        bestDifference = bitsDifference;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        // Hamming distance of the 32 masked codes is 7, by construction, so <= 3 bits\r\n        // differing means we found a match\r\n        if (bestDifference <= 3) {\r\n            return new FormatInformation(bestFormatInfo);\r\n        }\r\n        return null;\r\n    };\r\n    FormatInformation.prototype.getErrorCorrectionLevel = function () {\r\n        return this.errorCorrectionLevel;\r\n    };\r\n    FormatInformation.prototype.getDataMask = function () {\r\n        return this.dataMask;\r\n    };\r\n    /*@Override*/\r\n    FormatInformation.prototype.hashCode = function () {\r\n        return (this.errorCorrectionLevel.getBits() << 3) | this.dataMask;\r\n    };\r\n    /*@Override*/\r\n    FormatInformation.prototype.equals = function (o) {\r\n        if (!(o instanceof FormatInformation)) {\r\n            return false;\r\n        }\r\n        var other = o;\r\n        return this.errorCorrectionLevel === other.errorCorrectionLevel &&\r\n            this.dataMask === other.dataMask;\r\n    };\r\n    FormatInformation.FORMAT_INFO_MASK_QR = 0x5412;\r\n    /**\r\n     * See ISO 18004:2006, Annex C, Table C.1\r\n     */\r\n    FormatInformation.FORMAT_INFO_DECODE_LOOKUP = [\r\n        Int32Array.from([0x5412, 0x00]),\r\n        Int32Array.from([0x5125, 0x01]),\r\n        Int32Array.from([0x5E7C, 0x02]),\r\n        Int32Array.from([0x5B4B, 0x03]),\r\n        Int32Array.from([0x45F9, 0x04]),\r\n        Int32Array.from([0x40CE, 0x05]),\r\n        Int32Array.from([0x4F97, 0x06]),\r\n        Int32Array.from([0x4AA0, 0x07]),\r\n        Int32Array.from([0x77C4, 0x08]),\r\n        Int32Array.from([0x72F3, 0x09]),\r\n        Int32Array.from([0x7DAA, 0x0A]),\r\n        Int32Array.from([0x789D, 0x0B]),\r\n        Int32Array.from([0x662F, 0x0C]),\r\n        Int32Array.from([0x6318, 0x0D]),\r\n        Int32Array.from([0x6C41, 0x0E]),\r\n        Int32Array.from([0x6976, 0x0F]),\r\n        Int32Array.from([0x1689, 0x10]),\r\n        Int32Array.from([0x13BE, 0x11]),\r\n        Int32Array.from([0x1CE7, 0x12]),\r\n        Int32Array.from([0x19D0, 0x13]),\r\n        Int32Array.from([0x0762, 0x14]),\r\n        Int32Array.from([0x0255, 0x15]),\r\n        Int32Array.from([0x0D0C, 0x16]),\r\n        Int32Array.from([0x083B, 0x17]),\r\n        Int32Array.from([0x355F, 0x18]),\r\n        Int32Array.from([0x3068, 0x19]),\r\n        Int32Array.from([0x3F31, 0x1A]),\r\n        Int32Array.from([0x3A06, 0x1B]),\r\n        Int32Array.from([0x24B4, 0x1C]),\r\n        Int32Array.from([0x2183, 0x1D]),\r\n        Int32Array.from([0x2EDA, 0x1E]),\r\n        Int32Array.from([0x2BED, 0x1F]),\r\n    ];\r\n    return FormatInformation;\r\n}());\r\nexports.default = FormatInformation;\r\n//# sourceMappingURL=FormatInformation.js.map"]},"metadata":{},"sourceType":"script"}
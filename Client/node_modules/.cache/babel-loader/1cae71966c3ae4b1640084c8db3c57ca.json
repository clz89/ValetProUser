{"ast":null,"code":"\"use strict\";\n/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar BitSource_1 = require(\"../../common/BitSource\");\n\nvar CharacterSetECI_1 = require(\"../../common/CharacterSetECI\");\n\nvar DecoderResult_1 = require(\"../../common/DecoderResult\");\n\nvar StringUtils_1 = require(\"../../common/StringUtils\");\n\nvar Mode_1 = require(\"./Mode\");\n\nvar StringBuilder_1 = require(\"../../util/StringBuilder\");\n\nvar StringEncoding_1 = require(\"../../util/StringEncoding\");\n\nvar FormatException_1 = require(\"../../FormatException\");\n/*import java.io.UnsupportedEncodingException;*/\n\n/*import java.util.ArrayList;*/\n\n/*import java.util.Collection;*/\n\n/*import java.util.List;*/\n\n/*import java.util.Map;*/\n\n/**\r\n * <p>QR Codes can encode text as bits in one of several modes, and can use multiple modes\r\n * in one QR Code. This class decodes the bits back into text.</p>\r\n *\r\n * <p>See ISO 18004:2006, 6.4.3 - 6.4.7</p>\r\n *\r\n * @author Sean Owen\r\n */\n\n\nvar DecodedBitStreamParser =\n/** @class */\nfunction () {\n  function DecodedBitStreamParser() {}\n\n  DecodedBitStreamParser.decode = function (bytes, version, ecLevel, hints) {\n    var bits = new BitSource_1.default(bytes);\n    var result = new StringBuilder_1.default();\n    var byteSegments = new Array(); // 1\n    // TYPESCRIPTPORT: I do not use constructor with size 1 as in original Java means capacity and the array length is checked below\n\n    var symbolSequence = -1;\n    var parityData = -1;\n\n    try {\n      var currentCharacterSetECI = null;\n      var fc1InEffect = false;\n      var mode = void 0;\n\n      do {\n        // While still another segment to read...\n        if (bits.available() < 4) {\n          // OK, assume we're done. Really, a TERMINATOR mode should have been recorded here\n          mode = Mode_1.default.TERMINATOR;\n        } else {\n          var modeBits = bits.readBits(4);\n          mode = Mode_1.default.forBits(modeBits); // mode is encoded by 4 bits\n        }\n\n        switch (mode) {\n          case Mode_1.default.TERMINATOR:\n            break;\n\n          case Mode_1.default.FNC1_FIRST_POSITION:\n          case Mode_1.default.FNC1_SECOND_POSITION:\n            // We do little with FNC1 except alter the parsed result a bit according to the spec\n            fc1InEffect = true;\n            break;\n\n          case Mode_1.default.STRUCTURED_APPEND:\n            if (bits.available() < 16) {\n              throw new FormatException_1.default();\n            } // sequence number and parity is added later to the result metadata\n            // Read next 8 bits (symbol sequence #) and 8 bits (data: parity), then continue\n\n\n            symbolSequence = bits.readBits(8);\n            parityData = bits.readBits(8);\n            break;\n\n          case Mode_1.default.ECI:\n            // Count doesn't apply to ECI\n            var value = DecodedBitStreamParser.parseECIValue(bits);\n            currentCharacterSetECI = CharacterSetECI_1.default.getCharacterSetECIByValue(value);\n\n            if (currentCharacterSetECI === null) {\n              throw new FormatException_1.default();\n            }\n\n            break;\n\n          case Mode_1.default.HANZI:\n            // First handle Hanzi mode which does not start with character count\n            // Chinese mode contains a sub set indicator right after mode indicator\n            var subset = bits.readBits(4);\n            var countHanzi = bits.readBits(mode.getCharacterCountBits(version));\n\n            if (subset === DecodedBitStreamParser.GB2312_SUBSET) {\n              DecodedBitStreamParser.decodeHanziSegment(bits, result, countHanzi);\n            }\n\n            break;\n\n          default:\n            // \"Normal\" QR code modes:\n            // How many characters will follow, encoded in this mode?\n            var count = bits.readBits(mode.getCharacterCountBits(version));\n\n            switch (mode) {\n              case Mode_1.default.NUMERIC:\n                DecodedBitStreamParser.decodeNumericSegment(bits, result, count);\n                break;\n\n              case Mode_1.default.ALPHANUMERIC:\n                DecodedBitStreamParser.decodeAlphanumericSegment(bits, result, count, fc1InEffect);\n                break;\n\n              case Mode_1.default.BYTE:\n                DecodedBitStreamParser.decodeByteSegment(bits, result, count, currentCharacterSetECI, byteSegments, hints);\n                break;\n\n              case Mode_1.default.KANJI:\n                DecodedBitStreamParser.decodeKanjiSegment(bits, result, count);\n                break;\n\n              default:\n                throw new FormatException_1.default();\n            }\n\n            break;\n        }\n      } while (mode !== Mode_1.default.TERMINATOR);\n    } catch (iae\n    /*: IllegalArgumentException*/\n    ) {\n      // from readBits() calls\n      throw new FormatException_1.default();\n    }\n\n    return new DecoderResult_1.default(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, ecLevel === null ? null : ecLevel.toString(), symbolSequence, parityData);\n  };\n  /**\r\n   * See specification GBT 18284-2000\r\n   */\n\n\n  DecodedBitStreamParser.decodeHanziSegment = function (bits, result, count\n  /*int*/\n  ) {\n    // Don't crash trying to read more bits than we have available.\n    if (count * 13 > bits.available()) {\n      throw new FormatException_1.default();\n    } // Each character will require 2 bytes. Read the characters as 2-byte pairs\n    // and decode as GB2312 afterwards\n\n\n    var buffer = new Uint8Array(2 * count);\n    var offset = 0;\n\n    while (count > 0) {\n      // Each 13 bits encodes a 2-byte character\n      var twoBytes = bits.readBits(13);\n      var assembledTwoBytes = twoBytes / 0x060 << 8 & 0xFFFFFFFF | twoBytes % 0x060;\n\n      if (assembledTwoBytes < 0x003BF) {\n        // In the 0xA1A1 to 0xAAFE range\n        assembledTwoBytes += 0x0A1A1;\n      } else {\n        // In the 0xB0A1 to 0xFAFE range\n        assembledTwoBytes += 0x0A6A1;\n      }\n\n      buffer[offset] =\n      /*(byte) */\n      assembledTwoBytes >> 8 & 0xFF;\n      buffer[offset + 1] =\n      /*(byte) */\n      assembledTwoBytes & 0xFF;\n      offset += 2;\n      count--;\n    }\n\n    try {\n      result.append(StringEncoding_1.default.decode(buffer, StringUtils_1.default.GB2312)); // TYPESCRIPTPORT: TODO: implement GB2312 decode. StringView from MDN could be a starting point\n    } catch (ignored\n    /*: UnsupportedEncodingException*/\n    ) {\n      throw new FormatException_1.default(ignored);\n    }\n  };\n\n  DecodedBitStreamParser.decodeKanjiSegment = function (bits, result, count\n  /*int*/\n  ) {\n    // Don't crash trying to read more bits than we have available.\n    if (count * 13 > bits.available()) {\n      throw new FormatException_1.default();\n    } // Each character will require 2 bytes. Read the characters as 2-byte pairs\n    // and decode as Shift_JIS afterwards\n\n\n    var buffer = new Uint8Array(2 * count);\n    var offset = 0;\n\n    while (count > 0) {\n      // Each 13 bits encodes a 2-byte character\n      var twoBytes = bits.readBits(13);\n      var assembledTwoBytes = twoBytes / 0x0C0 << 8 & 0xFFFFFFFF | twoBytes % 0x0C0;\n\n      if (assembledTwoBytes < 0x01F00) {\n        // In the 0x8140 to 0x9FFC range\n        assembledTwoBytes += 0x08140;\n      } else {\n        // In the 0xE040 to 0xEBBF range\n        assembledTwoBytes += 0x0C140;\n      }\n\n      buffer[offset] =\n      /*(byte) */\n      assembledTwoBytes >> 8;\n      buffer[offset + 1] =\n      /*(byte) */\n      assembledTwoBytes;\n      offset += 2;\n      count--;\n    } // Shift_JIS may not be supported in some environments:\n\n\n    try {\n      result.append(StringEncoding_1.default.decode(buffer, StringUtils_1.default.SHIFT_JIS)); // TYPESCRIPTPORT: TODO: implement SHIFT_JIS decode. StringView from MDN could be a starting point\n    } catch (ignored\n    /*: UnsupportedEncodingException*/\n    ) {\n      throw new FormatException_1.default(ignored);\n    }\n  };\n\n  DecodedBitStreamParser.decodeByteSegment = function (bits, result, count\n  /*int*/\n  , currentCharacterSetECI, byteSegments, hints) {\n    // Don't crash trying to read more bits than we have available.\n    if (8 * count > bits.available()) {\n      throw new FormatException_1.default();\n    }\n\n    var readBytes = new Uint8Array(count);\n\n    for (var i = 0; i < count; i++) {\n      readBytes[i] =\n      /*(byte) */\n      bits.readBits(8);\n    }\n\n    var encoding;\n\n    if (currentCharacterSetECI === null) {\n      // The spec isn't clear on this mode; see\n      // section 6.4.5: t does not say which encoding to assuming\n      // upon decoding. I have seen ISO-8859-1 used as well as\n      // Shift_JIS -- without anything like an ECI designator to\n      // give a hint.\n      encoding = StringUtils_1.default.guessEncoding(readBytes, hints);\n    } else {\n      encoding = currentCharacterSetECI.getName();\n    }\n\n    try {\n      result.append(StringEncoding_1.default.decode(readBytes, encoding));\n    } catch (ignored\n    /*: UnsupportedEncodingException*/\n    ) {\n      throw new FormatException_1.default(ignored);\n    }\n\n    byteSegments.push(readBytes);\n  };\n\n  DecodedBitStreamParser.toAlphaNumericChar = function (value\n  /*int*/\n  ) {\n    if (value >= DecodedBitStreamParser.ALPHANUMERIC_CHARS.length) {\n      throw new FormatException_1.default();\n    }\n\n    return DecodedBitStreamParser.ALPHANUMERIC_CHARS[value];\n  };\n\n  DecodedBitStreamParser.decodeAlphanumericSegment = function (bits, result, count\n  /*int*/\n  , fc1InEffect) {\n    // Read two characters at a time\n    var start = result.length();\n\n    while (count > 1) {\n      if (bits.available() < 11) {\n        throw new FormatException_1.default();\n      }\n\n      var nextTwoCharsBits = bits.readBits(11);\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(nextTwoCharsBits / 45)));\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(nextTwoCharsBits % 45));\n      count -= 2;\n    }\n\n    if (count === 1) {\n      // special case: one character left\n      if (bits.available() < 6) {\n        throw new FormatException_1.default();\n      }\n\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(bits.readBits(6)));\n    } // See section 6.4.8.1, 6.4.8.2\n\n\n    if (fc1InEffect) {\n      // We need to massage the result a bit if in an FNC1 mode:\n      for (var i = start; i < result.length(); i++) {\n        if (result.charAt(i) === '%') {\n          if (i < result.length() - 1 && result.charAt(i + 1) === '%') {\n            // %% is rendered as %\n            result.deleteCharAt(i + 1);\n          } else {\n            // In alpha mode, % should be converted to FNC1 separator 0x1D\n            result.setCharAt(i, String.fromCharCode(0x1D));\n          }\n        }\n      }\n    }\n  };\n\n  DecodedBitStreamParser.decodeNumericSegment = function (bits, result, count\n  /*int*/\n  ) {\n    // Read three digits at a time\n    while (count >= 3) {\n      // Each 10 bits encodes three digits\n      if (bits.available() < 10) {\n        throw new FormatException_1.default();\n      }\n\n      var threeDigitsBits = bits.readBits(10);\n\n      if (threeDigitsBits >= 1000) {\n        throw new FormatException_1.default();\n      }\n\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 100)));\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 10) % 10));\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(threeDigitsBits % 10));\n      count -= 3;\n    }\n\n    if (count === 2) {\n      // Two digits left over to read, encoded in 7 bits\n      if (bits.available() < 7) {\n        throw new FormatException_1.default();\n      }\n\n      var twoDigitsBits = bits.readBits(7);\n\n      if (twoDigitsBits >= 100) {\n        throw new FormatException_1.default();\n      }\n\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(twoDigitsBits / 10)));\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(twoDigitsBits % 10));\n    } else if (count === 1) {\n      // One digit left over to read\n      if (bits.available() < 4) {\n        throw new FormatException_1.default();\n      }\n\n      var digitBits = bits.readBits(4);\n\n      if (digitBits >= 10) {\n        throw new FormatException_1.default();\n      }\n\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(digitBits));\n    }\n  };\n\n  DecodedBitStreamParser.parseECIValue = function (bits) {\n    var firstByte = bits.readBits(8);\n\n    if ((firstByte & 0x80) === 0) {\n      // just one byte\n      return firstByte & 0x7F;\n    }\n\n    if ((firstByte & 0xC0) === 0x80) {\n      // two bytes\n      var secondByte = bits.readBits(8);\n      return (firstByte & 0x3F) << 8 & 0xFFFFFFFF | secondByte;\n    }\n\n    if ((firstByte & 0xE0) === 0xC0) {\n      // three bytes\n      var secondThirdBytes = bits.readBits(16);\n      return (firstByte & 0x1F) << 16 & 0xFFFFFFFF | secondThirdBytes;\n    }\n\n    throw new FormatException_1.default();\n  };\n  /**\r\n   * See ISO 18004:2006, 6.4.4 Table 5\r\n   */\n\n\n  DecodedBitStreamParser.ALPHANUMERIC_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:';\n  DecodedBitStreamParser.GB2312_SUBSET = 1;\n  return DecodedBitStreamParser;\n}();\n\nexports.default = DecodedBitStreamParser;\n\nfunction Uint8ArrayToString(a) {\n  var CHUNK_SZ = 0x8000;\n  var c = new StringBuilder_1.default();\n\n  for (var i = 0, length_1 = a.length; i < length_1; i += CHUNK_SZ) {\n    c.append(String.fromCharCode.apply(null, a.subarray(i, i + CHUNK_SZ)));\n  }\n\n  return c.toString();\n}","map":{"version":3,"sources":["../../../../src/core/qrcode/decoder/DecodedBitStreamParser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar BitSource_1 = require(\"../../common/BitSource\");\r\nvar CharacterSetECI_1 = require(\"../../common/CharacterSetECI\");\r\nvar DecoderResult_1 = require(\"../../common/DecoderResult\");\r\nvar StringUtils_1 = require(\"../../common/StringUtils\");\r\nvar Mode_1 = require(\"./Mode\");\r\nvar StringBuilder_1 = require(\"../../util/StringBuilder\");\r\nvar StringEncoding_1 = require(\"../../util/StringEncoding\");\r\nvar FormatException_1 = require(\"../../FormatException\");\r\n/*import java.io.UnsupportedEncodingException;*/\r\n/*import java.util.ArrayList;*/\r\n/*import java.util.Collection;*/\r\n/*import java.util.List;*/\r\n/*import java.util.Map;*/\r\n/**\r\n * <p>QR Codes can encode text as bits in one of several modes, and can use multiple modes\r\n * in one QR Code. This class decodes the bits back into text.</p>\r\n *\r\n * <p>See ISO 18004:2006, 6.4.3 - 6.4.7</p>\r\n *\r\n * @author Sean Owen\r\n */\r\nvar DecodedBitStreamParser = /** @class */ (function () {\r\n    function DecodedBitStreamParser() {\r\n    }\r\n    DecodedBitStreamParser.decode = function (bytes, version, ecLevel, hints) {\r\n        var bits = new BitSource_1.default(bytes);\r\n        var result = new StringBuilder_1.default();\r\n        var byteSegments = new Array(); // 1\r\n        // TYPESCRIPTPORT: I do not use constructor with size 1 as in original Java means capacity and the array length is checked below\r\n        var symbolSequence = -1;\r\n        var parityData = -1;\r\n        try {\r\n            var currentCharacterSetECI = null;\r\n            var fc1InEffect = false;\r\n            var mode = void 0;\r\n            do {\r\n                // While still another segment to read...\r\n                if (bits.available() < 4) {\r\n                    // OK, assume we're done. Really, a TERMINATOR mode should have been recorded here\r\n                    mode = Mode_1.default.TERMINATOR;\r\n                }\r\n                else {\r\n                    var modeBits = bits.readBits(4);\r\n                    mode = Mode_1.default.forBits(modeBits); // mode is encoded by 4 bits\r\n                }\r\n                switch (mode) {\r\n                    case Mode_1.default.TERMINATOR:\r\n                        break;\r\n                    case Mode_1.default.FNC1_FIRST_POSITION:\r\n                    case Mode_1.default.FNC1_SECOND_POSITION:\r\n                        // We do little with FNC1 except alter the parsed result a bit according to the spec\r\n                        fc1InEffect = true;\r\n                        break;\r\n                    case Mode_1.default.STRUCTURED_APPEND:\r\n                        if (bits.available() < 16) {\r\n                            throw new FormatException_1.default();\r\n                        }\r\n                        // sequence number and parity is added later to the result metadata\r\n                        // Read next 8 bits (symbol sequence #) and 8 bits (data: parity), then continue\r\n                        symbolSequence = bits.readBits(8);\r\n                        parityData = bits.readBits(8);\r\n                        break;\r\n                    case Mode_1.default.ECI:\r\n                        // Count doesn't apply to ECI\r\n                        var value = DecodedBitStreamParser.parseECIValue(bits);\r\n                        currentCharacterSetECI = CharacterSetECI_1.default.getCharacterSetECIByValue(value);\r\n                        if (currentCharacterSetECI === null) {\r\n                            throw new FormatException_1.default();\r\n                        }\r\n                        break;\r\n                    case Mode_1.default.HANZI:\r\n                        // First handle Hanzi mode which does not start with character count\r\n                        // Chinese mode contains a sub set indicator right after mode indicator\r\n                        var subset = bits.readBits(4);\r\n                        var countHanzi = bits.readBits(mode.getCharacterCountBits(version));\r\n                        if (subset === DecodedBitStreamParser.GB2312_SUBSET) {\r\n                            DecodedBitStreamParser.decodeHanziSegment(bits, result, countHanzi);\r\n                        }\r\n                        break;\r\n                    default:\r\n                        // \"Normal\" QR code modes:\r\n                        // How many characters will follow, encoded in this mode?\r\n                        var count = bits.readBits(mode.getCharacterCountBits(version));\r\n                        switch (mode) {\r\n                            case Mode_1.default.NUMERIC:\r\n                                DecodedBitStreamParser.decodeNumericSegment(bits, result, count);\r\n                                break;\r\n                            case Mode_1.default.ALPHANUMERIC:\r\n                                DecodedBitStreamParser.decodeAlphanumericSegment(bits, result, count, fc1InEffect);\r\n                                break;\r\n                            case Mode_1.default.BYTE:\r\n                                DecodedBitStreamParser.decodeByteSegment(bits, result, count, currentCharacterSetECI, byteSegments, hints);\r\n                                break;\r\n                            case Mode_1.default.KANJI:\r\n                                DecodedBitStreamParser.decodeKanjiSegment(bits, result, count);\r\n                                break;\r\n                            default:\r\n                                throw new FormatException_1.default();\r\n                        }\r\n                        break;\r\n                }\r\n            } while (mode !== Mode_1.default.TERMINATOR);\r\n        }\r\n        catch (iae /*: IllegalArgumentException*/) {\r\n            // from readBits() calls\r\n            throw new FormatException_1.default();\r\n        }\r\n        return new DecoderResult_1.default(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, ecLevel === null ? null : ecLevel.toString(), symbolSequence, parityData);\r\n    };\r\n    /**\r\n     * See specification GBT 18284-2000\r\n     */\r\n    DecodedBitStreamParser.decodeHanziSegment = function (bits, result, count /*int*/) {\r\n        // Don't crash trying to read more bits than we have available.\r\n        if (count * 13 > bits.available()) {\r\n            throw new FormatException_1.default();\r\n        }\r\n        // Each character will require 2 bytes. Read the characters as 2-byte pairs\r\n        // and decode as GB2312 afterwards\r\n        var buffer = new Uint8Array(2 * count);\r\n        var offset = 0;\r\n        while (count > 0) {\r\n            // Each 13 bits encodes a 2-byte character\r\n            var twoBytes = bits.readBits(13);\r\n            var assembledTwoBytes = (((twoBytes / 0x060) << 8) & 0xFFFFFFFF) | (twoBytes % 0x060);\r\n            if (assembledTwoBytes < 0x003BF) {\r\n                // In the 0xA1A1 to 0xAAFE range\r\n                assembledTwoBytes += 0x0A1A1;\r\n            }\r\n            else {\r\n                // In the 0xB0A1 to 0xFAFE range\r\n                assembledTwoBytes += 0x0A6A1;\r\n            }\r\n            buffer[offset] = /*(byte) */ ((assembledTwoBytes >> 8) & 0xFF);\r\n            buffer[offset + 1] = /*(byte) */ (assembledTwoBytes & 0xFF);\r\n            offset += 2;\r\n            count--;\r\n        }\r\n        try {\r\n            result.append(StringEncoding_1.default.decode(buffer, StringUtils_1.default.GB2312));\r\n            // TYPESCRIPTPORT: TODO: implement GB2312 decode. StringView from MDN could be a starting point\r\n        }\r\n        catch (ignored /*: UnsupportedEncodingException*/) {\r\n            throw new FormatException_1.default(ignored);\r\n        }\r\n    };\r\n    DecodedBitStreamParser.decodeKanjiSegment = function (bits, result, count /*int*/) {\r\n        // Don't crash trying to read more bits than we have available.\r\n        if (count * 13 > bits.available()) {\r\n            throw new FormatException_1.default();\r\n        }\r\n        // Each character will require 2 bytes. Read the characters as 2-byte pairs\r\n        // and decode as Shift_JIS afterwards\r\n        var buffer = new Uint8Array(2 * count);\r\n        var offset = 0;\r\n        while (count > 0) {\r\n            // Each 13 bits encodes a 2-byte character\r\n            var twoBytes = bits.readBits(13);\r\n            var assembledTwoBytes = (((twoBytes / 0x0C0) << 8) & 0xFFFFFFFF) | (twoBytes % 0x0C0);\r\n            if (assembledTwoBytes < 0x01F00) {\r\n                // In the 0x8140 to 0x9FFC range\r\n                assembledTwoBytes += 0x08140;\r\n            }\r\n            else {\r\n                // In the 0xE040 to 0xEBBF range\r\n                assembledTwoBytes += 0x0C140;\r\n            }\r\n            buffer[offset] = /*(byte) */ (assembledTwoBytes >> 8);\r\n            buffer[offset + 1] = /*(byte) */ assembledTwoBytes;\r\n            offset += 2;\r\n            count--;\r\n        }\r\n        // Shift_JIS may not be supported in some environments:\r\n        try {\r\n            result.append(StringEncoding_1.default.decode(buffer, StringUtils_1.default.SHIFT_JIS));\r\n            // TYPESCRIPTPORT: TODO: implement SHIFT_JIS decode. StringView from MDN could be a starting point\r\n        }\r\n        catch (ignored /*: UnsupportedEncodingException*/) {\r\n            throw new FormatException_1.default(ignored);\r\n        }\r\n    };\r\n    DecodedBitStreamParser.decodeByteSegment = function (bits, result, count /*int*/, currentCharacterSetECI, byteSegments, hints) {\r\n        // Don't crash trying to read more bits than we have available.\r\n        if (8 * count > bits.available()) {\r\n            throw new FormatException_1.default();\r\n        }\r\n        var readBytes = new Uint8Array(count);\r\n        for (var i = 0; i < count; i++) {\r\n            readBytes[i] = /*(byte) */ bits.readBits(8);\r\n        }\r\n        var encoding;\r\n        if (currentCharacterSetECI === null) {\r\n            // The spec isn't clear on this mode; see\r\n            // section 6.4.5: t does not say which encoding to assuming\r\n            // upon decoding. I have seen ISO-8859-1 used as well as\r\n            // Shift_JIS -- without anything like an ECI designator to\r\n            // give a hint.\r\n            encoding = StringUtils_1.default.guessEncoding(readBytes, hints);\r\n        }\r\n        else {\r\n            encoding = currentCharacterSetECI.getName();\r\n        }\r\n        try {\r\n            result.append(StringEncoding_1.default.decode(readBytes, encoding));\r\n        }\r\n        catch (ignored /*: UnsupportedEncodingException*/) {\r\n            throw new FormatException_1.default(ignored);\r\n        }\r\n        byteSegments.push(readBytes);\r\n    };\r\n    DecodedBitStreamParser.toAlphaNumericChar = function (value /*int*/) {\r\n        if (value >= DecodedBitStreamParser.ALPHANUMERIC_CHARS.length) {\r\n            throw new FormatException_1.default();\r\n        }\r\n        return DecodedBitStreamParser.ALPHANUMERIC_CHARS[value];\r\n    };\r\n    DecodedBitStreamParser.decodeAlphanumericSegment = function (bits, result, count /*int*/, fc1InEffect) {\r\n        // Read two characters at a time\r\n        var start = result.length();\r\n        while (count > 1) {\r\n            if (bits.available() < 11) {\r\n                throw new FormatException_1.default();\r\n            }\r\n            var nextTwoCharsBits = bits.readBits(11);\r\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(nextTwoCharsBits / 45)));\r\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(nextTwoCharsBits % 45));\r\n            count -= 2;\r\n        }\r\n        if (count === 1) {\r\n            // special case: one character left\r\n            if (bits.available() < 6) {\r\n                throw new FormatException_1.default();\r\n            }\r\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(bits.readBits(6)));\r\n        }\r\n        // See section 6.4.8.1, 6.4.8.2\r\n        if (fc1InEffect) {\r\n            // We need to massage the result a bit if in an FNC1 mode:\r\n            for (var i = start; i < result.length(); i++) {\r\n                if (result.charAt(i) === '%') {\r\n                    if (i < result.length() - 1 && result.charAt(i + 1) === '%') {\r\n                        // %% is rendered as %\r\n                        result.deleteCharAt(i + 1);\r\n                    }\r\n                    else {\r\n                        // In alpha mode, % should be converted to FNC1 separator 0x1D\r\n                        result.setCharAt(i, String.fromCharCode(0x1D));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    DecodedBitStreamParser.decodeNumericSegment = function (bits, result, count /*int*/) {\r\n        // Read three digits at a time\r\n        while (count >= 3) {\r\n            // Each 10 bits encodes three digits\r\n            if (bits.available() < 10) {\r\n                throw new FormatException_1.default();\r\n            }\r\n            var threeDigitsBits = bits.readBits(10);\r\n            if (threeDigitsBits >= 1000) {\r\n                throw new FormatException_1.default();\r\n            }\r\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 100)));\r\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 10) % 10));\r\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(threeDigitsBits % 10));\r\n            count -= 3;\r\n        }\r\n        if (count === 2) {\r\n            // Two digits left over to read, encoded in 7 bits\r\n            if (bits.available() < 7) {\r\n                throw new FormatException_1.default();\r\n            }\r\n            var twoDigitsBits = bits.readBits(7);\r\n            if (twoDigitsBits >= 100) {\r\n                throw new FormatException_1.default();\r\n            }\r\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(twoDigitsBits / 10)));\r\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(twoDigitsBits % 10));\r\n        }\r\n        else if (count === 1) {\r\n            // One digit left over to read\r\n            if (bits.available() < 4) {\r\n                throw new FormatException_1.default();\r\n            }\r\n            var digitBits = bits.readBits(4);\r\n            if (digitBits >= 10) {\r\n                throw new FormatException_1.default();\r\n            }\r\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(digitBits));\r\n        }\r\n    };\r\n    DecodedBitStreamParser.parseECIValue = function (bits) {\r\n        var firstByte = bits.readBits(8);\r\n        if ((firstByte & 0x80) === 0) {\r\n            // just one byte\r\n            return firstByte & 0x7F;\r\n        }\r\n        if ((firstByte & 0xC0) === 0x80) {\r\n            // two bytes\r\n            var secondByte = bits.readBits(8);\r\n            return (((firstByte & 0x3F) << 8) & 0xFFFFFFFF) | secondByte;\r\n        }\r\n        if ((firstByte & 0xE0) === 0xC0) {\r\n            // three bytes\r\n            var secondThirdBytes = bits.readBits(16);\r\n            return (((firstByte & 0x1F) << 16) & 0xFFFFFFFF) | secondThirdBytes;\r\n        }\r\n        throw new FormatException_1.default();\r\n    };\r\n    /**\r\n     * See ISO 18004:2006, 6.4.4 Table 5\r\n     */\r\n    DecodedBitStreamParser.ALPHANUMERIC_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:';\r\n    DecodedBitStreamParser.GB2312_SUBSET = 1;\r\n    return DecodedBitStreamParser;\r\n}());\r\nexports.default = DecodedBitStreamParser;\r\nfunction Uint8ArrayToString(a) {\r\n    var CHUNK_SZ = 0x8000;\r\n    var c = new StringBuilder_1.default();\r\n    for (var i = 0, length_1 = a.length; i < length_1; i += CHUNK_SZ) {\r\n        c.append(String.fromCharCode.apply(null, a.subarray(i, i + CHUNK_SZ)));\r\n    }\r\n    return c.toString();\r\n}\r\n//# sourceMappingURL=DecodedBitStreamParser.js.map"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n/*\r\n * Copyright 2010 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.common.detector {*/\n\nvar ResultPoint_1 = require(\"../../ResultPoint\");\n\nvar MathUtils_1 = require(\"./MathUtils\");\n\nvar NotFoundException_1 = require(\"../../NotFoundException\");\n/**\r\n * <p>\r\n * Detects a candidate barcode-like rectangular region within an image. It\r\n * starts around the center of the image, increases the size of the candidate\r\n * region until it finds a white rectangular region. By keeping track of the\r\n * last black points it encountered, it determines the corners of the barcode.\r\n * </p>\r\n *\r\n * @author David Olivier\r\n */\n\n\nvar WhiteRectangleDetector =\n/** @class */\nfunction () {\n  // public constructor(private image: BitMatrix) /*throws NotFoundException*/ {\n  //   this(image, INIT_SIZE, image.getWidth() / 2, image.getHeight() / 2)\n  // }\n\n  /**\r\n   * @param image barcode image to find a rectangle in\r\n   * @param initSize initial size of search area around center\r\n   * @param x x position of search center\r\n   * @param y y position of search center\r\n   * @throws NotFoundException if image is too small to accommodate {@code initSize}\r\n   */\n  function WhiteRectangleDetector(image, initSize\n  /*int*/\n  , x\n  /*int*/\n  , y\n  /*int*/\n  ) {\n    this.image = image;\n    this.height = image.getHeight();\n    this.width = image.getWidth();\n\n    if (undefined === initSize || null === initSize) {\n      initSize = WhiteRectangleDetector.INIT_SIZE;\n    }\n\n    if (undefined === x || null === x) {\n      x = image.getWidth() / 2 | 0;\n    }\n\n    if (undefined === y || null === y) {\n      y = image.getHeight() / 2 | 0;\n    }\n\n    var halfsize = initSize / 2 | 0;\n    this.leftInit = x - halfsize;\n    this.rightInit = x + halfsize;\n    this.upInit = y - halfsize;\n    this.downInit = y + halfsize;\n\n    if (this.upInit < 0 || this.leftInit < 0 || this.downInit >= this.height || this.rightInit >= this.width) {\n      throw new NotFoundException_1.default();\n    }\n  }\n  /**\r\n   * <p>\r\n   * Detects a candidate barcode-like rectangular region within an image. It\r\n   * starts around the center of the image, increases the size of the candidate\r\n   * region until it finds a white rectangular region.\r\n   * </p>\r\n   *\r\n   * @return {@link ResultPoint}[] describing the corners of the rectangular\r\n   *         region. The first and last points are opposed on the diagonal, as\r\n   *         are the second and third. The first point will be the topmost\r\n   *         point and the last, the bottommost. The second point will be\r\n   *         leftmost and the third, the rightmost\r\n   * @throws NotFoundException if no Data Matrix Code can be found\r\n   */\n\n\n  WhiteRectangleDetector.prototype.detect = function () {\n    var left = this.leftInit;\n    var right = this.rightInit;\n    var up = this.upInit;\n    var down = this.downInit;\n    var sizeExceeded = false;\n    var aBlackPointFoundOnBorder = true;\n    var atLeastOneBlackPointFoundOnBorder = false;\n    var atLeastOneBlackPointFoundOnRight = false;\n    var atLeastOneBlackPointFoundOnBottom = false;\n    var atLeastOneBlackPointFoundOnLeft = false;\n    var atLeastOneBlackPointFoundOnTop = false;\n    var width = this.width;\n    var height = this.height;\n\n    while (aBlackPointFoundOnBorder) {\n      aBlackPointFoundOnBorder = false; // .....\n      // .   |\n      // .....\n\n      var rightBorderNotWhite = true;\n\n      while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < width) {\n        rightBorderNotWhite = this.containsBlackPoint(up, down, right, false);\n\n        if (rightBorderNotWhite) {\n          right++;\n          aBlackPointFoundOnBorder = true;\n          atLeastOneBlackPointFoundOnRight = true;\n        } else if (!atLeastOneBlackPointFoundOnRight) {\n          right++;\n        }\n      }\n\n      if (right >= width) {\n        sizeExceeded = true;\n        break;\n      } // .....\n      // .   .\n      // .___.\n\n\n      var bottomBorderNotWhite = true;\n\n      while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height) {\n        bottomBorderNotWhite = this.containsBlackPoint(left, right, down, true);\n\n        if (bottomBorderNotWhite) {\n          down++;\n          aBlackPointFoundOnBorder = true;\n          atLeastOneBlackPointFoundOnBottom = true;\n        } else if (!atLeastOneBlackPointFoundOnBottom) {\n          down++;\n        }\n      }\n\n      if (down >= height) {\n        sizeExceeded = true;\n        break;\n      } // .....\n      // |   .\n      // .....\n\n\n      var leftBorderNotWhite = true;\n\n      while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0) {\n        leftBorderNotWhite = this.containsBlackPoint(up, down, left, false);\n\n        if (leftBorderNotWhite) {\n          left--;\n          aBlackPointFoundOnBorder = true;\n          atLeastOneBlackPointFoundOnLeft = true;\n        } else if (!atLeastOneBlackPointFoundOnLeft) {\n          left--;\n        }\n      }\n\n      if (left < 0) {\n        sizeExceeded = true;\n        break;\n      } // .___.\n      // .   .\n      // .....\n\n\n      var topBorderNotWhite = true;\n\n      while ((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0) {\n        topBorderNotWhite = this.containsBlackPoint(left, right, up, true);\n\n        if (topBorderNotWhite) {\n          up--;\n          aBlackPointFoundOnBorder = true;\n          atLeastOneBlackPointFoundOnTop = true;\n        } else if (!atLeastOneBlackPointFoundOnTop) {\n          up--;\n        }\n      }\n\n      if (up < 0) {\n        sizeExceeded = true;\n        break;\n      }\n\n      if (aBlackPointFoundOnBorder) {\n        atLeastOneBlackPointFoundOnBorder = true;\n      }\n    }\n\n    if (!sizeExceeded && atLeastOneBlackPointFoundOnBorder) {\n      var maxSize = right - left;\n      var z = null;\n\n      for (var i = 1; z === null && i < maxSize; i++) {\n        z = this.getBlackPointOnSegment(left, down - i, left + i, down);\n      }\n\n      if (z == null) {\n        throw new NotFoundException_1.default();\n      }\n\n      var t = null; // go down right\n\n      for (var i = 1; t === null && i < maxSize; i++) {\n        t = this.getBlackPointOnSegment(left, up + i, left + i, up);\n      }\n\n      if (t == null) {\n        throw new NotFoundException_1.default();\n      }\n\n      var x = null; // go down left\n\n      for (var i = 1; x === null && i < maxSize; i++) {\n        x = this.getBlackPointOnSegment(right, up + i, right - i, up);\n      }\n\n      if (x == null) {\n        throw new NotFoundException_1.default();\n      }\n\n      var y = null; // go up left\n\n      for (var i = 1; y === null && i < maxSize; i++) {\n        y = this.getBlackPointOnSegment(right, down - i, right - i, down);\n      }\n\n      if (y == null) {\n        throw new NotFoundException_1.default();\n      }\n\n      return this.centerEdges(y, z, x, t);\n    } else {\n      throw new NotFoundException_1.default();\n    }\n  };\n\n  WhiteRectangleDetector.prototype.getBlackPointOnSegment = function (aX\n  /*float*/\n  , aY\n  /*float*/\n  , bX\n  /*float*/\n  , bY\n  /*float*/\n  ) {\n    var dist = MathUtils_1.default.round(MathUtils_1.default.distance(aX, aY, bX, bY));\n    var xStep = (bX - aX) / dist;\n    var yStep = (bY - aY) / dist;\n    var image = this.image;\n\n    for (var i = 0; i < dist; i++) {\n      var x = MathUtils_1.default.round(aX + i * xStep);\n      var y = MathUtils_1.default.round(aY + i * yStep);\n\n      if (image.get(x, y)) {\n        return new ResultPoint_1.default(x, y);\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * recenters the points of a constant distance towards the center\r\n   *\r\n   * @param y bottom most point\r\n   * @param z left most point\r\n   * @param x right most point\r\n   * @param t top most point\r\n   * @return {@link ResultPoint}[] describing the corners of the rectangular\r\n   *         region. The first and last points are opposed on the diagonal, as\r\n   *         are the second and third. The first point will be the topmost\r\n   *         point and the last, the bottommost. The second point will be\r\n   *         leftmost and the third, the rightmost\r\n   */\n\n\n  WhiteRectangleDetector.prototype.centerEdges = function (y, z, x, t) {\n    //\n    //       t            t\n    //  z                      x\n    //        x    OR    z\n    //   y                    y\n    //\n    var yi = y.getX();\n    var yj = y.getY();\n    var zi = z.getX();\n    var zj = z.getY();\n    var xi = x.getX();\n    var xj = x.getY();\n    var ti = t.getX();\n    var tj = t.getY();\n    var CORR = WhiteRectangleDetector.CORR;\n\n    if (yi < this.width / 2.0) {\n      return [new ResultPoint_1.default(ti - CORR, tj + CORR), new ResultPoint_1.default(zi + CORR, zj + CORR), new ResultPoint_1.default(xi - CORR, xj - CORR), new ResultPoint_1.default(yi + CORR, yj - CORR)];\n    } else {\n      return [new ResultPoint_1.default(ti + CORR, tj + CORR), new ResultPoint_1.default(zi + CORR, zj - CORR), new ResultPoint_1.default(xi - CORR, xj + CORR), new ResultPoint_1.default(yi - CORR, yj - CORR)];\n    }\n  };\n  /**\r\n   * Determines whether a segment contains a black point\r\n   *\r\n   * @param a          min value of the scanned coordinate\r\n   * @param b          max value of the scanned coordinate\r\n   * @param fixed      value of fixed coordinate\r\n   * @param horizontal set to true if scan must be horizontal, false if vertical\r\n   * @return true if a black point has been found, else false.\r\n   */\n\n\n  WhiteRectangleDetector.prototype.containsBlackPoint = function (a\n  /*int*/\n  , b\n  /*int*/\n  , fixed\n  /*int*/\n  , horizontal) {\n    var image = this.image;\n\n    if (horizontal) {\n      for (var x = a; x <= b; x++) {\n        if (image.get(x, fixed)) {\n          return true;\n        }\n      }\n    } else {\n      for (var y = a; y <= b; y++) {\n        if (image.get(fixed, y)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  WhiteRectangleDetector.INIT_SIZE = 10;\n  WhiteRectangleDetector.CORR = 1;\n  return WhiteRectangleDetector;\n}();\n\nexports.default = WhiteRectangleDetector;","map":{"version":3,"sources":["../../../../src/core/common/detector/WhiteRectangleDetector.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/*\r\n * Copyright 2010 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*namespace com.google.zxing.common.detector {*/\r\nvar ResultPoint_1 = require(\"../../ResultPoint\");\r\nvar MathUtils_1 = require(\"./MathUtils\");\r\nvar NotFoundException_1 = require(\"../../NotFoundException\");\r\n/**\r\n * <p>\r\n * Detects a candidate barcode-like rectangular region within an image. It\r\n * starts around the center of the image, increases the size of the candidate\r\n * region until it finds a white rectangular region. By keeping track of the\r\n * last black points it encountered, it determines the corners of the barcode.\r\n * </p>\r\n *\r\n * @author David Olivier\r\n */\r\nvar WhiteRectangleDetector = /** @class */ (function () {\r\n    // public constructor(private image: BitMatrix) /*throws NotFoundException*/ {\r\n    //   this(image, INIT_SIZE, image.getWidth() / 2, image.getHeight() / 2)\r\n    // }\r\n    /**\r\n     * @param image barcode image to find a rectangle in\r\n     * @param initSize initial size of search area around center\r\n     * @param x x position of search center\r\n     * @param y y position of search center\r\n     * @throws NotFoundException if image is too small to accommodate {@code initSize}\r\n     */\r\n    function WhiteRectangleDetector(image, initSize /*int*/, x /*int*/, y /*int*/) {\r\n        this.image = image;\r\n        this.height = image.getHeight();\r\n        this.width = image.getWidth();\r\n        if (undefined === initSize || null === initSize) {\r\n            initSize = WhiteRectangleDetector.INIT_SIZE;\r\n        }\r\n        if (undefined === x || null === x) {\r\n            x = image.getWidth() / 2 | 0;\r\n        }\r\n        if (undefined === y || null === y) {\r\n            y = image.getHeight() / 2 | 0;\r\n        }\r\n        var halfsize = initSize / 2 | 0;\r\n        this.leftInit = x - halfsize;\r\n        this.rightInit = x + halfsize;\r\n        this.upInit = y - halfsize;\r\n        this.downInit = y + halfsize;\r\n        if (this.upInit < 0 || this.leftInit < 0 || this.downInit >= this.height || this.rightInit >= this.width) {\r\n            throw new NotFoundException_1.default();\r\n        }\r\n    }\r\n    /**\r\n     * <p>\r\n     * Detects a candidate barcode-like rectangular region within an image. It\r\n     * starts around the center of the image, increases the size of the candidate\r\n     * region until it finds a white rectangular region.\r\n     * </p>\r\n     *\r\n     * @return {@link ResultPoint}[] describing the corners of the rectangular\r\n     *         region. The first and last points are opposed on the diagonal, as\r\n     *         are the second and third. The first point will be the topmost\r\n     *         point and the last, the bottommost. The second point will be\r\n     *         leftmost and the third, the rightmost\r\n     * @throws NotFoundException if no Data Matrix Code can be found\r\n     */\r\n    WhiteRectangleDetector.prototype.detect = function () {\r\n        var left = this.leftInit;\r\n        var right = this.rightInit;\r\n        var up = this.upInit;\r\n        var down = this.downInit;\r\n        var sizeExceeded = false;\r\n        var aBlackPointFoundOnBorder = true;\r\n        var atLeastOneBlackPointFoundOnBorder = false;\r\n        var atLeastOneBlackPointFoundOnRight = false;\r\n        var atLeastOneBlackPointFoundOnBottom = false;\r\n        var atLeastOneBlackPointFoundOnLeft = false;\r\n        var atLeastOneBlackPointFoundOnTop = false;\r\n        var width = this.width;\r\n        var height = this.height;\r\n        while (aBlackPointFoundOnBorder) {\r\n            aBlackPointFoundOnBorder = false;\r\n            // .....\r\n            // .   |\r\n            // .....\r\n            var rightBorderNotWhite = true;\r\n            while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < width) {\r\n                rightBorderNotWhite = this.containsBlackPoint(up, down, right, false);\r\n                if (rightBorderNotWhite) {\r\n                    right++;\r\n                    aBlackPointFoundOnBorder = true;\r\n                    atLeastOneBlackPointFoundOnRight = true;\r\n                }\r\n                else if (!atLeastOneBlackPointFoundOnRight) {\r\n                    right++;\r\n                }\r\n            }\r\n            if (right >= width) {\r\n                sizeExceeded = true;\r\n                break;\r\n            }\r\n            // .....\r\n            // .   .\r\n            // .___.\r\n            var bottomBorderNotWhite = true;\r\n            while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height) {\r\n                bottomBorderNotWhite = this.containsBlackPoint(left, right, down, true);\r\n                if (bottomBorderNotWhite) {\r\n                    down++;\r\n                    aBlackPointFoundOnBorder = true;\r\n                    atLeastOneBlackPointFoundOnBottom = true;\r\n                }\r\n                else if (!atLeastOneBlackPointFoundOnBottom) {\r\n                    down++;\r\n                }\r\n            }\r\n            if (down >= height) {\r\n                sizeExceeded = true;\r\n                break;\r\n            }\r\n            // .....\r\n            // |   .\r\n            // .....\r\n            var leftBorderNotWhite = true;\r\n            while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0) {\r\n                leftBorderNotWhite = this.containsBlackPoint(up, down, left, false);\r\n                if (leftBorderNotWhite) {\r\n                    left--;\r\n                    aBlackPointFoundOnBorder = true;\r\n                    atLeastOneBlackPointFoundOnLeft = true;\r\n                }\r\n                else if (!atLeastOneBlackPointFoundOnLeft) {\r\n                    left--;\r\n                }\r\n            }\r\n            if (left < 0) {\r\n                sizeExceeded = true;\r\n                break;\r\n            }\r\n            // .___.\r\n            // .   .\r\n            // .....\r\n            var topBorderNotWhite = true;\r\n            while ((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0) {\r\n                topBorderNotWhite = this.containsBlackPoint(left, right, up, true);\r\n                if (topBorderNotWhite) {\r\n                    up--;\r\n                    aBlackPointFoundOnBorder = true;\r\n                    atLeastOneBlackPointFoundOnTop = true;\r\n                }\r\n                else if (!atLeastOneBlackPointFoundOnTop) {\r\n                    up--;\r\n                }\r\n            }\r\n            if (up < 0) {\r\n                sizeExceeded = true;\r\n                break;\r\n            }\r\n            if (aBlackPointFoundOnBorder) {\r\n                atLeastOneBlackPointFoundOnBorder = true;\r\n            }\r\n        }\r\n        if (!sizeExceeded && atLeastOneBlackPointFoundOnBorder) {\r\n            var maxSize = right - left;\r\n            var z = null;\r\n            for (var i = 1; z === null && i < maxSize; i++) {\r\n                z = this.getBlackPointOnSegment(left, down - i, left + i, down);\r\n            }\r\n            if (z == null) {\r\n                throw new NotFoundException_1.default();\r\n            }\r\n            var t = null;\r\n            // go down right\r\n            for (var i = 1; t === null && i < maxSize; i++) {\r\n                t = this.getBlackPointOnSegment(left, up + i, left + i, up);\r\n            }\r\n            if (t == null) {\r\n                throw new NotFoundException_1.default();\r\n            }\r\n            var x = null;\r\n            // go down left\r\n            for (var i = 1; x === null && i < maxSize; i++) {\r\n                x = this.getBlackPointOnSegment(right, up + i, right - i, up);\r\n            }\r\n            if (x == null) {\r\n                throw new NotFoundException_1.default();\r\n            }\r\n            var y = null;\r\n            // go up left\r\n            for (var i = 1; y === null && i < maxSize; i++) {\r\n                y = this.getBlackPointOnSegment(right, down - i, right - i, down);\r\n            }\r\n            if (y == null) {\r\n                throw new NotFoundException_1.default();\r\n            }\r\n            return this.centerEdges(y, z, x, t);\r\n        }\r\n        else {\r\n            throw new NotFoundException_1.default();\r\n        }\r\n    };\r\n    WhiteRectangleDetector.prototype.getBlackPointOnSegment = function (aX /*float*/, aY /*float*/, bX /*float*/, bY /*float*/) {\r\n        var dist = MathUtils_1.default.round(MathUtils_1.default.distance(aX, aY, bX, bY));\r\n        var xStep = (bX - aX) / dist;\r\n        var yStep = (bY - aY) / dist;\r\n        var image = this.image;\r\n        for (var i = 0; i < dist; i++) {\r\n            var x = MathUtils_1.default.round(aX + i * xStep);\r\n            var y = MathUtils_1.default.round(aY + i * yStep);\r\n            if (image.get(x, y)) {\r\n                return new ResultPoint_1.default(x, y);\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * recenters the points of a constant distance towards the center\r\n     *\r\n     * @param y bottom most point\r\n     * @param z left most point\r\n     * @param x right most point\r\n     * @param t top most point\r\n     * @return {@link ResultPoint}[] describing the corners of the rectangular\r\n     *         region. The first and last points are opposed on the diagonal, as\r\n     *         are the second and third. The first point will be the topmost\r\n     *         point and the last, the bottommost. The second point will be\r\n     *         leftmost and the third, the rightmost\r\n     */\r\n    WhiteRectangleDetector.prototype.centerEdges = function (y, z, x, t) {\r\n        //\r\n        //       t            t\r\n        //  z                      x\r\n        //        x    OR    z\r\n        //   y                    y\r\n        //\r\n        var yi = y.getX();\r\n        var yj = y.getY();\r\n        var zi = z.getX();\r\n        var zj = z.getY();\r\n        var xi = x.getX();\r\n        var xj = x.getY();\r\n        var ti = t.getX();\r\n        var tj = t.getY();\r\n        var CORR = WhiteRectangleDetector.CORR;\r\n        if (yi < this.width / 2.0) {\r\n            return [\r\n                new ResultPoint_1.default(ti - CORR, tj + CORR),\r\n                new ResultPoint_1.default(zi + CORR, zj + CORR),\r\n                new ResultPoint_1.default(xi - CORR, xj - CORR),\r\n                new ResultPoint_1.default(yi + CORR, yj - CORR)\r\n            ];\r\n        }\r\n        else {\r\n            return [\r\n                new ResultPoint_1.default(ti + CORR, tj + CORR),\r\n                new ResultPoint_1.default(zi + CORR, zj - CORR),\r\n                new ResultPoint_1.default(xi - CORR, xj + CORR),\r\n                new ResultPoint_1.default(yi - CORR, yj - CORR)\r\n            ];\r\n        }\r\n    };\r\n    /**\r\n     * Determines whether a segment contains a black point\r\n     *\r\n     * @param a          min value of the scanned coordinate\r\n     * @param b          max value of the scanned coordinate\r\n     * @param fixed      value of fixed coordinate\r\n     * @param horizontal set to true if scan must be horizontal, false if vertical\r\n     * @return true if a black point has been found, else false.\r\n     */\r\n    WhiteRectangleDetector.prototype.containsBlackPoint = function (a /*int*/, b /*int*/, fixed /*int*/, horizontal) {\r\n        var image = this.image;\r\n        if (horizontal) {\r\n            for (var x = a; x <= b; x++) {\r\n                if (image.get(x, fixed)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (var y = a; y <= b; y++) {\r\n                if (image.get(fixed, y)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    WhiteRectangleDetector.INIT_SIZE = 10;\r\n    WhiteRectangleDetector.CORR = 1;\r\n    return WhiteRectangleDetector;\r\n}());\r\nexports.default = WhiteRectangleDetector;\r\n//# sourceMappingURL=WhiteRectangleDetector.js.map"]},"metadata":{},"sourceType":"script"}
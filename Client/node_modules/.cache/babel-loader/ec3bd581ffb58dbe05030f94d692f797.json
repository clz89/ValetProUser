{"ast":null,"code":"\"use strict\";\n/*\r\n * Copyright 2008 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.qrcode.encoder {*/\n\nvar EncodeHintType_1 = require(\"../../EncodeHintType\");\n\nvar BitArray_1 = require(\"../../common/BitArray\");\n\nvar CharacterSetECI_1 = require(\"../../common/CharacterSetECI\");\n\nvar GenericGF_1 = require(\"../../common/reedsolomon/GenericGF\");\n\nvar ReedSolomonEncoder_1 = require(\"../../common/reedsolomon/ReedSolomonEncoder\");\n\nvar Mode_1 = require(\"../decoder/Mode\");\n\nvar Version_1 = require(\"../decoder/Version\");\n\nvar MaskUtil_1 = require(\"./MaskUtil\");\n\nvar ByteMatrix_1 = require(\"./ByteMatrix\");\n\nvar QRCode_1 = require(\"./QRCode\");\n\nvar MatrixUtil_1 = require(\"./MatrixUtil\");\n\nvar StringEncoding_1 = require(\"../../util/StringEncoding\");\n\nvar BlockPair_1 = require(\"./BlockPair\");\n\nvar WriterException_1 = require(\"../../WriterException\");\n/*import java.io.UnsupportedEncodingException;*/\n\n/*import java.util.ArrayList;*/\n\n/*import java.util.Collection;*/\n\n/*import java.util.Map;*/\n\n/**\r\n * @author satorux@google.com (Satoru Takabayashi) - creator\r\n * @author dswitkin@google.com (Daniel Switkin) - ported from C++\r\n */\n\n\nvar Encoder =\n/** @class */\nfunction () {\n  // TYPESCRIPTPORT: changed to UTF8, the default for js\n  function Encoder() {} // The mask penalty calculation is complicated.  See Table 21 of JISX0510:2004 (p.45) for details.\n  // Basically it applies four rules and summate all penalties.\n\n\n  Encoder.calculateMaskPenalty = function (matrix) {\n    return MaskUtil_1.default.applyMaskPenaltyRule1(matrix) + MaskUtil_1.default.applyMaskPenaltyRule2(matrix) + MaskUtil_1.default.applyMaskPenaltyRule3(matrix) + MaskUtil_1.default.applyMaskPenaltyRule4(matrix);\n  };\n  /**\r\n   * @param content text to encode\r\n   * @param ecLevel error correction level to use\r\n   * @return {@link QRCode} representing the encoded QR code\r\n   * @throws WriterException if encoding can't succeed, because of for example invalid content\r\n   *   or configuration\r\n   */\n  // public static encode(content: string, ecLevel: ErrorCorrectionLevel): QRCode /*throws WriterException*/ {\n  //   return encode(content, ecLevel, null)\n  // }\n\n\n  Encoder.encode = function (content, ecLevel, hints) {\n    if (hints === void 0) {\n      hints = null;\n    } // Determine what character encoding has been specified by the caller, if any\n\n\n    var encoding = Encoder.DEFAULT_BYTE_MODE_ENCODING;\n    var hasEncodingHint = hints !== null && undefined !== hints.get(EncodeHintType_1.default.CHARACTER_SET);\n\n    if (hasEncodingHint) {\n      encoding = hints.get(EncodeHintType_1.default.CHARACTER_SET).toString();\n    } // Pick an encoding mode appropriate for the content. Note that this will not attempt to use\n    // multiple modes / segments even if that were more efficient. Twould be nice.\n\n\n    var mode = this.chooseMode(content, encoding); // This will store the header information, like mode and\n    // length, as well as \"header\" segments like an ECI segment.\n\n    var headerBits = new BitArray_1.default(); // Append ECI segment if applicable\n\n    if (mode === Mode_1.default.BYTE && (hasEncodingHint || Encoder.DEFAULT_BYTE_MODE_ENCODING !== encoding)) {\n      var eci = CharacterSetECI_1.default.getCharacterSetECIByName(encoding);\n\n      if (eci !== undefined) {\n        this.appendECI(eci, headerBits);\n      }\n    } // (With ECI in place,) Write the mode marker\n\n\n    this.appendModeInfo(mode, headerBits); // Collect data within the main segment, separately, to count its size if needed. Don't add it to\n    // main payload yet.\n\n    var dataBits = new BitArray_1.default();\n    this.appendBytes(content, mode, dataBits, encoding);\n    var version;\n\n    if (hints !== null && undefined !== hints.get(EncodeHintType_1.default.QR_VERSION)) {\n      var versionNumber = Number.parseInt(hints.get(EncodeHintType_1.default.QR_VERSION).toString(), 10);\n      version = Version_1.default.getVersionForNumber(versionNumber);\n      var bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, version);\n\n      if (!this.willFit(bitsNeeded, version, ecLevel)) {\n        throw new WriterException_1.default('Data too big for requested version');\n      }\n    } else {\n      version = this.recommendVersion(ecLevel, mode, headerBits, dataBits);\n    }\n\n    var headerAndDataBits = new BitArray_1.default();\n    headerAndDataBits.appendBitArray(headerBits); // Find \"length\" of main segment and write it\n\n    var numLetters = mode === Mode_1.default.BYTE ? dataBits.getSizeInBytes() : content.length;\n    this.appendLengthInfo(numLetters, version, mode, headerAndDataBits); // Put data together into the overall payload\n\n    headerAndDataBits.appendBitArray(dataBits);\n    var ecBlocks = version.getECBlocksForLevel(ecLevel);\n    var numDataBytes = version.getTotalCodewords() - ecBlocks.getTotalECCodewords(); // Terminate the bits properly.\n\n    this.terminateBits(numDataBytes, headerAndDataBits); // Interleave data bits with error correction code.\n\n    var finalBits = this.interleaveWithECBytes(headerAndDataBits, version.getTotalCodewords(), numDataBytes, ecBlocks.getNumBlocks());\n    var qrCode = new QRCode_1.default();\n    qrCode.setECLevel(ecLevel);\n    qrCode.setMode(mode);\n    qrCode.setVersion(version); //  Choose the mask pattern and set to \"qrCode\".\n\n    var dimension = version.getDimensionForVersion();\n    var matrix = new ByteMatrix_1.default(dimension, dimension);\n    var maskPattern = this.chooseMaskPattern(finalBits, ecLevel, version, matrix);\n    qrCode.setMaskPattern(maskPattern); // Build the matrix and set it to \"qrCode\".\n\n    MatrixUtil_1.default.buildMatrix(finalBits, ecLevel, version, maskPattern, matrix);\n    qrCode.setMatrix(matrix);\n    return qrCode;\n  };\n  /**\r\n   * Decides the smallest version of QR code that will contain all of the provided data.\r\n   *\r\n   * @throws WriterException if the data cannot fit in any version\r\n   */\n\n\n  Encoder.recommendVersion = function (ecLevel, mode, headerBits, dataBits) {\n    // Hard part: need to know version to know how many bits length takes. But need to know how many\n    // bits it takes to know version. First we take a guess at version by assuming version will be\n    // the minimum, 1:\n    var provisionalBitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, Version_1.default.getVersionForNumber(1));\n    var provisionalVersion = this.chooseVersion(provisionalBitsNeeded, ecLevel); // Use that guess to calculate the right version. I am still not sure this works in 100% of cases.\n\n    var bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, provisionalVersion);\n    return this.chooseVersion(bitsNeeded, ecLevel);\n  };\n\n  Encoder.calculateBitsNeeded = function (mode, headerBits, dataBits, version) {\n    return headerBits.getSize() + mode.getCharacterCountBits(version) + dataBits.getSize();\n  };\n  /**\r\n   * @return the code point of the table used in alphanumeric mode or\r\n   *  -1 if there is no corresponding code in the table.\r\n   */\n\n\n  Encoder.getAlphanumericCode = function (code\n  /*int*/\n  ) {\n    if (code < Encoder.ALPHANUMERIC_TABLE.length) {\n      return Encoder.ALPHANUMERIC_TABLE[code];\n    }\n\n    return -1;\n  }; // public static chooseMode(content: string): Mode {\n  //   return chooseMode(content, null);\n  // }\n\n  /**\r\n   * Choose the best mode by examining the content. Note that 'encoding' is used as a hint;\r\n   * if it is Shift_JIS, and the input is only double-byte Kanji, then we return {@link Mode#KANJI}.\r\n   */\n\n\n  Encoder.chooseMode = function (content, encoding) {\n    if (encoding === void 0) {\n      encoding = null;\n    }\n\n    if (CharacterSetECI_1.default.SJIS.getName() === encoding && this.isOnlyDoubleByteKanji(content)) {\n      // Choose Kanji mode if all input are double-byte characters\n      return Mode_1.default.KANJI;\n    }\n\n    var hasNumeric = false;\n    var hasAlphanumeric = false;\n\n    for (var i = 0, length_1 = content.length; i < length_1; ++i) {\n      var c = content.charAt(i);\n\n      if (Encoder.isDigit(c)) {\n        hasNumeric = true;\n      } else if (this.getAlphanumericCode(c.charCodeAt(0)) !== -1) {\n        hasAlphanumeric = true;\n      } else {\n        return Mode_1.default.BYTE;\n      }\n    }\n\n    if (hasAlphanumeric) {\n      return Mode_1.default.ALPHANUMERIC;\n    }\n\n    if (hasNumeric) {\n      return Mode_1.default.NUMERIC;\n    }\n\n    return Mode_1.default.BYTE;\n  };\n\n  Encoder.isOnlyDoubleByteKanji = function (content) {\n    var bytes;\n\n    try {\n      bytes = StringEncoding_1.default.encode(content, CharacterSetECI_1.default.SJIS); // content.getBytes(\"Shift_JIS\"))\n    } catch (ignored\n    /*: UnsupportedEncodingException*/\n    ) {\n      return false;\n    }\n\n    var length = bytes.length;\n\n    if (length % 2 !== 0) {\n      return false;\n    }\n\n    for (var i = 0; i < length; i += 2) {\n      var byte1 = bytes[i] & 0xFF;\n\n      if ((byte1 < 0x81 || byte1 > 0x9F) && (byte1 < 0xE0 || byte1 > 0xEB)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  Encoder.chooseMaskPattern = function (bits, ecLevel, version, matrix) {\n    var minPenalty = Number.MAX_SAFE_INTEGER; // Lower penalty is better.\n\n    var bestMaskPattern = -1; // We try all mask patterns to choose the best one.\n\n    for (var maskPattern = 0; maskPattern < QRCode_1.default.NUM_MASK_PATTERNS; maskPattern++) {\n      MatrixUtil_1.default.buildMatrix(bits, ecLevel, version, maskPattern, matrix);\n      var penalty = this.calculateMaskPenalty(matrix);\n\n      if (penalty < minPenalty) {\n        minPenalty = penalty;\n        bestMaskPattern = maskPattern;\n      }\n    }\n\n    return bestMaskPattern;\n  };\n\n  Encoder.chooseVersion = function (numInputBits\n  /*int*/\n  , ecLevel) {\n    for (var versionNum = 1; versionNum <= 40; versionNum++) {\n      var version = Version_1.default.getVersionForNumber(versionNum);\n\n      if (Encoder.willFit(numInputBits, version, ecLevel)) {\n        return version;\n      }\n    }\n\n    throw new WriterException_1.default('Data too big');\n  };\n  /**\r\n   * @return true if the number of input bits will fit in a code with the specified version and\r\n   * error correction level.\r\n   */\n\n\n  Encoder.willFit = function (numInputBits\n  /*int*/\n  , version, ecLevel) {\n    // In the following comments, we use numbers of Version 7-H.\n    // numBytes = 196\n    var numBytes = version.getTotalCodewords(); // getNumECBytes = 130\n\n    var ecBlocks = version.getECBlocksForLevel(ecLevel);\n    var numEcBytes = ecBlocks.getTotalECCodewords(); // getNumDataBytes = 196 - 130 = 66\n\n    var numDataBytes = numBytes - numEcBytes;\n    var totalInputBytes = (numInputBits + 7) / 8;\n    return numDataBytes >= totalInputBytes;\n  };\n  /**\r\n   * Terminate bits as described in 8.4.8 and 8.4.9 of JISX0510:2004 (p.24).\r\n   */\n\n\n  Encoder.terminateBits = function (numDataBytes\n  /*int*/\n  , bits) {\n    var capacity = numDataBytes * 8;\n\n    if (bits.getSize() > capacity) {\n      throw new WriterException_1.default('data bits cannot fit in the QR Code' + bits.getSize() + ' > ' + capacity);\n    }\n\n    for (var i = 0; i < 4 && bits.getSize() < capacity; ++i) {\n      bits.appendBit(false);\n    } // Append termination bits. See 8.4.8 of JISX0510:2004 (p.24) for details.\n    // If the last byte isn't 8-bit aligned, we'll add padding bits.\n\n\n    var numBitsInLastByte = bits.getSize() & 0x07;\n\n    if (numBitsInLastByte > 0) {\n      for (var i = numBitsInLastByte; i < 8; i++) {\n        bits.appendBit(false);\n      }\n    } // If we have more space, we'll fill the space with padding patterns defined in 8.4.9 (p.24).\n\n\n    var numPaddingBytes = numDataBytes - bits.getSizeInBytes();\n\n    for (var i = 0; i < numPaddingBytes; ++i) {\n      bits.appendBits((i & 0x01) === 0 ? 0xEC : 0x11, 8);\n    }\n\n    if (bits.getSize() !== capacity) {\n      throw new WriterException_1.default('Bits size does not equal capacity');\n    }\n  };\n  /**\r\n   * Get number of data bytes and number of error correction bytes for block id \"blockID\". Store\r\n   * the result in \"numDataBytesInBlock\", and \"numECBytesInBlock\". See table 12 in 8.5.1 of\r\n   * JISX0510:2004 (p.30)\r\n   */\n\n\n  Encoder.getNumDataBytesAndNumECBytesForBlockID = function (numTotalBytes\n  /*int*/\n  , numDataBytes\n  /*int*/\n  , numRSBlocks\n  /*int*/\n  , blockID\n  /*int*/\n  , numDataBytesInBlock, numECBytesInBlock) {\n    if (blockID >= numRSBlocks) {\n      throw new WriterException_1.default('Block ID too large');\n    } // numRsBlocksInGroup2 = 196 % 5 = 1\n\n\n    var numRsBlocksInGroup2 = numTotalBytes % numRSBlocks; // numRsBlocksInGroup1 = 5 - 1 = 4\n\n    var numRsBlocksInGroup1 = numRSBlocks - numRsBlocksInGroup2; // numTotalBytesInGroup1 = 196 / 5 = 39\n\n    var numTotalBytesInGroup1 = Math.floor(numTotalBytes / numRSBlocks); // numTotalBytesInGroup2 = 39 + 1 = 40\n\n    var numTotalBytesInGroup2 = numTotalBytesInGroup1 + 1; // numDataBytesInGroup1 = 66 / 5 = 13\n\n    var numDataBytesInGroup1 = Math.floor(numDataBytes / numRSBlocks); // numDataBytesInGroup2 = 13 + 1 = 14\n\n    var numDataBytesInGroup2 = numDataBytesInGroup1 + 1; // numEcBytesInGroup1 = 39 - 13 = 26\n\n    var numEcBytesInGroup1 = numTotalBytesInGroup1 - numDataBytesInGroup1; // numEcBytesInGroup2 = 40 - 14 = 26\n\n    var numEcBytesInGroup2 = numTotalBytesInGroup2 - numDataBytesInGroup2; // Sanity checks.\n    // 26 = 26\n\n    if (numEcBytesInGroup1 !== numEcBytesInGroup2) {\n      throw new WriterException_1.default('EC bytes mismatch');\n    } // 5 = 4 + 1.\n\n\n    if (numRSBlocks !== numRsBlocksInGroup1 + numRsBlocksInGroup2) {\n      throw new WriterException_1.default('RS blocks mismatch');\n    } // 196 = (13 + 26) * 4 + (14 + 26) * 1\n\n\n    if (numTotalBytes !== (numDataBytesInGroup1 + numEcBytesInGroup1) * numRsBlocksInGroup1 + (numDataBytesInGroup2 + numEcBytesInGroup2) * numRsBlocksInGroup2) {\n      throw new WriterException_1.default('Total bytes mismatch');\n    }\n\n    if (blockID < numRsBlocksInGroup1) {\n      numDataBytesInBlock[0] = numDataBytesInGroup1;\n      numECBytesInBlock[0] = numEcBytesInGroup1;\n    } else {\n      numDataBytesInBlock[0] = numDataBytesInGroup2;\n      numECBytesInBlock[0] = numEcBytesInGroup2;\n    }\n  };\n  /**\r\n   * Interleave \"bits\" with corresponding error correction bytes. On success, store the result in\r\n   * \"result\". The interleave rule is complicated. See 8.6 of JISX0510:2004 (p.37) for details.\r\n   */\n\n\n  Encoder.interleaveWithECBytes = function (bits, numTotalBytes\n  /*int*/\n  , numDataBytes\n  /*int*/\n  , numRSBlocks\n  /*int*/\n  ) {\n    var e_1, _a, e_2, _b; // \"bits\" must have \"getNumDataBytes\" bytes of data.\n\n\n    if (bits.getSizeInBytes() !== numDataBytes) {\n      throw new WriterException_1.default('Number of bits and data bytes does not match');\n    } // Step 1.  Divide data bytes into blocks and generate error correction bytes for them. We'll\n    // store the divided data bytes blocks and error correction bytes blocks into \"blocks\".\n\n\n    var dataBytesOffset = 0;\n    var maxNumDataBytes = 0;\n    var maxNumEcBytes = 0; // Since, we know the number of reedsolmon blocks, we can initialize the vector with the number.\n\n    var blocks = new Array(); // new Array<BlockPair>(numRSBlocks)\n\n    for (var i = 0; i < numRSBlocks; ++i) {\n      var numDataBytesInBlock = new Int32Array(1);\n      var numEcBytesInBlock = new Int32Array(1);\n      Encoder.getNumDataBytesAndNumECBytesForBlockID(numTotalBytes, numDataBytes, numRSBlocks, i, numDataBytesInBlock, numEcBytesInBlock);\n      var size = numDataBytesInBlock[0];\n      var dataBytes = new Uint8Array(size);\n      bits.toBytes(8 * dataBytesOffset, dataBytes, 0, size);\n      var ecBytes = Encoder.generateECBytes(dataBytes, numEcBytesInBlock[0]);\n      blocks.push(new BlockPair_1.default(dataBytes, ecBytes));\n      maxNumDataBytes = Math.max(maxNumDataBytes, size);\n      maxNumEcBytes = Math.max(maxNumEcBytes, ecBytes.length);\n      dataBytesOffset += numDataBytesInBlock[0];\n    }\n\n    if (numDataBytes !== dataBytesOffset) {\n      throw new WriterException_1.default('Data bytes does not match offset');\n    }\n\n    var result = new BitArray_1.default(); // First, place data blocks.\n\n    for (var i = 0; i < maxNumDataBytes; ++i) {\n      try {\n        for (var blocks_1 = __values(blocks), blocks_1_1 = blocks_1.next(); !blocks_1_1.done; blocks_1_1 = blocks_1.next()) {\n          var block = blocks_1_1.value;\n          var dataBytes = block.getDataBytes();\n\n          if (i < dataBytes.length) {\n            result.appendBits(dataBytes[i], 8);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (blocks_1_1 && !blocks_1_1.done && (_a = blocks_1.return)) _a.call(blocks_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    } // Then, place error correction blocks.\n\n\n    for (var i = 0; i < maxNumEcBytes; ++i) {\n      try {\n        for (var blocks_2 = __values(blocks), blocks_2_1 = blocks_2.next(); !blocks_2_1.done; blocks_2_1 = blocks_2.next()) {\n          var block = blocks_2_1.value;\n          var ecBytes = block.getErrorCorrectionBytes();\n\n          if (i < ecBytes.length) {\n            result.appendBits(ecBytes[i], 8);\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (blocks_2_1 && !blocks_2_1.done && (_b = blocks_2.return)) _b.call(blocks_2);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n\n    if (numTotalBytes !== result.getSizeInBytes()) {\n      // Should be same.\n      throw new WriterException_1.default('Interleaving error: ' + numTotalBytes + ' and ' + result.getSizeInBytes() + ' differ.');\n    }\n\n    return result;\n  };\n\n  Encoder.generateECBytes = function (dataBytes, numEcBytesInBlock\n  /*int*/\n  ) {\n    var numDataBytes = dataBytes.length;\n    var toEncode = new Int32Array(numDataBytes + numEcBytesInBlock); // int[numDataBytes + numEcBytesInBlock]\n\n    for (var i = 0; i < numDataBytes; i++) {\n      toEncode[i] = dataBytes[i] & 0xFF;\n    }\n\n    new ReedSolomonEncoder_1.default(GenericGF_1.default.QR_CODE_FIELD_256).encode(toEncode, numEcBytesInBlock);\n    var ecBytes = new Uint8Array(numEcBytesInBlock);\n\n    for (var i = 0; i < numEcBytesInBlock; i++) {\n      ecBytes[i] =\n      /*(byte) */\n      toEncode[numDataBytes + i];\n    }\n\n    return ecBytes;\n  };\n  /**\r\n   * Append mode info. On success, store the result in \"bits\".\r\n   */\n\n\n  Encoder.appendModeInfo = function (mode, bits) {\n    bits.appendBits(mode.getBits(), 4);\n  };\n  /**\r\n   * Append length info. On success, store the result in \"bits\".\r\n   */\n\n\n  Encoder.appendLengthInfo = function (numLetters\n  /*int*/\n  , version, mode, bits) {\n    var numBits = mode.getCharacterCountBits(version);\n\n    if (numLetters >= 1 << numBits) {\n      throw new WriterException_1.default(numLetters + ' is bigger than ' + ((1 << numBits) - 1));\n    }\n\n    bits.appendBits(numLetters, numBits);\n  };\n  /**\r\n   * Append \"bytes\" in \"mode\" mode (encoding) into \"bits\". On success, store the result in \"bits\".\r\n   */\n\n\n  Encoder.appendBytes = function (content, mode, bits, encoding) {\n    switch (mode) {\n      case Mode_1.default.NUMERIC:\n        Encoder.appendNumericBytes(content, bits);\n        break;\n\n      case Mode_1.default.ALPHANUMERIC:\n        Encoder.appendAlphanumericBytes(content, bits);\n        break;\n\n      case Mode_1.default.BYTE:\n        Encoder.append8BitBytes(content, bits, encoding);\n        break;\n\n      case Mode_1.default.KANJI:\n        Encoder.appendKanjiBytes(content, bits);\n        break;\n\n      default:\n        throw new WriterException_1.default('Invalid mode: ' + mode);\n    }\n  };\n\n  Encoder.getDigit = function (singleCharacter) {\n    return singleCharacter.charCodeAt(0) - 48;\n  };\n\n  Encoder.isDigit = function (singleCharacter) {\n    var cn = Encoder.getDigit(singleCharacter);\n    return cn >= 0 && cn <= 9;\n  };\n\n  Encoder.appendNumericBytes = function (content, bits) {\n    var length = content.length;\n    var i = 0;\n\n    while (i < length) {\n      var num1 = Encoder.getDigit(content.charAt(i));\n\n      if (i + 2 < length) {\n        // Encode three numeric letters in ten bits.\n        var num2 = Encoder.getDigit(content.charAt(i + 1));\n        var num3 = Encoder.getDigit(content.charAt(i + 2));\n        bits.appendBits(num1 * 100 + num2 * 10 + num3, 10);\n        i += 3;\n      } else if (i + 1 < length) {\n        // Encode two numeric letters in seven bits.\n        var num2 = Encoder.getDigit(content.charAt(i + 1));\n        bits.appendBits(num1 * 10 + num2, 7);\n        i += 2;\n      } else {\n        // Encode one numeric letter in four bits.\n        bits.appendBits(num1, 4);\n        i++;\n      }\n    }\n  };\n\n  Encoder.appendAlphanumericBytes = function (content, bits) {\n    var length = content.length;\n    var i = 0;\n\n    while (i < length) {\n      var code1 = Encoder.getAlphanumericCode(content.charCodeAt(i));\n\n      if (code1 === -1) {\n        throw new WriterException_1.default();\n      }\n\n      if (i + 1 < length) {\n        var code2 = Encoder.getAlphanumericCode(content.charCodeAt(i + 1));\n\n        if (code2 === -1) {\n          throw new WriterException_1.default();\n        } // Encode two alphanumeric letters in 11 bits.\n\n\n        bits.appendBits(code1 * 45 + code2, 11);\n        i += 2;\n      } else {\n        // Encode one alphanumeric letter in six bits.\n        bits.appendBits(code1, 6);\n        i++;\n      }\n    }\n  };\n\n  Encoder.append8BitBytes = function (content, bits, encoding) {\n    var bytes;\n\n    try {\n      bytes = StringEncoding_1.default.encode(content, encoding);\n    } catch (uee\n    /*: UnsupportedEncodingException*/\n    ) {\n      throw new WriterException_1.default(uee);\n    }\n\n    for (var i = 0, length_2 = bytes.length; i !== length_2; i++) {\n      var b = bytes[i];\n      bits.appendBits(b, 8);\n    }\n  };\n  /**\r\n   * @throws WriterException\r\n   */\n\n\n  Encoder.appendKanjiBytes = function (content, bits) {\n    var bytes;\n\n    try {\n      bytes = StringEncoding_1.default.encode(content, CharacterSetECI_1.default.SJIS);\n    } catch (uee\n    /*: UnsupportedEncodingException*/\n    ) {\n      throw new WriterException_1.default(uee);\n    }\n\n    var length = bytes.length;\n\n    for (var i = 0; i < length; i += 2) {\n      var byte1 = bytes[i] & 0xFF;\n      var byte2 = bytes[i + 1] & 0xFF;\n      var code = byte1 << 8 & 0xFFFFFFFF | byte2;\n      var subtracted = -1;\n\n      if (code >= 0x8140 && code <= 0x9ffc) {\n        subtracted = code - 0x8140;\n      } else if (code >= 0xe040 && code <= 0xebbf) {\n        subtracted = code - 0xc140;\n      }\n\n      if (subtracted === -1) {\n        throw new WriterException_1.default('Invalid byte sequence');\n      }\n\n      var encoded = (subtracted >> 8) * 0xc0 + (subtracted & 0xff);\n      bits.appendBits(encoded, 13);\n    }\n  };\n\n  Encoder.appendECI = function (eci, bits) {\n    bits.appendBits(Mode_1.default.ECI.getBits(), 4); // This is correct for values up to 127, which is all we need now.\n\n    bits.appendBits(eci.getValue(), 8);\n  }; // The original table is defined in the table 5 of JISX0510:2004 (p.19).\n\n\n  Encoder.ALPHANUMERIC_TABLE = Int32Array.from([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 36, -1, -1, -1, 37, 38, -1, -1, -1, -1, 39, 40, -1, 41, 42, 43, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 44, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1]);\n  Encoder.DEFAULT_BYTE_MODE_ENCODING = CharacterSetECI_1.default.UTF8.getName(); // \"ISO-8859-1\"\n\n  return Encoder;\n}();\n\nexports.default = Encoder;","map":{"version":3,"sources":["../../../../src/core/qrcode/encoder/Encoder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/*\r\n * Copyright 2008 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar __values = (this && this.__values) || function (o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*namespace com.google.zxing.qrcode.encoder {*/\r\nvar EncodeHintType_1 = require(\"../../EncodeHintType\");\r\nvar BitArray_1 = require(\"../../common/BitArray\");\r\nvar CharacterSetECI_1 = require(\"../../common/CharacterSetECI\");\r\nvar GenericGF_1 = require(\"../../common/reedsolomon/GenericGF\");\r\nvar ReedSolomonEncoder_1 = require(\"../../common/reedsolomon/ReedSolomonEncoder\");\r\nvar Mode_1 = require(\"../decoder/Mode\");\r\nvar Version_1 = require(\"../decoder/Version\");\r\nvar MaskUtil_1 = require(\"./MaskUtil\");\r\nvar ByteMatrix_1 = require(\"./ByteMatrix\");\r\nvar QRCode_1 = require(\"./QRCode\");\r\nvar MatrixUtil_1 = require(\"./MatrixUtil\");\r\nvar StringEncoding_1 = require(\"../../util/StringEncoding\");\r\nvar BlockPair_1 = require(\"./BlockPair\");\r\nvar WriterException_1 = require(\"../../WriterException\");\r\n/*import java.io.UnsupportedEncodingException;*/\r\n/*import java.util.ArrayList;*/\r\n/*import java.util.Collection;*/\r\n/*import java.util.Map;*/\r\n/**\r\n * @author satorux@google.com (Satoru Takabayashi) - creator\r\n * @author dswitkin@google.com (Daniel Switkin) - ported from C++\r\n */\r\nvar Encoder = /** @class */ (function () {\r\n    // TYPESCRIPTPORT: changed to UTF8, the default for js\r\n    function Encoder() {\r\n    }\r\n    // The mask penalty calculation is complicated.  See Table 21 of JISX0510:2004 (p.45) for details.\r\n    // Basically it applies four rules and summate all penalties.\r\n    Encoder.calculateMaskPenalty = function (matrix) {\r\n        return MaskUtil_1.default.applyMaskPenaltyRule1(matrix)\r\n            + MaskUtil_1.default.applyMaskPenaltyRule2(matrix)\r\n            + MaskUtil_1.default.applyMaskPenaltyRule3(matrix)\r\n            + MaskUtil_1.default.applyMaskPenaltyRule4(matrix);\r\n    };\r\n    /**\r\n     * @param content text to encode\r\n     * @param ecLevel error correction level to use\r\n     * @return {@link QRCode} representing the encoded QR code\r\n     * @throws WriterException if encoding can't succeed, because of for example invalid content\r\n     *   or configuration\r\n     */\r\n    // public static encode(content: string, ecLevel: ErrorCorrectionLevel): QRCode /*throws WriterException*/ {\r\n    //   return encode(content, ecLevel, null)\r\n    // }\r\n    Encoder.encode = function (content, ecLevel, hints) {\r\n        if (hints === void 0) { hints = null; }\r\n        // Determine what character encoding has been specified by the caller, if any\r\n        var encoding = Encoder.DEFAULT_BYTE_MODE_ENCODING;\r\n        var hasEncodingHint = hints !== null && undefined !== hints.get(EncodeHintType_1.default.CHARACTER_SET);\r\n        if (hasEncodingHint) {\r\n            encoding = hints.get(EncodeHintType_1.default.CHARACTER_SET).toString();\r\n        }\r\n        // Pick an encoding mode appropriate for the content. Note that this will not attempt to use\r\n        // multiple modes / segments even if that were more efficient. Twould be nice.\r\n        var mode = this.chooseMode(content, encoding);\r\n        // This will store the header information, like mode and\r\n        // length, as well as \"header\" segments like an ECI segment.\r\n        var headerBits = new BitArray_1.default();\r\n        // Append ECI segment if applicable\r\n        if (mode === Mode_1.default.BYTE && (hasEncodingHint || Encoder.DEFAULT_BYTE_MODE_ENCODING !== encoding)) {\r\n            var eci = CharacterSetECI_1.default.getCharacterSetECIByName(encoding);\r\n            if (eci !== undefined) {\r\n                this.appendECI(eci, headerBits);\r\n            }\r\n        }\r\n        // (With ECI in place,) Write the mode marker\r\n        this.appendModeInfo(mode, headerBits);\r\n        // Collect data within the main segment, separately, to count its size if needed. Don't add it to\r\n        // main payload yet.\r\n        var dataBits = new BitArray_1.default();\r\n        this.appendBytes(content, mode, dataBits, encoding);\r\n        var version;\r\n        if (hints !== null && undefined !== hints.get(EncodeHintType_1.default.QR_VERSION)) {\r\n            var versionNumber = Number.parseInt(hints.get(EncodeHintType_1.default.QR_VERSION).toString(), 10);\r\n            version = Version_1.default.getVersionForNumber(versionNumber);\r\n            var bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, version);\r\n            if (!this.willFit(bitsNeeded, version, ecLevel)) {\r\n                throw new WriterException_1.default('Data too big for requested version');\r\n            }\r\n        }\r\n        else {\r\n            version = this.recommendVersion(ecLevel, mode, headerBits, dataBits);\r\n        }\r\n        var headerAndDataBits = new BitArray_1.default();\r\n        headerAndDataBits.appendBitArray(headerBits);\r\n        // Find \"length\" of main segment and write it\r\n        var numLetters = mode === Mode_1.default.BYTE ? dataBits.getSizeInBytes() : content.length;\r\n        this.appendLengthInfo(numLetters, version, mode, headerAndDataBits);\r\n        // Put data together into the overall payload\r\n        headerAndDataBits.appendBitArray(dataBits);\r\n        var ecBlocks = version.getECBlocksForLevel(ecLevel);\r\n        var numDataBytes = version.getTotalCodewords() - ecBlocks.getTotalECCodewords();\r\n        // Terminate the bits properly.\r\n        this.terminateBits(numDataBytes, headerAndDataBits);\r\n        // Interleave data bits with error correction code.\r\n        var finalBits = this.interleaveWithECBytes(headerAndDataBits, version.getTotalCodewords(), numDataBytes, ecBlocks.getNumBlocks());\r\n        var qrCode = new QRCode_1.default();\r\n        qrCode.setECLevel(ecLevel);\r\n        qrCode.setMode(mode);\r\n        qrCode.setVersion(version);\r\n        //  Choose the mask pattern and set to \"qrCode\".\r\n        var dimension = version.getDimensionForVersion();\r\n        var matrix = new ByteMatrix_1.default(dimension, dimension);\r\n        var maskPattern = this.chooseMaskPattern(finalBits, ecLevel, version, matrix);\r\n        qrCode.setMaskPattern(maskPattern);\r\n        // Build the matrix and set it to \"qrCode\".\r\n        MatrixUtil_1.default.buildMatrix(finalBits, ecLevel, version, maskPattern, matrix);\r\n        qrCode.setMatrix(matrix);\r\n        return qrCode;\r\n    };\r\n    /**\r\n     * Decides the smallest version of QR code that will contain all of the provided data.\r\n     *\r\n     * @throws WriterException if the data cannot fit in any version\r\n     */\r\n    Encoder.recommendVersion = function (ecLevel, mode, headerBits, dataBits) {\r\n        // Hard part: need to know version to know how many bits length takes. But need to know how many\r\n        // bits it takes to know version. First we take a guess at version by assuming version will be\r\n        // the minimum, 1:\r\n        var provisionalBitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, Version_1.default.getVersionForNumber(1));\r\n        var provisionalVersion = this.chooseVersion(provisionalBitsNeeded, ecLevel);\r\n        // Use that guess to calculate the right version. I am still not sure this works in 100% of cases.\r\n        var bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, provisionalVersion);\r\n        return this.chooseVersion(bitsNeeded, ecLevel);\r\n    };\r\n    Encoder.calculateBitsNeeded = function (mode, headerBits, dataBits, version) {\r\n        return headerBits.getSize() + mode.getCharacterCountBits(version) + dataBits.getSize();\r\n    };\r\n    /**\r\n     * @return the code point of the table used in alphanumeric mode or\r\n     *  -1 if there is no corresponding code in the table.\r\n     */\r\n    Encoder.getAlphanumericCode = function (code /*int*/) {\r\n        if (code < Encoder.ALPHANUMERIC_TABLE.length) {\r\n            return Encoder.ALPHANUMERIC_TABLE[code];\r\n        }\r\n        return -1;\r\n    };\r\n    // public static chooseMode(content: string): Mode {\r\n    //   return chooseMode(content, null);\r\n    // }\r\n    /**\r\n     * Choose the best mode by examining the content. Note that 'encoding' is used as a hint;\r\n     * if it is Shift_JIS, and the input is only double-byte Kanji, then we return {@link Mode#KANJI}.\r\n     */\r\n    Encoder.chooseMode = function (content, encoding) {\r\n        if (encoding === void 0) { encoding = null; }\r\n        if (CharacterSetECI_1.default.SJIS.getName() === encoding && this.isOnlyDoubleByteKanji(content)) {\r\n            // Choose Kanji mode if all input are double-byte characters\r\n            return Mode_1.default.KANJI;\r\n        }\r\n        var hasNumeric = false;\r\n        var hasAlphanumeric = false;\r\n        for (var i = 0, length_1 = content.length; i < length_1; ++i) {\r\n            var c = content.charAt(i);\r\n            if (Encoder.isDigit(c)) {\r\n                hasNumeric = true;\r\n            }\r\n            else if (this.getAlphanumericCode(c.charCodeAt(0)) !== -1) {\r\n                hasAlphanumeric = true;\r\n            }\r\n            else {\r\n                return Mode_1.default.BYTE;\r\n            }\r\n        }\r\n        if (hasAlphanumeric) {\r\n            return Mode_1.default.ALPHANUMERIC;\r\n        }\r\n        if (hasNumeric) {\r\n            return Mode_1.default.NUMERIC;\r\n        }\r\n        return Mode_1.default.BYTE;\r\n    };\r\n    Encoder.isOnlyDoubleByteKanji = function (content) {\r\n        var bytes;\r\n        try {\r\n            bytes = StringEncoding_1.default.encode(content, CharacterSetECI_1.default.SJIS); // content.getBytes(\"Shift_JIS\"))\r\n        }\r\n        catch (ignored /*: UnsupportedEncodingException*/) {\r\n            return false;\r\n        }\r\n        var length = bytes.length;\r\n        if (length % 2 !== 0) {\r\n            return false;\r\n        }\r\n        for (var i = 0; i < length; i += 2) {\r\n            var byte1 = bytes[i] & 0xFF;\r\n            if ((byte1 < 0x81 || byte1 > 0x9F) && (byte1 < 0xE0 || byte1 > 0xEB)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    Encoder.chooseMaskPattern = function (bits, ecLevel, version, matrix) {\r\n        var minPenalty = Number.MAX_SAFE_INTEGER; // Lower penalty is better.\r\n        var bestMaskPattern = -1;\r\n        // We try all mask patterns to choose the best one.\r\n        for (var maskPattern = 0; maskPattern < QRCode_1.default.NUM_MASK_PATTERNS; maskPattern++) {\r\n            MatrixUtil_1.default.buildMatrix(bits, ecLevel, version, maskPattern, matrix);\r\n            var penalty = this.calculateMaskPenalty(matrix);\r\n            if (penalty < minPenalty) {\r\n                minPenalty = penalty;\r\n                bestMaskPattern = maskPattern;\r\n            }\r\n        }\r\n        return bestMaskPattern;\r\n    };\r\n    Encoder.chooseVersion = function (numInputBits /*int*/, ecLevel) {\r\n        for (var versionNum = 1; versionNum <= 40; versionNum++) {\r\n            var version = Version_1.default.getVersionForNumber(versionNum);\r\n            if (Encoder.willFit(numInputBits, version, ecLevel)) {\r\n                return version;\r\n            }\r\n        }\r\n        throw new WriterException_1.default('Data too big');\r\n    };\r\n    /**\r\n     * @return true if the number of input bits will fit in a code with the specified version and\r\n     * error correction level.\r\n     */\r\n    Encoder.willFit = function (numInputBits /*int*/, version, ecLevel) {\r\n        // In the following comments, we use numbers of Version 7-H.\r\n        // numBytes = 196\r\n        var numBytes = version.getTotalCodewords();\r\n        // getNumECBytes = 130\r\n        var ecBlocks = version.getECBlocksForLevel(ecLevel);\r\n        var numEcBytes = ecBlocks.getTotalECCodewords();\r\n        // getNumDataBytes = 196 - 130 = 66\r\n        var numDataBytes = numBytes - numEcBytes;\r\n        var totalInputBytes = (numInputBits + 7) / 8;\r\n        return numDataBytes >= totalInputBytes;\r\n    };\r\n    /**\r\n     * Terminate bits as described in 8.4.8 and 8.4.9 of JISX0510:2004 (p.24).\r\n     */\r\n    Encoder.terminateBits = function (numDataBytes /*int*/, bits) {\r\n        var capacity = numDataBytes * 8;\r\n        if (bits.getSize() > capacity) {\r\n            throw new WriterException_1.default('data bits cannot fit in the QR Code' + bits.getSize() + ' > ' +\r\n                capacity);\r\n        }\r\n        for (var i = 0; i < 4 && bits.getSize() < capacity; ++i) {\r\n            bits.appendBit(false);\r\n        }\r\n        // Append termination bits. See 8.4.8 of JISX0510:2004 (p.24) for details.\r\n        // If the last byte isn't 8-bit aligned, we'll add padding bits.\r\n        var numBitsInLastByte = bits.getSize() & 0x07;\r\n        if (numBitsInLastByte > 0) {\r\n            for (var i = numBitsInLastByte; i < 8; i++) {\r\n                bits.appendBit(false);\r\n            }\r\n        }\r\n        // If we have more space, we'll fill the space with padding patterns defined in 8.4.9 (p.24).\r\n        var numPaddingBytes = numDataBytes - bits.getSizeInBytes();\r\n        for (var i = 0; i < numPaddingBytes; ++i) {\r\n            bits.appendBits((i & 0x01) === 0 ? 0xEC : 0x11, 8);\r\n        }\r\n        if (bits.getSize() !== capacity) {\r\n            throw new WriterException_1.default('Bits size does not equal capacity');\r\n        }\r\n    };\r\n    /**\r\n     * Get number of data bytes and number of error correction bytes for block id \"blockID\". Store\r\n     * the result in \"numDataBytesInBlock\", and \"numECBytesInBlock\". See table 12 in 8.5.1 of\r\n     * JISX0510:2004 (p.30)\r\n     */\r\n    Encoder.getNumDataBytesAndNumECBytesForBlockID = function (numTotalBytes /*int*/, numDataBytes /*int*/, numRSBlocks /*int*/, blockID /*int*/, numDataBytesInBlock, numECBytesInBlock) {\r\n        if (blockID >= numRSBlocks) {\r\n            throw new WriterException_1.default('Block ID too large');\r\n        }\r\n        // numRsBlocksInGroup2 = 196 % 5 = 1\r\n        var numRsBlocksInGroup2 = numTotalBytes % numRSBlocks;\r\n        // numRsBlocksInGroup1 = 5 - 1 = 4\r\n        var numRsBlocksInGroup1 = numRSBlocks - numRsBlocksInGroup2;\r\n        // numTotalBytesInGroup1 = 196 / 5 = 39\r\n        var numTotalBytesInGroup1 = Math.floor(numTotalBytes / numRSBlocks);\r\n        // numTotalBytesInGroup2 = 39 + 1 = 40\r\n        var numTotalBytesInGroup2 = numTotalBytesInGroup1 + 1;\r\n        // numDataBytesInGroup1 = 66 / 5 = 13\r\n        var numDataBytesInGroup1 = Math.floor(numDataBytes / numRSBlocks);\r\n        // numDataBytesInGroup2 = 13 + 1 = 14\r\n        var numDataBytesInGroup2 = numDataBytesInGroup1 + 1;\r\n        // numEcBytesInGroup1 = 39 - 13 = 26\r\n        var numEcBytesInGroup1 = numTotalBytesInGroup1 - numDataBytesInGroup1;\r\n        // numEcBytesInGroup2 = 40 - 14 = 26\r\n        var numEcBytesInGroup2 = numTotalBytesInGroup2 - numDataBytesInGroup2;\r\n        // Sanity checks.\r\n        // 26 = 26\r\n        if (numEcBytesInGroup1 !== numEcBytesInGroup2) {\r\n            throw new WriterException_1.default('EC bytes mismatch');\r\n        }\r\n        // 5 = 4 + 1.\r\n        if (numRSBlocks !== numRsBlocksInGroup1 + numRsBlocksInGroup2) {\r\n            throw new WriterException_1.default('RS blocks mismatch');\r\n        }\r\n        // 196 = (13 + 26) * 4 + (14 + 26) * 1\r\n        if (numTotalBytes !==\r\n            ((numDataBytesInGroup1 + numEcBytesInGroup1) *\r\n                numRsBlocksInGroup1) +\r\n                ((numDataBytesInGroup2 + numEcBytesInGroup2) *\r\n                    numRsBlocksInGroup2)) {\r\n            throw new WriterException_1.default('Total bytes mismatch');\r\n        }\r\n        if (blockID < numRsBlocksInGroup1) {\r\n            numDataBytesInBlock[0] = numDataBytesInGroup1;\r\n            numECBytesInBlock[0] = numEcBytesInGroup1;\r\n        }\r\n        else {\r\n            numDataBytesInBlock[0] = numDataBytesInGroup2;\r\n            numECBytesInBlock[0] = numEcBytesInGroup2;\r\n        }\r\n    };\r\n    /**\r\n     * Interleave \"bits\" with corresponding error correction bytes. On success, store the result in\r\n     * \"result\". The interleave rule is complicated. See 8.6 of JISX0510:2004 (p.37) for details.\r\n     */\r\n    Encoder.interleaveWithECBytes = function (bits, numTotalBytes /*int*/, numDataBytes /*int*/, numRSBlocks /*int*/) {\r\n        var e_1, _a, e_2, _b;\r\n        // \"bits\" must have \"getNumDataBytes\" bytes of data.\r\n        if (bits.getSizeInBytes() !== numDataBytes) {\r\n            throw new WriterException_1.default('Number of bits and data bytes does not match');\r\n        }\r\n        // Step 1.  Divide data bytes into blocks and generate error correction bytes for them. We'll\r\n        // store the divided data bytes blocks and error correction bytes blocks into \"blocks\".\r\n        var dataBytesOffset = 0;\r\n        var maxNumDataBytes = 0;\r\n        var maxNumEcBytes = 0;\r\n        // Since, we know the number of reedsolmon blocks, we can initialize the vector with the number.\r\n        var blocks = new Array(); // new Array<BlockPair>(numRSBlocks)\r\n        for (var i = 0; i < numRSBlocks; ++i) {\r\n            var numDataBytesInBlock = new Int32Array(1);\r\n            var numEcBytesInBlock = new Int32Array(1);\r\n            Encoder.getNumDataBytesAndNumECBytesForBlockID(numTotalBytes, numDataBytes, numRSBlocks, i, numDataBytesInBlock, numEcBytesInBlock);\r\n            var size = numDataBytesInBlock[0];\r\n            var dataBytes = new Uint8Array(size);\r\n            bits.toBytes(8 * dataBytesOffset, dataBytes, 0, size);\r\n            var ecBytes = Encoder.generateECBytes(dataBytes, numEcBytesInBlock[0]);\r\n            blocks.push(new BlockPair_1.default(dataBytes, ecBytes));\r\n            maxNumDataBytes = Math.max(maxNumDataBytes, size);\r\n            maxNumEcBytes = Math.max(maxNumEcBytes, ecBytes.length);\r\n            dataBytesOffset += numDataBytesInBlock[0];\r\n        }\r\n        if (numDataBytes !== dataBytesOffset) {\r\n            throw new WriterException_1.default('Data bytes does not match offset');\r\n        }\r\n        var result = new BitArray_1.default();\r\n        // First, place data blocks.\r\n        for (var i = 0; i < maxNumDataBytes; ++i) {\r\n            try {\r\n                for (var blocks_1 = __values(blocks), blocks_1_1 = blocks_1.next(); !blocks_1_1.done; blocks_1_1 = blocks_1.next()) {\r\n                    var block = blocks_1_1.value;\r\n                    var dataBytes = block.getDataBytes();\r\n                    if (i < dataBytes.length) {\r\n                        result.appendBits(dataBytes[i], 8);\r\n                    }\r\n                }\r\n            }\r\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n            finally {\r\n                try {\r\n                    if (blocks_1_1 && !blocks_1_1.done && (_a = blocks_1.return)) _a.call(blocks_1);\r\n                }\r\n                finally { if (e_1) throw e_1.error; }\r\n            }\r\n        }\r\n        // Then, place error correction blocks.\r\n        for (var i = 0; i < maxNumEcBytes; ++i) {\r\n            try {\r\n                for (var blocks_2 = __values(blocks), blocks_2_1 = blocks_2.next(); !blocks_2_1.done; blocks_2_1 = blocks_2.next()) {\r\n                    var block = blocks_2_1.value;\r\n                    var ecBytes = block.getErrorCorrectionBytes();\r\n                    if (i < ecBytes.length) {\r\n                        result.appendBits(ecBytes[i], 8);\r\n                    }\r\n                }\r\n            }\r\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n            finally {\r\n                try {\r\n                    if (blocks_2_1 && !blocks_2_1.done && (_b = blocks_2.return)) _b.call(blocks_2);\r\n                }\r\n                finally { if (e_2) throw e_2.error; }\r\n            }\r\n        }\r\n        if (numTotalBytes !== result.getSizeInBytes()) { // Should be same.\r\n            throw new WriterException_1.default('Interleaving error: ' + numTotalBytes + ' and ' +\r\n                result.getSizeInBytes() + ' differ.');\r\n        }\r\n        return result;\r\n    };\r\n    Encoder.generateECBytes = function (dataBytes, numEcBytesInBlock /*int*/) {\r\n        var numDataBytes = dataBytes.length;\r\n        var toEncode = new Int32Array(numDataBytes + numEcBytesInBlock); // int[numDataBytes + numEcBytesInBlock]\r\n        for (var i = 0; i < numDataBytes; i++) {\r\n            toEncode[i] = dataBytes[i] & 0xFF;\r\n        }\r\n        new ReedSolomonEncoder_1.default(GenericGF_1.default.QR_CODE_FIELD_256).encode(toEncode, numEcBytesInBlock);\r\n        var ecBytes = new Uint8Array(numEcBytesInBlock);\r\n        for (var i = 0; i < numEcBytesInBlock; i++) {\r\n            ecBytes[i] = /*(byte) */ toEncode[numDataBytes + i];\r\n        }\r\n        return ecBytes;\r\n    };\r\n    /**\r\n     * Append mode info. On success, store the result in \"bits\".\r\n     */\r\n    Encoder.appendModeInfo = function (mode, bits) {\r\n        bits.appendBits(mode.getBits(), 4);\r\n    };\r\n    /**\r\n     * Append length info. On success, store the result in \"bits\".\r\n     */\r\n    Encoder.appendLengthInfo = function (numLetters /*int*/, version, mode, bits) {\r\n        var numBits = mode.getCharacterCountBits(version);\r\n        if (numLetters >= (1 << numBits)) {\r\n            throw new WriterException_1.default(numLetters + ' is bigger than ' + ((1 << numBits) - 1));\r\n        }\r\n        bits.appendBits(numLetters, numBits);\r\n    };\r\n    /**\r\n     * Append \"bytes\" in \"mode\" mode (encoding) into \"bits\". On success, store the result in \"bits\".\r\n     */\r\n    Encoder.appendBytes = function (content, mode, bits, encoding) {\r\n        switch (mode) {\r\n            case Mode_1.default.NUMERIC:\r\n                Encoder.appendNumericBytes(content, bits);\r\n                break;\r\n            case Mode_1.default.ALPHANUMERIC:\r\n                Encoder.appendAlphanumericBytes(content, bits);\r\n                break;\r\n            case Mode_1.default.BYTE:\r\n                Encoder.append8BitBytes(content, bits, encoding);\r\n                break;\r\n            case Mode_1.default.KANJI:\r\n                Encoder.appendKanjiBytes(content, bits);\r\n                break;\r\n            default:\r\n                throw new WriterException_1.default('Invalid mode: ' + mode);\r\n        }\r\n    };\r\n    Encoder.getDigit = function (singleCharacter) {\r\n        return singleCharacter.charCodeAt(0) - 48;\r\n    };\r\n    Encoder.isDigit = function (singleCharacter) {\r\n        var cn = Encoder.getDigit(singleCharacter);\r\n        return cn >= 0 && cn <= 9;\r\n    };\r\n    Encoder.appendNumericBytes = function (content, bits) {\r\n        var length = content.length;\r\n        var i = 0;\r\n        while (i < length) {\r\n            var num1 = Encoder.getDigit(content.charAt(i));\r\n            if (i + 2 < length) {\r\n                // Encode three numeric letters in ten bits.\r\n                var num2 = Encoder.getDigit(content.charAt(i + 1));\r\n                var num3 = Encoder.getDigit(content.charAt(i + 2));\r\n                bits.appendBits(num1 * 100 + num2 * 10 + num3, 10);\r\n                i += 3;\r\n            }\r\n            else if (i + 1 < length) {\r\n                // Encode two numeric letters in seven bits.\r\n                var num2 = Encoder.getDigit(content.charAt(i + 1));\r\n                bits.appendBits(num1 * 10 + num2, 7);\r\n                i += 2;\r\n            }\r\n            else {\r\n                // Encode one numeric letter in four bits.\r\n                bits.appendBits(num1, 4);\r\n                i++;\r\n            }\r\n        }\r\n    };\r\n    Encoder.appendAlphanumericBytes = function (content, bits) {\r\n        var length = content.length;\r\n        var i = 0;\r\n        while (i < length) {\r\n            var code1 = Encoder.getAlphanumericCode(content.charCodeAt(i));\r\n            if (code1 === -1) {\r\n                throw new WriterException_1.default();\r\n            }\r\n            if (i + 1 < length) {\r\n                var code2 = Encoder.getAlphanumericCode(content.charCodeAt(i + 1));\r\n                if (code2 === -1) {\r\n                    throw new WriterException_1.default();\r\n                }\r\n                // Encode two alphanumeric letters in 11 bits.\r\n                bits.appendBits(code1 * 45 + code2, 11);\r\n                i += 2;\r\n            }\r\n            else {\r\n                // Encode one alphanumeric letter in six bits.\r\n                bits.appendBits(code1, 6);\r\n                i++;\r\n            }\r\n        }\r\n    };\r\n    Encoder.append8BitBytes = function (content, bits, encoding) {\r\n        var bytes;\r\n        try {\r\n            bytes = StringEncoding_1.default.encode(content, encoding);\r\n        }\r\n        catch (uee /*: UnsupportedEncodingException*/) {\r\n            throw new WriterException_1.default(uee);\r\n        }\r\n        for (var i = 0, length_2 = bytes.length; i !== length_2; i++) {\r\n            var b = bytes[i];\r\n            bits.appendBits(b, 8);\r\n        }\r\n    };\r\n    /**\r\n     * @throws WriterException\r\n     */\r\n    Encoder.appendKanjiBytes = function (content, bits) {\r\n        var bytes;\r\n        try {\r\n            bytes = StringEncoding_1.default.encode(content, CharacterSetECI_1.default.SJIS);\r\n        }\r\n        catch (uee /*: UnsupportedEncodingException*/) {\r\n            throw new WriterException_1.default(uee);\r\n        }\r\n        var length = bytes.length;\r\n        for (var i = 0; i < length; i += 2) {\r\n            var byte1 = bytes[i] & 0xFF;\r\n            var byte2 = bytes[i + 1] & 0xFF;\r\n            var code = ((byte1 << 8) & 0xFFFFFFFF) | byte2;\r\n            var subtracted = -1;\r\n            if (code >= 0x8140 && code <= 0x9ffc) {\r\n                subtracted = code - 0x8140;\r\n            }\r\n            else if (code >= 0xe040 && code <= 0xebbf) {\r\n                subtracted = code - 0xc140;\r\n            }\r\n            if (subtracted === -1) {\r\n                throw new WriterException_1.default('Invalid byte sequence');\r\n            }\r\n            var encoded = ((subtracted >> 8) * 0xc0) + (subtracted & 0xff);\r\n            bits.appendBits(encoded, 13);\r\n        }\r\n    };\r\n    Encoder.appendECI = function (eci, bits) {\r\n        bits.appendBits(Mode_1.default.ECI.getBits(), 4);\r\n        // This is correct for values up to 127, which is all we need now.\r\n        bits.appendBits(eci.getValue(), 8);\r\n    };\r\n    // The original table is defined in the table 5 of JISX0510:2004 (p.19).\r\n    Encoder.ALPHANUMERIC_TABLE = Int32Array.from([\r\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\r\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\r\n        36, -1, -1, -1, 37, 38, -1, -1, -1, -1, 39, 40, -1, 41, 42, 43,\r\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 44, -1, -1, -1, -1, -1,\r\n        -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\r\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,\r\n    ]);\r\n    Encoder.DEFAULT_BYTE_MODE_ENCODING = CharacterSetECI_1.default.UTF8.getName(); // \"ISO-8859-1\"\r\n    return Encoder;\r\n}());\r\nexports.default = Encoder;\r\n//# sourceMappingURL=Encoder.js.map"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing {*/\n\nvar MathUtils_1 = require(\"./common/detector/MathUtils\");\n\nvar Float_1 = require(\"./util/Float\");\n/**\r\n * <p>Encapsulates a point of interest in an image containing a barcode. Typically, this\r\n * would be the location of a finder pattern or the corner of the barcode, for example.</p>\r\n *\r\n * @author Sean Owen\r\n */\n\n\nvar ResultPoint =\n/** @class */\nfunction () {\n  function ResultPoint(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  ResultPoint.prototype.getX = function () {\n    return this.x;\n  };\n\n  ResultPoint.prototype.getY = function () {\n    return this.y;\n  };\n  /*@Override*/\n\n\n  ResultPoint.prototype.equals = function (other) {\n    if (other instanceof ResultPoint) {\n      var otherPoint = other;\n      return this.x === otherPoint.x && this.y === otherPoint.y;\n    }\n\n    return false;\n  };\n  /*@Override*/\n\n\n  ResultPoint.prototype.hashCode = function () {\n    return 31 * Float_1.default.floatToIntBits(this.x) + Float_1.default.floatToIntBits(this.y);\n  };\n  /*@Override*/\n\n\n  ResultPoint.prototype.toString = function () {\n    return '(' + this.x + ',' + this.y + ')';\n  };\n  /**\r\n   * Orders an array of three ResultPoints in an order [A,B,C] such that AB is less than AC\r\n   * and BC is less than AC, and the angle between BC and BA is less than 180 degrees.\r\n   *\r\n   * @param patterns array of three {@code ResultPoint} to order\r\n   */\n\n\n  ResultPoint.orderBestPatterns = function (patterns) {\n    // Find distances between pattern centers\n    var zeroOneDistance = this.distance(patterns[0], patterns[1]);\n    var oneTwoDistance = this.distance(patterns[1], patterns[2]);\n    var zeroTwoDistance = this.distance(patterns[0], patterns[2]);\n    var pointA;\n    var pointB;\n    var pointC; // Assume one closest to other two is B; A and C will just be guesses at first\n\n    if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {\n      pointB = patterns[0];\n      pointA = patterns[1];\n      pointC = patterns[2];\n    } else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {\n      pointB = patterns[1];\n      pointA = patterns[0];\n      pointC = patterns[2];\n    } else {\n      pointB = patterns[2];\n      pointA = patterns[0];\n      pointC = patterns[1];\n    } // Use cross product to figure out whether A and C are correct or flipped.\n    // This asks whether BC x BA has a positive z component, which is the arrangement\n    // we want for A, B, C. If it's negative, then we've got it flipped around and\n    // should swap A and C.\n\n\n    if (this.crossProductZ(pointA, pointB, pointC) < 0.0) {\n      var temp = pointA;\n      pointA = pointC;\n      pointC = temp;\n    }\n\n    patterns[0] = pointA;\n    patterns[1] = pointB;\n    patterns[2] = pointC;\n  };\n  /**\r\n   * @param pattern1 first pattern\r\n   * @param pattern2 second pattern\r\n   * @return distance between two points\r\n   */\n\n\n  ResultPoint.distance = function (pattern1, pattern2) {\n    return MathUtils_1.default.distance(pattern1.x, pattern1.y, pattern2.x, pattern2.y);\n  };\n  /**\r\n   * Returns the z component of the cross product between vectors BC and BA.\r\n   */\n\n\n  ResultPoint.crossProductZ = function (pointA, pointB, pointC) {\n    var bX = pointB.x;\n    var bY = pointB.y;\n    return (pointC.x - bX) * (pointA.y - bY) - (pointC.y - bY) * (pointA.x - bX);\n  };\n\n  return ResultPoint;\n}();\n\nexports.default = ResultPoint;","map":{"version":3,"sources":["../../src/core/ResultPoint.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*namespace com.google.zxing {*/\r\nvar MathUtils_1 = require(\"./common/detector/MathUtils\");\r\nvar Float_1 = require(\"./util/Float\");\r\n/**\r\n * <p>Encapsulates a point of interest in an image containing a barcode. Typically, this\r\n * would be the location of a finder pattern or the corner of the barcode, for example.</p>\r\n *\r\n * @author Sean Owen\r\n */\r\nvar ResultPoint = /** @class */ (function () {\r\n    function ResultPoint(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    ResultPoint.prototype.getX = function () {\r\n        return this.x;\r\n    };\r\n    ResultPoint.prototype.getY = function () {\r\n        return this.y;\r\n    };\r\n    /*@Override*/\r\n    ResultPoint.prototype.equals = function (other) {\r\n        if (other instanceof ResultPoint) {\r\n            var otherPoint = other;\r\n            return this.x === otherPoint.x && this.y === otherPoint.y;\r\n        }\r\n        return false;\r\n    };\r\n    /*@Override*/\r\n    ResultPoint.prototype.hashCode = function () {\r\n        return 31 * Float_1.default.floatToIntBits(this.x) + Float_1.default.floatToIntBits(this.y);\r\n    };\r\n    /*@Override*/\r\n    ResultPoint.prototype.toString = function () {\r\n        return '(' + this.x + ',' + this.y + ')';\r\n    };\r\n    /**\r\n     * Orders an array of three ResultPoints in an order [A,B,C] such that AB is less than AC\r\n     * and BC is less than AC, and the angle between BC and BA is less than 180 degrees.\r\n     *\r\n     * @param patterns array of three {@code ResultPoint} to order\r\n     */\r\n    ResultPoint.orderBestPatterns = function (patterns) {\r\n        // Find distances between pattern centers\r\n        var zeroOneDistance = this.distance(patterns[0], patterns[1]);\r\n        var oneTwoDistance = this.distance(patterns[1], patterns[2]);\r\n        var zeroTwoDistance = this.distance(patterns[0], patterns[2]);\r\n        var pointA;\r\n        var pointB;\r\n        var pointC;\r\n        // Assume one closest to other two is B; A and C will just be guesses at first\r\n        if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {\r\n            pointB = patterns[0];\r\n            pointA = patterns[1];\r\n            pointC = patterns[2];\r\n        }\r\n        else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {\r\n            pointB = patterns[1];\r\n            pointA = patterns[0];\r\n            pointC = patterns[2];\r\n        }\r\n        else {\r\n            pointB = patterns[2];\r\n            pointA = patterns[0];\r\n            pointC = patterns[1];\r\n        }\r\n        // Use cross product to figure out whether A and C are correct or flipped.\r\n        // This asks whether BC x BA has a positive z component, which is the arrangement\r\n        // we want for A, B, C. If it's negative, then we've got it flipped around and\r\n        // should swap A and C.\r\n        if (this.crossProductZ(pointA, pointB, pointC) < 0.0) {\r\n            var temp = pointA;\r\n            pointA = pointC;\r\n            pointC = temp;\r\n        }\r\n        patterns[0] = pointA;\r\n        patterns[1] = pointB;\r\n        patterns[2] = pointC;\r\n    };\r\n    /**\r\n     * @param pattern1 first pattern\r\n     * @param pattern2 second pattern\r\n     * @return distance between two points\r\n     */\r\n    ResultPoint.distance = function (pattern1, pattern2) {\r\n        return MathUtils_1.default.distance(pattern1.x, pattern1.y, pattern2.x, pattern2.y);\r\n    };\r\n    /**\r\n     * Returns the z component of the cross product between vectors BC and BA.\r\n     */\r\n    ResultPoint.crossProductZ = function (pointA, pointB, pointC) {\r\n        var bX = pointB.x;\r\n        var bY = pointB.y;\r\n        return ((pointC.x - bX) * (pointA.y - bY)) - ((pointC.y - bY) * (pointA.x - bX));\r\n    };\r\n    return ResultPoint;\r\n}());\r\nexports.default = ResultPoint;\r\n//# sourceMappingURL=ResultPoint.js.map"]},"metadata":{},"sourceType":"script"}
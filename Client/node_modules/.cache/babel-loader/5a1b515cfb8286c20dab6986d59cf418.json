{"ast":null,"code":"\"use strict\";\n/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar BitMatrix_1 = require(\"../../common/BitMatrix\");\n\nvar GenericGF_1 = require(\"../../common/reedsolomon/GenericGF\");\n\nvar ReedSolomonDecoder_1 = require(\"../../common/reedsolomon/ReedSolomonDecoder\");\n\nvar BitMatrixParser_1 = require(\"./BitMatrixParser\");\n\nvar QRCodeDecoderMetaData_1 = require(\"./QRCodeDecoderMetaData\");\n\nvar DataBlock_1 = require(\"./DataBlock\");\n\nvar DecodedBitStreamParser_1 = require(\"./DecodedBitStreamParser\");\n\nvar ChecksumException_1 = require(\"../../ChecksumException\");\n/*import java.util.Map;*/\n\n/**\r\n * <p>The main class which implements QR Code decoding -- as opposed to locating and extracting\r\n * the QR Code from an image.</p>\r\n *\r\n * @author Sean Owen\r\n */\n\n\nvar Decoder =\n/** @class */\nfunction () {\n  function Decoder() {\n    this.rsDecoder = new ReedSolomonDecoder_1.default(GenericGF_1.default.QR_CODE_FIELD_256);\n  } // public decode(image: boolean[][]): DecoderResult /*throws ChecksumException, FormatException*/ {\n  //   return decode(image, null)\n  // }\n\n  /**\r\n   * <p>Convenience method that can decode a QR Code represented as a 2D array of booleans.\r\n   * \"true\" is taken to mean a black module.</p>\r\n   *\r\n   * @param image booleans representing white/black QR Code modules\r\n   * @param hints decoding hints that should be used to influence decoding\r\n   * @return text and bytes encoded within the QR Code\r\n   * @throws FormatException if the QR Code cannot be decoded\r\n   * @throws ChecksumException if error correction fails\r\n   */\n\n\n  Decoder.prototype.decodeBooleanArray = function (image, hints) {\n    return this.decodeBitMatrix(BitMatrix_1.default.parseFromBooleanArray(image), hints);\n  }; // public decodeBitMatrix(bits: BitMatrix): DecoderResult /*throws ChecksumException, FormatException*/ {\n  //   return decode(bits, null)\n  // }\n\n  /**\r\n   * <p>Decodes a QR Code represented as a {@link BitMatrix}. A 1 or \"true\" is taken to mean a black module.</p>\r\n   *\r\n   * @param bits booleans representing white/black QR Code modules\r\n   * @param hints decoding hints that should be used to influence decoding\r\n   * @return text and bytes encoded within the QR Code\r\n   * @throws FormatException if the QR Code cannot be decoded\r\n   * @throws ChecksumException if error correction fails\r\n   */\n\n\n  Decoder.prototype.decodeBitMatrix = function (bits, hints) {\n    // Construct a parser and read version, error-correction level\n    var parser = new BitMatrixParser_1.default(bits);\n    var ex = null;\n\n    try {\n      return this.decodeBitMatrixParser(parser, hints);\n    } catch (e\n    /*: FormatException, ChecksumException*/\n    ) {\n      ex = e;\n    }\n\n    try {\n      // Revert the bit matrix\n      parser.remask(); // Will be attempting a mirrored reading of the version and format info.\n\n      parser.setMirror(true); // Preemptively read the version.\n\n      parser.readVersion(); // Preemptively read the format information.\n\n      parser.readFormatInformation();\n      /*\r\n       * Since we're here, this means we have successfully detected some kind\r\n       * of version and format information when mirrored. This is a good sign,\r\n       * that the QR code may be mirrored, and we should try once more with a\r\n       * mirrored content.\r\n       */\n      // Prepare for a mirrored reading.\n\n      parser.mirror();\n      var result = this.decodeBitMatrixParser(parser, hints); // Success! Notify the caller that the code was mirrored.\n\n      result.setOther(new QRCodeDecoderMetaData_1.default(true));\n      return result;\n    } catch (e\n    /*FormatException | ChecksumException*/\n    ) {\n      // Throw the exception from the original reading\n      if (ex !== null) {\n        throw ex;\n      }\n\n      throw e;\n    }\n  };\n\n  Decoder.prototype.decodeBitMatrixParser = function (parser, hints) {\n    var e_1, _a, e_2, _b;\n\n    var version = parser.readVersion();\n    var ecLevel = parser.readFormatInformation().getErrorCorrectionLevel(); // Read codewords\n\n    var codewords = parser.readCodewords(); // Separate into data blocks\n\n    var dataBlocks = DataBlock_1.default.getDataBlocks(codewords, version, ecLevel); // Count total number of data bytes\n\n    var totalBytes = 0;\n\n    try {\n      for (var dataBlocks_1 = __values(dataBlocks), dataBlocks_1_1 = dataBlocks_1.next(); !dataBlocks_1_1.done; dataBlocks_1_1 = dataBlocks_1.next()) {\n        var dataBlock = dataBlocks_1_1.value;\n        totalBytes += dataBlock.getNumDataCodewords();\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (dataBlocks_1_1 && !dataBlocks_1_1.done && (_a = dataBlocks_1.return)) _a.call(dataBlocks_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    var resultBytes = new Uint8Array(totalBytes);\n    var resultOffset = 0;\n\n    try {\n      // Error-correct and copy data blocks together into a stream of bytes\n      for (var dataBlocks_2 = __values(dataBlocks), dataBlocks_2_1 = dataBlocks_2.next(); !dataBlocks_2_1.done; dataBlocks_2_1 = dataBlocks_2.next()) {\n        var dataBlock = dataBlocks_2_1.value;\n        var codewordBytes = dataBlock.getCodewords();\n        var numDataCodewords = dataBlock.getNumDataCodewords();\n        this.correctErrors(codewordBytes, numDataCodewords);\n\n        for (var i = 0; i < numDataCodewords; i++) {\n          resultBytes[resultOffset++] = codewordBytes[i];\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (dataBlocks_2_1 && !dataBlocks_2_1.done && (_b = dataBlocks_2.return)) _b.call(dataBlocks_2);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    } // Decode the contents of that stream of bytes\n\n\n    return DecodedBitStreamParser_1.default.decode(resultBytes, version, ecLevel, hints);\n  };\n  /**\r\n   * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to\r\n   * correct the errors in-place using Reed-Solomon error correction.</p>\r\n   *\r\n   * @param codewordBytes data and error correction codewords\r\n   * @param numDataCodewords number of codewords that are data bytes\r\n   * @throws ChecksumException if error correction fails\r\n   */\n\n\n  Decoder.prototype.correctErrors = function (codewordBytes, numDataCodewords\n  /*int*/\n  ) {\n    var numCodewords = codewordBytes.length; // First read into an array of ints\n\n    var codewordsInts = new Int32Array(codewordBytes); // TYPESCRIPTPORT: not realy necessary to transform to ints? could redesign everything to work with unsigned bytes?\n    // const codewordsInts = new Int32Array(numCodewords)\n    // for (let i = 0; i < numCodewords; i++) {\n    //   codewordsInts[i] = codewordBytes[i] & 0xFF\n    // }\n\n    try {\n      this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);\n    } catch (ignored\n    /*: ReedSolomonException*/\n    ) {\n      throw new ChecksumException_1.default();\n    } // Copy back into array of bytes -- only need to worry about the bytes that were data\n    // We don't care about errors in the error-correction codewords\n\n\n    for (var i = 0; i < numDataCodewords; i++) {\n      codewordBytes[i] =\n      /*(byte) */\n      codewordsInts[i];\n    }\n  };\n\n  return Decoder;\n}();\n\nexports.default = Decoder;","map":{"version":3,"sources":["../../../../src/core/qrcode/decoder/Decoder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar __values = (this && this.__values) || function (o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar BitMatrix_1 = require(\"../../common/BitMatrix\");\r\nvar GenericGF_1 = require(\"../../common/reedsolomon/GenericGF\");\r\nvar ReedSolomonDecoder_1 = require(\"../../common/reedsolomon/ReedSolomonDecoder\");\r\nvar BitMatrixParser_1 = require(\"./BitMatrixParser\");\r\nvar QRCodeDecoderMetaData_1 = require(\"./QRCodeDecoderMetaData\");\r\nvar DataBlock_1 = require(\"./DataBlock\");\r\nvar DecodedBitStreamParser_1 = require(\"./DecodedBitStreamParser\");\r\nvar ChecksumException_1 = require(\"../../ChecksumException\");\r\n/*import java.util.Map;*/\r\n/**\r\n * <p>The main class which implements QR Code decoding -- as opposed to locating and extracting\r\n * the QR Code from an image.</p>\r\n *\r\n * @author Sean Owen\r\n */\r\nvar Decoder = /** @class */ (function () {\r\n    function Decoder() {\r\n        this.rsDecoder = new ReedSolomonDecoder_1.default(GenericGF_1.default.QR_CODE_FIELD_256);\r\n    }\r\n    // public decode(image: boolean[][]): DecoderResult /*throws ChecksumException, FormatException*/ {\r\n    //   return decode(image, null)\r\n    // }\r\n    /**\r\n     * <p>Convenience method that can decode a QR Code represented as a 2D array of booleans.\r\n     * \"true\" is taken to mean a black module.</p>\r\n     *\r\n     * @param image booleans representing white/black QR Code modules\r\n     * @param hints decoding hints that should be used to influence decoding\r\n     * @return text and bytes encoded within the QR Code\r\n     * @throws FormatException if the QR Code cannot be decoded\r\n     * @throws ChecksumException if error correction fails\r\n     */\r\n    Decoder.prototype.decodeBooleanArray = function (image, hints) {\r\n        return this.decodeBitMatrix(BitMatrix_1.default.parseFromBooleanArray(image), hints);\r\n    };\r\n    // public decodeBitMatrix(bits: BitMatrix): DecoderResult /*throws ChecksumException, FormatException*/ {\r\n    //   return decode(bits, null)\r\n    // }\r\n    /**\r\n     * <p>Decodes a QR Code represented as a {@link BitMatrix}. A 1 or \"true\" is taken to mean a black module.</p>\r\n     *\r\n     * @param bits booleans representing white/black QR Code modules\r\n     * @param hints decoding hints that should be used to influence decoding\r\n     * @return text and bytes encoded within the QR Code\r\n     * @throws FormatException if the QR Code cannot be decoded\r\n     * @throws ChecksumException if error correction fails\r\n     */\r\n    Decoder.prototype.decodeBitMatrix = function (bits, hints) {\r\n        // Construct a parser and read version, error-correction level\r\n        var parser = new BitMatrixParser_1.default(bits);\r\n        var ex = null;\r\n        try {\r\n            return this.decodeBitMatrixParser(parser, hints);\r\n        }\r\n        catch (e /*: FormatException, ChecksumException*/) {\r\n            ex = e;\r\n        }\r\n        try {\r\n            // Revert the bit matrix\r\n            parser.remask();\r\n            // Will be attempting a mirrored reading of the version and format info.\r\n            parser.setMirror(true);\r\n            // Preemptively read the version.\r\n            parser.readVersion();\r\n            // Preemptively read the format information.\r\n            parser.readFormatInformation();\r\n            /*\r\n             * Since we're here, this means we have successfully detected some kind\r\n             * of version and format information when mirrored. This is a good sign,\r\n             * that the QR code may be mirrored, and we should try once more with a\r\n             * mirrored content.\r\n             */\r\n            // Prepare for a mirrored reading.\r\n            parser.mirror();\r\n            var result = this.decodeBitMatrixParser(parser, hints);\r\n            // Success! Notify the caller that the code was mirrored.\r\n            result.setOther(new QRCodeDecoderMetaData_1.default(true));\r\n            return result;\r\n        }\r\n        catch (e /*FormatException | ChecksumException*/) {\r\n            // Throw the exception from the original reading\r\n            if (ex !== null) {\r\n                throw ex;\r\n            }\r\n            throw e;\r\n        }\r\n    };\r\n    Decoder.prototype.decodeBitMatrixParser = function (parser, hints) {\r\n        var e_1, _a, e_2, _b;\r\n        var version = parser.readVersion();\r\n        var ecLevel = parser.readFormatInformation().getErrorCorrectionLevel();\r\n        // Read codewords\r\n        var codewords = parser.readCodewords();\r\n        // Separate into data blocks\r\n        var dataBlocks = DataBlock_1.default.getDataBlocks(codewords, version, ecLevel);\r\n        // Count total number of data bytes\r\n        var totalBytes = 0;\r\n        try {\r\n            for (var dataBlocks_1 = __values(dataBlocks), dataBlocks_1_1 = dataBlocks_1.next(); !dataBlocks_1_1.done; dataBlocks_1_1 = dataBlocks_1.next()) {\r\n                var dataBlock = dataBlocks_1_1.value;\r\n                totalBytes += dataBlock.getNumDataCodewords();\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (dataBlocks_1_1 && !dataBlocks_1_1.done && (_a = dataBlocks_1.return)) _a.call(dataBlocks_1);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        var resultBytes = new Uint8Array(totalBytes);\r\n        var resultOffset = 0;\r\n        try {\r\n            // Error-correct and copy data blocks together into a stream of bytes\r\n            for (var dataBlocks_2 = __values(dataBlocks), dataBlocks_2_1 = dataBlocks_2.next(); !dataBlocks_2_1.done; dataBlocks_2_1 = dataBlocks_2.next()) {\r\n                var dataBlock = dataBlocks_2_1.value;\r\n                var codewordBytes = dataBlock.getCodewords();\r\n                var numDataCodewords = dataBlock.getNumDataCodewords();\r\n                this.correctErrors(codewordBytes, numDataCodewords);\r\n                for (var i = 0; i < numDataCodewords; i++) {\r\n                    resultBytes[resultOffset++] = codewordBytes[i];\r\n                }\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (dataBlocks_2_1 && !dataBlocks_2_1.done && (_b = dataBlocks_2.return)) _b.call(dataBlocks_2);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n        // Decode the contents of that stream of bytes\r\n        return DecodedBitStreamParser_1.default.decode(resultBytes, version, ecLevel, hints);\r\n    };\r\n    /**\r\n     * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to\r\n     * correct the errors in-place using Reed-Solomon error correction.</p>\r\n     *\r\n     * @param codewordBytes data and error correction codewords\r\n     * @param numDataCodewords number of codewords that are data bytes\r\n     * @throws ChecksumException if error correction fails\r\n     */\r\n    Decoder.prototype.correctErrors = function (codewordBytes, numDataCodewords /*int*/) {\r\n        var numCodewords = codewordBytes.length;\r\n        // First read into an array of ints\r\n        var codewordsInts = new Int32Array(codewordBytes);\r\n        // TYPESCRIPTPORT: not realy necessary to transform to ints? could redesign everything to work with unsigned bytes?\r\n        // const codewordsInts = new Int32Array(numCodewords)\r\n        // for (let i = 0; i < numCodewords; i++) {\r\n        //   codewordsInts[i] = codewordBytes[i] & 0xFF\r\n        // }\r\n        try {\r\n            this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);\r\n        }\r\n        catch (ignored /*: ReedSolomonException*/) {\r\n            throw new ChecksumException_1.default();\r\n        }\r\n        // Copy back into array of bytes -- only need to worry about the bytes that were data\r\n        // We don't care about errors in the error-correction codewords\r\n        for (var i = 0; i < numDataCodewords; i++) {\r\n            codewordBytes[i] = /*(byte) */ codewordsInts[i];\r\n        }\r\n    };\r\n    return Decoder;\r\n}());\r\nexports.default = Decoder;\r\n//# sourceMappingURL=Decoder.js.map"]},"metadata":{},"sourceType":"script"}
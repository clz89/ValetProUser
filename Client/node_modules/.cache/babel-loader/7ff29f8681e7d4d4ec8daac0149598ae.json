{"ast":null,"code":"\"use strict\";\n/*\r\n * Copyright 2009 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar GlobalHistogramBinarizer_1 = require(\"./GlobalHistogramBinarizer\");\n\nvar BitMatrix_1 = require(\"./BitMatrix\");\n/**\r\n * This class implements a local thresholding algorithm, which while slower than the\r\n * GlobalHistogramBinarizer, is fairly efficient for what it does. It is designed for\r\n * high frequency images of barcodes with black data on white backgrounds. For this application,\r\n * it does a much better job than a global blackpoint with severe shadows and gradients.\r\n * However it tends to produce artifacts on lower frequency images and is therefore not\r\n * a good general purpose binarizer for uses outside ZXing.\r\n *\r\n * This class extends GlobalHistogramBinarizer, using the older histogram approach for 1D readers,\r\n * and the newer local approach for 2D readers. 1D decoding using a per-row histogram is already\r\n * inherently local, and only fails for horizontal gradients. We can revisit that problem later,\r\n * but for now it was not a win to use local blocks for 1D.\r\n *\r\n * This Binarizer is the default for the unit tests and the recommended class for library users.\r\n *\r\n * @author dswitkin@google.com (Daniel Switkin)\r\n */\n\n\nvar HybridBinarizer =\n/** @class */\nfunction (_super) {\n  __extends(HybridBinarizer, _super);\n\n  function HybridBinarizer(source) {\n    var _this = _super.call(this, source) || this;\n\n    _this.matrix = null;\n    return _this;\n  }\n  /**\r\n   * Calculates the final BitMatrix once for all requests. This could be called once from the\r\n   * constructor instead, but there are some advantages to doing it lazily, such as making\r\n   * profiling easier, and not doing heavy lifting when callers don't expect it.\r\n   */\n\n  /*@Override*/\n\n\n  HybridBinarizer.prototype.getBlackMatrix = function () {\n    if (this.matrix !== null) {\n      return this.matrix;\n    }\n\n    var source = this.getLuminanceSource();\n    var width = source.getWidth();\n    var height = source.getHeight();\n\n    if (width >= HybridBinarizer.MINIMUM_DIMENSION && height >= HybridBinarizer.MINIMUM_DIMENSION) {\n      var luminances = source.getMatrix();\n      var subWidth = width >> HybridBinarizer.BLOCK_SIZE_POWER;\n\n      if ((width & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {\n        subWidth++;\n      }\n\n      var subHeight = height >> HybridBinarizer.BLOCK_SIZE_POWER;\n\n      if ((height & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {\n        subHeight++;\n      }\n\n      var blackPoints = HybridBinarizer.calculateBlackPoints(luminances, subWidth, subHeight, width, height);\n      var newMatrix = new BitMatrix_1.default(width, height);\n      HybridBinarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, newMatrix);\n      this.matrix = newMatrix;\n    } else {\n      // If the image is too small, fall back to the global histogram approach.\n      this.matrix = _super.prototype.getBlackMatrix.call(this);\n    }\n\n    return this.matrix;\n  };\n  /*@Override*/\n\n\n  HybridBinarizer.prototype.createBinarizer = function (source) {\n    return new HybridBinarizer(source);\n  };\n  /**\r\n   * For each block in the image, calculate the average black point using a 5x5 grid\r\n   * of the blocks around it. Also handles the corner cases (fractional blocks are computed based\r\n   * on the last pixels in the row/column which are also used in the previous block).\r\n   */\n\n\n  HybridBinarizer.calculateThresholdForBlock = function (luminances, subWidth\n  /*int*/\n  , subHeight\n  /*int*/\n  , width\n  /*int*/\n  , height\n  /*int*/\n  , blackPoints, matrix) {\n    var maxYOffset = height - HybridBinarizer.BLOCK_SIZE;\n    var maxXOffset = width - HybridBinarizer.BLOCK_SIZE;\n\n    for (var y = 0; y < subHeight; y++) {\n      var yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;\n\n      if (yoffset > maxYOffset) {\n        yoffset = maxYOffset;\n      }\n\n      var top_1 = HybridBinarizer.cap(y, 2, subHeight - 3);\n\n      for (var x = 0; x < subWidth; x++) {\n        var xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;\n\n        if (xoffset > maxXOffset) {\n          xoffset = maxXOffset;\n        }\n\n        var left = HybridBinarizer.cap(x, 2, subWidth - 3);\n        var sum = 0;\n\n        for (var z = -2; z <= 2; z++) {\n          var blackRow = blackPoints[top_1 + z];\n          sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];\n        }\n\n        var average = sum / 25;\n        HybridBinarizer.thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);\n      }\n    }\n  };\n\n  HybridBinarizer.cap = function (value\n  /*int*/\n  , min\n  /*int*/\n  , max\n  /*int*/\n  ) {\n    return value < min ? min : value > max ? max : value;\n  };\n  /**\r\n   * Applies a single threshold to a block of pixels.\r\n   */\n\n\n  HybridBinarizer.thresholdBlock = function (luminances, xoffset\n  /*int*/\n  , yoffset\n  /*int*/\n  , threshold\n  /*int*/\n  , stride\n  /*int*/\n  , matrix) {\n    for (var y = 0, offset = yoffset * stride + xoffset; y < HybridBinarizer.BLOCK_SIZE; y++, offset += stride) {\n      for (var x = 0; x < HybridBinarizer.BLOCK_SIZE; x++) {\n        // Comparison needs to be <= so that black == 0 pixels are black even if the threshold is 0.\n        if ((luminances[offset + x] & 0xFF) <= threshold) {\n          matrix.set(xoffset + x, yoffset + y);\n        }\n      }\n    }\n  };\n  /**\r\n   * Calculates a single black point for each block of pixels and saves it away.\r\n   * See the following thread for a discussion of this algorithm:\r\n   *  http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0\r\n   */\n\n\n  HybridBinarizer.calculateBlackPoints = function (luminances, subWidth\n  /*int*/\n  , subHeight\n  /*int*/\n  , width\n  /*int*/\n  , height\n  /*int*/\n  ) {\n    var maxYOffset = height - HybridBinarizer.BLOCK_SIZE;\n    var maxXOffset = width - HybridBinarizer.BLOCK_SIZE; // tslint:disable-next-line:whitespace\n\n    var blackPoints = new Array(subHeight); // subWidth\n\n    for (var y = 0; y < subHeight; y++) {\n      blackPoints[y] = new Int32Array(subWidth);\n      var yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;\n\n      if (yoffset > maxYOffset) {\n        yoffset = maxYOffset;\n      }\n\n      for (var x = 0; x < subWidth; x++) {\n        var xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;\n\n        if (xoffset > maxXOffset) {\n          xoffset = maxXOffset;\n        }\n\n        var sum = 0;\n        var min = 0xFF;\n        var max = 0;\n\n        for (var yy = 0, offset = yoffset * width + xoffset; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {\n          for (var xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {\n            var pixel = luminances[offset + xx] & 0xFF;\n            sum += pixel; // still looking for good contrast\n\n            if (pixel < min) {\n              min = pixel;\n            }\n\n            if (pixel > max) {\n              max = pixel;\n            }\n          } // short-circuit min/max tests once dynamic range is met\n\n\n          if (max - min > HybridBinarizer.MIN_DYNAMIC_RANGE) {\n            // finish the rest of the rows quickly\n            for (yy++, offset += width; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {\n              for (var xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {\n                sum += luminances[offset + xx] & 0xFF;\n              }\n            }\n          }\n        } // The default estimate is the average of the values in the block.\n\n\n        var average = sum >> HybridBinarizer.BLOCK_SIZE_POWER * 2;\n\n        if (max - min <= HybridBinarizer.MIN_DYNAMIC_RANGE) {\n          // If variation within the block is low, assume this is a block with only light or only\n          // dark pixels. In that case we do not want to use the average, as it would divide this\n          // low contrast area into black and white pixels, essentially creating data out of noise.\n          //\n          // The default assumption is that the block is light/background. Since no estimate for\n          // the level of dark pixels exists locally, use half the min for the block.\n          average = min / 2;\n\n          if (y > 0 && x > 0) {\n            // Correct the \"white background\" assumption for blocks that have neighbors by comparing\n            // the pixels in this block to the previously calculated black points. This is based on\n            // the fact that dark barcode symbology is always surrounded by some amount of light\n            // background for which reasonable black point estimates were made. The bp estimated at\n            // the boundaries is used for the interior.\n            // The (min < bp) is arbitrary but works better than other heuristics that were tried.\n            var averageNeighborBlackPoint = (blackPoints[y - 1][x] + 2 * blackPoints[y][x - 1] + blackPoints[y - 1][x - 1]) / 4;\n\n            if (min < averageNeighborBlackPoint) {\n              average = averageNeighborBlackPoint;\n            }\n          }\n        }\n\n        blackPoints[y][x] = average;\n      }\n    }\n\n    return blackPoints;\n  }; // This class uses 5x5 blocks to compute local luminance, where each block is 8x8 pixels.\n  // So this is the smallest dimension in each axis we can accept.\n\n\n  HybridBinarizer.BLOCK_SIZE_POWER = 3;\n  HybridBinarizer.BLOCK_SIZE = 1 << HybridBinarizer.BLOCK_SIZE_POWER; // ...0100...00\n\n  HybridBinarizer.BLOCK_SIZE_MASK = HybridBinarizer.BLOCK_SIZE - 1; // ...0011...11\n\n  HybridBinarizer.MINIMUM_DIMENSION = HybridBinarizer.BLOCK_SIZE * 5;\n  HybridBinarizer.MIN_DYNAMIC_RANGE = 24;\n  return HybridBinarizer;\n}(GlobalHistogramBinarizer_1.default);\n\nexports.default = HybridBinarizer;","map":{"version":3,"sources":["../../../src/core/common/HybridBinarizer.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;AAcG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMH,IAAA,0BAAA,GAAA,OAAA,CAAA,4BAAA,CAAA;;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AAEA;;;;;;;;;;;;;;;;AAgBG;;;AACH,IAAA,eAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAA6C,EAAA,SAAA,CAAA,eAAA,EAAA,MAAA,CAAA;;AAYzC,WAAA,eAAA,CAAmB,MAAnB,EAA0C;AAA1C,QAAA,KAAA,GACI,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,MAAN,KAAa,IADjB;;AAFQ,IAAA,KAAA,CAAA,MAAA,GAA2B,IAA3B;;AAIP;AAED;;;;AAIG;;AACH;;;AACO,EAAA,eAAA,CAAA,SAAA,CAAA,cAAA,GAAP,YAAA;AACI,QAAI,KAAK,MAAL,KAAgB,IAApB,EAA0B;AACtB,aAAO,KAAK,MAAZ;AACH;;AACD,QAAM,MAAM,GAAG,KAAK,kBAAL,EAAf;AACA,QAAM,KAAK,GAAG,MAAM,CAAC,QAAP,EAAd;AACA,QAAM,MAAM,GAAG,MAAM,CAAC,SAAP,EAAf;;AACA,QAAI,KAAK,IAAI,eAAe,CAAC,iBAAzB,IAA8C,MAAM,IAAI,eAAe,CAAC,iBAA5E,EAA+F;AAC3F,UAAM,UAAU,GAAG,MAAM,CAAC,SAAP,EAAnB;AACA,UAAI,QAAQ,GAAG,KAAK,IAAI,eAAe,CAAC,gBAAxC;;AACA,UAAI,CAAC,KAAK,GAAG,eAAe,CAAC,eAAzB,MAA8C,CAAlD,EAAqD;AACjD,QAAA,QAAQ;AACX;;AACD,UAAI,SAAS,GAAG,MAAM,IAAI,eAAe,CAAC,gBAA1C;;AACA,UAAI,CAAC,MAAM,GAAG,eAAe,CAAC,eAA1B,MAA+C,CAAnD,EAAsD;AAClD,QAAA,SAAS;AACZ;;AACD,UAAM,WAAW,GAAG,eAAe,CAAC,oBAAhB,CAAqC,UAArC,EAAiD,QAAjD,EAA2D,SAA3D,EAAsE,KAAtE,EAA6E,MAA7E,CAApB;AAEA,UAAM,SAAS,GAAG,IAAI,WAAA,CAAA,OAAJ,CAAc,KAAd,EAAqB,MAArB,CAAlB;AACA,MAAA,eAAe,CAAC,0BAAhB,CAA2C,UAA3C,EAAuD,QAAvD,EAAiE,SAAjE,EAA4E,KAA5E,EAAmF,MAAnF,EAA2F,WAA3F,EAAwG,SAAxG;AACA,WAAK,MAAL,GAAc,SAAd;AACH,KAfD,MAeO;AACH;AACA,WAAK,MAAL,GAAc,MAAA,CAAA,SAAA,CAAM,cAAN,CAAoB,IAApB,CAAoB,IAApB,CAAd;AACH;;AACD,WAAO,KAAK,MAAZ;AACH,GA3BM;AA6BP;;;AACO,EAAA,eAAA,CAAA,SAAA,CAAA,eAAA,GAAP,UAAuB,MAAvB,EAA8C;AAC1C,WAAO,IAAI,eAAJ,CAAoB,MAApB,CAAP;AACH,GAFM;AAIP;;;;AAIG;;;AACY,EAAA,eAAA,CAAA,0BAAA,GAAf,UAA0C,UAA1C,EACI;AAAiB;AADrB,IAEI;AAAkB;AAFtB,IAGI;AAAc;AAHlB,IAII;AAAe;AAJnB,IAKI,WALJ,EAMI,MANJ,EAMqB;AACjB,QAAM,UAAU,GAAG,MAAM,GAAG,eAAe,CAAC,UAA5C;AACA,QAAM,UAAU,GAAG,KAAK,GAAG,eAAe,CAAC,UAA3C;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAApB,EAA+B,CAAC,EAAhC,EAAoC;AAChC,UAAI,OAAO,GAAG,CAAC,IAAI,eAAe,CAAC,gBAAnC;;AACA,UAAI,OAAO,GAAG,UAAd,EAA0B;AACtB,QAAA,OAAO,GAAG,UAAV;AACH;;AACD,UAAM,KAAG,GAAG,eAAe,CAAC,GAAhB,CAAoB,CAApB,EAAuB,CAAvB,EAA0B,SAAS,GAAG,CAAtC,CAAZ;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,QAApB,EAA8B,CAAC,EAA/B,EAAmC;AAC/B,YAAI,OAAO,GAAG,CAAC,IAAI,eAAe,CAAC,gBAAnC;;AACA,YAAI,OAAO,GAAG,UAAd,EAA0B;AACtB,UAAA,OAAO,GAAG,UAAV;AACH;;AACD,YAAM,IAAI,GAAG,eAAe,CAAC,GAAhB,CAAoB,CAApB,EAAuB,CAAvB,EAA0B,QAAQ,GAAG,CAArC,CAAb;AACA,YAAI,GAAG,GAAG,CAAV;;AACA,aAAK,IAAI,CAAC,GAAG,CAAC,CAAd,EAAiB,CAAC,IAAI,CAAtB,EAAyB,CAAC,EAA1B,EAA8B;AAC1B,cAAM,QAAQ,GAAG,WAAW,CAAC,KAAG,GAAG,CAAP,CAA5B;AACA,UAAA,GAAG,IAAI,QAAQ,CAAC,IAAI,GAAG,CAAR,CAAR,GAAqB,QAAQ,CAAC,IAAI,GAAG,CAAR,CAA7B,GAA0C,QAAQ,CAAC,IAAD,CAAlD,GAA2D,QAAQ,CAAC,IAAI,GAAG,CAAR,CAAnE,GAAgF,QAAQ,CAAC,IAAI,GAAG,CAAR,CAA/F;AACH;;AACD,YAAM,OAAO,GAAG,GAAG,GAAG,EAAtB;AACA,QAAA,eAAe,CAAC,cAAhB,CAA+B,UAA/B,EAA2C,OAA3C,EAAoD,OAApD,EAA6D,OAA7D,EAAsE,KAAtE,EAA6E,MAA7E;AACH;AACJ;AACJ,GA9Bc;;AAgCA,EAAA,eAAA,CAAA,GAAA,GAAf,UAAmB;AAAc;AAAjC,IAA0C;AAAY;AAAtD,IAA+D;AAAY;AAA3E,IAAkF;AAC9E,WAAO,KAAK,GAAG,GAAR,GAAc,GAAd,GAAoB,KAAK,GAAG,GAAR,GAAc,GAAd,GAAoB,KAA/C;AACH,GAFc;AAIf;;AAEG;;;AACY,EAAA,eAAA,CAAA,cAAA,GAAf,UAA8B,UAA9B,EACI;AAAgB;AADpB,IAEI;AAAgB;AAFpB,IAGI;AAAkB;AAHtB,IAII;AAAe;AAJnB,IAKI,MALJ,EAKqB;AACjB,SAAK,IAAI,CAAC,GAAG,CAAR,EAAW,MAAM,GAAG,OAAO,GAAG,MAAV,GAAmB,OAA5C,EAAqD,CAAC,GAAG,eAAe,CAAC,UAAzE,EAAqF,CAAC,IAAK,MAAM,IAAI,MAArG,EAA6G;AACzG,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,eAAe,CAAC,UAApC,EAAgD,CAAC,EAAjD,EAAqD;AACjD;AACA,YAAI,CAAC,UAAU,CAAC,MAAM,GAAG,CAAV,CAAV,GAAyB,IAA1B,KAAmC,SAAvC,EAAkD;AAC9C,UAAA,MAAM,CAAC,GAAP,CAAW,OAAO,GAAG,CAArB,EAAwB,OAAO,GAAG,CAAlC;AACH;AACJ;AACJ;AACJ,GAdc;AAgBf;;;;AAIG;;;AACY,EAAA,eAAA,CAAA,oBAAA,GAAf,UAAoC,UAApC,EACI;AAAiB;AADrB,IAEI;AAAkB;AAFtB,IAGI;AAAc;AAHlB,IAII;AAAe;AAJnB,IAI0B;AACtB,QAAM,UAAU,GAAG,MAAM,GAAG,eAAe,CAAC,UAA5C;AACA,QAAM,UAAU,GAAG,KAAK,GAAG,eAAe,CAAC,UAA3C,CAFsB,CAGtB;;AACA,QAAM,WAAW,GAAG,IAAI,KAAJ,CAAsB,SAAtB,CAApB,CAJsB,CAI+B;;AAErD,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAApB,EAA+B,CAAC,EAAhC,EAAoC;AAChC,MAAA,WAAW,CAAC,CAAD,CAAX,GAAiB,IAAI,UAAJ,CAAe,QAAf,CAAjB;AACA,UAAI,OAAO,GAAG,CAAC,IAAI,eAAe,CAAC,gBAAnC;;AACA,UAAI,OAAO,GAAG,UAAd,EAA0B;AACtB,QAAA,OAAO,GAAG,UAAV;AACH;;AACD,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,QAApB,EAA8B,CAAC,EAA/B,EAAmC;AAC/B,YAAI,OAAO,GAAG,CAAC,IAAI,eAAe,CAAC,gBAAnC;;AACA,YAAI,OAAO,GAAG,UAAd,EAA0B;AACtB,UAAA,OAAO,GAAG,UAAV;AACH;;AACD,YAAI,GAAG,GAAG,CAAV;AACA,YAAI,GAAG,GAAG,IAAV;AACA,YAAI,GAAG,GAAG,CAAV;;AACA,aAAK,IAAI,EAAE,GAAG,CAAT,EAAY,MAAM,GAAG,OAAO,GAAG,KAAV,GAAkB,OAA5C,EAAqD,EAAE,GAAG,eAAe,CAAC,UAA1E,EAAsF,EAAE,IAAK,MAAM,IAAI,KAAvG,EAA8G;AAC1G,eAAK,IAAI,EAAE,GAAG,CAAd,EAAiB,EAAE,GAAG,eAAe,CAAC,UAAtC,EAAkD,EAAE,EAApD,EAAwD;AACpD,gBAAM,KAAK,GAAG,UAAU,CAAC,MAAM,GAAG,EAAV,CAAV,GAA0B,IAAxC;AACA,YAAA,GAAG,IAAI,KAAP,CAFoD,CAGpD;;AACA,gBAAI,KAAK,GAAG,GAAZ,EAAiB;AACb,cAAA,GAAG,GAAG,KAAN;AACH;;AACD,gBAAI,KAAK,GAAG,GAAZ,EAAiB;AACb,cAAA,GAAG,GAAG,KAAN;AACH;AACJ,WAXyG,CAY1G;;;AACA,cAAI,GAAG,GAAG,GAAN,GAAY,eAAe,CAAC,iBAAhC,EAAmD;AAC/C;AACA,iBAAK,EAAE,IAAK,MAAM,IAAI,KAAtB,EAA6B,EAAE,GAAG,eAAe,CAAC,UAAlD,EAA8D,EAAE,IAAK,MAAM,IAAI,KAA/E,EAAsF;AAClF,mBAAK,IAAI,EAAE,GAAG,CAAd,EAAiB,EAAE,GAAG,eAAe,CAAC,UAAtC,EAAkD,EAAE,EAApD,EAAwD;AACpD,gBAAA,GAAG,IAAI,UAAU,CAAC,MAAM,GAAG,EAAV,CAAV,GAA0B,IAAjC;AACH;AACJ;AACJ;AACJ,SA7B8B,CA+B/B;;;AACA,YAAI,OAAO,GAAG,GAAG,IAAK,eAAe,CAAC,gBAAhB,GAAmC,CAAzD;;AACA,YAAI,GAAG,GAAG,GAAN,IAAa,eAAe,CAAC,iBAAjC,EAAoD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,UAAA,OAAO,GAAG,GAAG,GAAG,CAAhB;;AAEA,cAAI,CAAC,GAAG,CAAJ,IAAS,CAAC,GAAG,CAAjB,EAAoB;AAChB;AACA;AACA;AACA;AACA;AAEA;AACA,gBAAM,yBAAyB,GAC3B,CAAC,WAAW,CAAC,CAAC,GAAG,CAAL,CAAX,CAAmB,CAAnB,IAAyB,IAAI,WAAW,CAAC,CAAD,CAAX,CAAe,CAAC,GAAG,CAAnB,CAA7B,GAAsD,WAAW,CAAC,CAAC,GAAG,CAAL,CAAX,CAAmB,CAAC,GAAG,CAAvB,CAAvD,IAAoF,CADxF;;AAEA,gBAAI,GAAG,GAAG,yBAAV,EAAqC;AACjC,cAAA,OAAO,GAAG,yBAAV;AACH;AACJ;AACJ;;AACD,QAAA,WAAW,CAAC,CAAD,CAAX,CAAe,CAAf,IAAoB,OAApB;AACH;AACJ;;AACD,WAAO,WAAP;AACH,GA7Ec,CAzHnB,CAEI;AACA;;;AACe,EAAA,eAAA,CAAA,gBAAA,GAAmB,CAAnB;AACA,EAAA,eAAA,CAAA,UAAA,GAAa,KAAK,eAAe,CAAC,gBAAlC,CALnB,CAKuE;;AACpD,EAAA,eAAA,CAAA,eAAA,GAAkB,eAAe,CAAC,UAAhB,GAA6B,CAA/C,CANnB,CAMuE;;AACpD,EAAA,eAAA,CAAA,iBAAA,GAAoB,eAAe,CAAC,UAAhB,GAA6B,CAAjD;AACA,EAAA,eAAA,CAAA,iBAAA,GAAoB,EAApB;AAgMnB,SAAA,eAAA;AAAC,CAxMD,CAA6C,0BAAA,CAAA,OAA7C,CAAA;;kBAAqB,e","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/*\r\n * Copyright 2009 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar GlobalHistogramBinarizer_1 = require(\"./GlobalHistogramBinarizer\");\r\nvar BitMatrix_1 = require(\"./BitMatrix\");\r\n/**\r\n * This class implements a local thresholding algorithm, which while slower than the\r\n * GlobalHistogramBinarizer, is fairly efficient for what it does. It is designed for\r\n * high frequency images of barcodes with black data on white backgrounds. For this application,\r\n * it does a much better job than a global blackpoint with severe shadows and gradients.\r\n * However it tends to produce artifacts on lower frequency images and is therefore not\r\n * a good general purpose binarizer for uses outside ZXing.\r\n *\r\n * This class extends GlobalHistogramBinarizer, using the older histogram approach for 1D readers,\r\n * and the newer local approach for 2D readers. 1D decoding using a per-row histogram is already\r\n * inherently local, and only fails for horizontal gradients. We can revisit that problem later,\r\n * but for now it was not a win to use local blocks for 1D.\r\n *\r\n * This Binarizer is the default for the unit tests and the recommended class for library users.\r\n *\r\n * @author dswitkin@google.com (Daniel Switkin)\r\n */\r\nvar HybridBinarizer = /** @class */ (function (_super) {\r\n    __extends(HybridBinarizer, _super);\r\n    function HybridBinarizer(source) {\r\n        var _this = _super.call(this, source) || this;\r\n        _this.matrix = null;\r\n        return _this;\r\n    }\r\n    /**\r\n     * Calculates the final BitMatrix once for all requests. This could be called once from the\r\n     * constructor instead, but there are some advantages to doing it lazily, such as making\r\n     * profiling easier, and not doing heavy lifting when callers don't expect it.\r\n     */\r\n    /*@Override*/\r\n    HybridBinarizer.prototype.getBlackMatrix = function () {\r\n        if (this.matrix !== null) {\r\n            return this.matrix;\r\n        }\r\n        var source = this.getLuminanceSource();\r\n        var width = source.getWidth();\r\n        var height = source.getHeight();\r\n        if (width >= HybridBinarizer.MINIMUM_DIMENSION && height >= HybridBinarizer.MINIMUM_DIMENSION) {\r\n            var luminances = source.getMatrix();\r\n            var subWidth = width >> HybridBinarizer.BLOCK_SIZE_POWER;\r\n            if ((width & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {\r\n                subWidth++;\r\n            }\r\n            var subHeight = height >> HybridBinarizer.BLOCK_SIZE_POWER;\r\n            if ((height & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {\r\n                subHeight++;\r\n            }\r\n            var blackPoints = HybridBinarizer.calculateBlackPoints(luminances, subWidth, subHeight, width, height);\r\n            var newMatrix = new BitMatrix_1.default(width, height);\r\n            HybridBinarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, newMatrix);\r\n            this.matrix = newMatrix;\r\n        }\r\n        else {\r\n            // If the image is too small, fall back to the global histogram approach.\r\n            this.matrix = _super.prototype.getBlackMatrix.call(this);\r\n        }\r\n        return this.matrix;\r\n    };\r\n    /*@Override*/\r\n    HybridBinarizer.prototype.createBinarizer = function (source) {\r\n        return new HybridBinarizer(source);\r\n    };\r\n    /**\r\n     * For each block in the image, calculate the average black point using a 5x5 grid\r\n     * of the blocks around it. Also handles the corner cases (fractional blocks are computed based\r\n     * on the last pixels in the row/column which are also used in the previous block).\r\n     */\r\n    HybridBinarizer.calculateThresholdForBlock = function (luminances, subWidth /*int*/, subHeight /*int*/, width /*int*/, height /*int*/, blackPoints, matrix) {\r\n        var maxYOffset = height - HybridBinarizer.BLOCK_SIZE;\r\n        var maxXOffset = width - HybridBinarizer.BLOCK_SIZE;\r\n        for (var y = 0; y < subHeight; y++) {\r\n            var yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;\r\n            if (yoffset > maxYOffset) {\r\n                yoffset = maxYOffset;\r\n            }\r\n            var top_1 = HybridBinarizer.cap(y, 2, subHeight - 3);\r\n            for (var x = 0; x < subWidth; x++) {\r\n                var xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;\r\n                if (xoffset > maxXOffset) {\r\n                    xoffset = maxXOffset;\r\n                }\r\n                var left = HybridBinarizer.cap(x, 2, subWidth - 3);\r\n                var sum = 0;\r\n                for (var z = -2; z <= 2; z++) {\r\n                    var blackRow = blackPoints[top_1 + z];\r\n                    sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];\r\n                }\r\n                var average = sum / 25;\r\n                HybridBinarizer.thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);\r\n            }\r\n        }\r\n    };\r\n    HybridBinarizer.cap = function (value /*int*/, min /*int*/, max /*int*/) {\r\n        return value < min ? min : value > max ? max : value;\r\n    };\r\n    /**\r\n     * Applies a single threshold to a block of pixels.\r\n     */\r\n    HybridBinarizer.thresholdBlock = function (luminances, xoffset /*int*/, yoffset /*int*/, threshold /*int*/, stride /*int*/, matrix) {\r\n        for (var y = 0, offset = yoffset * stride + xoffset; y < HybridBinarizer.BLOCK_SIZE; y++, offset += stride) {\r\n            for (var x = 0; x < HybridBinarizer.BLOCK_SIZE; x++) {\r\n                // Comparison needs to be <= so that black == 0 pixels are black even if the threshold is 0.\r\n                if ((luminances[offset + x] & 0xFF) <= threshold) {\r\n                    matrix.set(xoffset + x, yoffset + y);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Calculates a single black point for each block of pixels and saves it away.\r\n     * See the following thread for a discussion of this algorithm:\r\n     *  http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0\r\n     */\r\n    HybridBinarizer.calculateBlackPoints = function (luminances, subWidth /*int*/, subHeight /*int*/, width /*int*/, height /*int*/) {\r\n        var maxYOffset = height - HybridBinarizer.BLOCK_SIZE;\r\n        var maxXOffset = width - HybridBinarizer.BLOCK_SIZE;\r\n        // tslint:disable-next-line:whitespace\r\n        var blackPoints = new Array(subHeight); // subWidth\r\n        for (var y = 0; y < subHeight; y++) {\r\n            blackPoints[y] = new Int32Array(subWidth);\r\n            var yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;\r\n            if (yoffset > maxYOffset) {\r\n                yoffset = maxYOffset;\r\n            }\r\n            for (var x = 0; x < subWidth; x++) {\r\n                var xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;\r\n                if (xoffset > maxXOffset) {\r\n                    xoffset = maxXOffset;\r\n                }\r\n                var sum = 0;\r\n                var min = 0xFF;\r\n                var max = 0;\r\n                for (var yy = 0, offset = yoffset * width + xoffset; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {\r\n                    for (var xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {\r\n                        var pixel = luminances[offset + xx] & 0xFF;\r\n                        sum += pixel;\r\n                        // still looking for good contrast\r\n                        if (pixel < min) {\r\n                            min = pixel;\r\n                        }\r\n                        if (pixel > max) {\r\n                            max = pixel;\r\n                        }\r\n                    }\r\n                    // short-circuit min/max tests once dynamic range is met\r\n                    if (max - min > HybridBinarizer.MIN_DYNAMIC_RANGE) {\r\n                        // finish the rest of the rows quickly\r\n                        for (yy++, offset += width; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {\r\n                            for (var xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {\r\n                                sum += luminances[offset + xx] & 0xFF;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                // The default estimate is the average of the values in the block.\r\n                var average = sum >> (HybridBinarizer.BLOCK_SIZE_POWER * 2);\r\n                if (max - min <= HybridBinarizer.MIN_DYNAMIC_RANGE) {\r\n                    // If variation within the block is low, assume this is a block with only light or only\r\n                    // dark pixels. In that case we do not want to use the average, as it would divide this\r\n                    // low contrast area into black and white pixels, essentially creating data out of noise.\r\n                    //\r\n                    // The default assumption is that the block is light/background. Since no estimate for\r\n                    // the level of dark pixels exists locally, use half the min for the block.\r\n                    average = min / 2;\r\n                    if (y > 0 && x > 0) {\r\n                        // Correct the \"white background\" assumption for blocks that have neighbors by comparing\r\n                        // the pixels in this block to the previously calculated black points. This is based on\r\n                        // the fact that dark barcode symbology is always surrounded by some amount of light\r\n                        // background for which reasonable black point estimates were made. The bp estimated at\r\n                        // the boundaries is used for the interior.\r\n                        // The (min < bp) is arbitrary but works better than other heuristics that were tried.\r\n                        var averageNeighborBlackPoint = (blackPoints[y - 1][x] + (2 * blackPoints[y][x - 1]) + blackPoints[y - 1][x - 1]) / 4;\r\n                        if (min < averageNeighborBlackPoint) {\r\n                            average = averageNeighborBlackPoint;\r\n                        }\r\n                    }\r\n                }\r\n                blackPoints[y][x] = average;\r\n            }\r\n        }\r\n        return blackPoints;\r\n    };\r\n    // This class uses 5x5 blocks to compute local luminance, where each block is 8x8 pixels.\r\n    // So this is the smallest dimension in each axis we can accept.\r\n    HybridBinarizer.BLOCK_SIZE_POWER = 3;\r\n    HybridBinarizer.BLOCK_SIZE = 1 << HybridBinarizer.BLOCK_SIZE_POWER; // ...0100...00\r\n    HybridBinarizer.BLOCK_SIZE_MASK = HybridBinarizer.BLOCK_SIZE - 1; // ...0011...11\r\n    HybridBinarizer.MINIMUM_DIMENSION = HybridBinarizer.BLOCK_SIZE * 5;\r\n    HybridBinarizer.MIN_DYNAMIC_RANGE = 24;\r\n    return HybridBinarizer;\r\n}(GlobalHistogramBinarizer_1.default));\r\nexports.default = HybridBinarizer;\r\n//# sourceMappingURL=HybridBinarizer.js.map"]},"metadata":{},"sourceType":"script"}